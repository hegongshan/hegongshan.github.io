<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PAT乙级 1046.划拳 （15 分)]]></title>
    <url>%2F2019%2F03%2F31%2Fpat-basic-1046%2F</url>
    <content type="text"><![CDATA[划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。 下面给出甲、乙两人的划拳记录，请你统计他们最后分别喝了多少杯酒。 输入格式：输入第一行先给出一个正整数 N（≤100），随后 N 行，每行给出一轮划拳的记录，格式为： 1甲喊 甲划 乙喊 乙划 其中喊是喊出的数字，划是划出的数字，均为不超过 100 的正整数（两只手一起划）。 输出格式：在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格分隔。 输入样例：12345658 10 9 125 10 5 103 8 5 1212 18 1 134 16 12 15 输出样例：11 2 分析:设aCount和bCount分别表示甲、乙两人喝酒的杯数，aSay和bSay分别表示甲、乙喊出的数字，aGive和bGive分别表示甲、乙划出的数字。 本题共有四种情况，对应三种结果： 1.甲、乙同赢(aGive == aSay + bSay &amp;&amp; bGive == aSay + bSay)或同输(aGive != aSay + bSay &amp;&amp; bGive != aSay + bSay)：继续下一轮； 2.甲赢(aGive == aSay + bSay)：乙喝酒，即bCount++； 3.乙赢(bGive == aSay + bSay)：甲喝酒，即aCount++。 12345678910111213141516171819202122232425#include &lt;cstdio&gt;int main() &#123; int n, aCount, bCount; aCount = bCount = 0; scanf("%d", &amp;n); while (n--) &#123; int aSay, aGive, bSay, bGive; scanf("%d %d %d %d", &amp;aSay, &amp;aGive, &amp;bSay, &amp;bGive); //1.同赢或同输 if ((aGive == aSay + bSay &amp;&amp; bGive == aSay + bSay) || (aGive != aSay + bSay &amp;&amp; bGive != aSay + bSay)) &#123; continue; &#125; //2.甲赢 if (aGive == aSay + bSay) &#123; bCount++; &#125; else if (bGive == aSay + bSay) &#123; //3.乙赢 aCount++; &#125; &#125; printf("%d %d\n", aCount, bCount); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1026.程序运行时间 （15 分)]]></title>
    <url>%2F2019%2F03%2F28%2Fpat-basic-1026%2F</url>
    <content type="text"><![CDATA[要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。 这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。 输入格式：输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 &lt; C2，并且取值在 [0,10^7]。 输出格式：在一行中输出被测函数运行的时间。运行时间必须按照 hh:mm:ss（即2位的 时:分:秒）格式输出；不足 1 秒的时间四舍五入到秒。 输入样例：1123 4577973 输出样例：112:42:59 分析：由于题目要求“不足 1 秒的时间四舍五入到秒”，所以C2-C1后，先加上50，这样如果（C2-C1）/ 100的小数位大于等于0.5则会进位，小于0.5则会被舍去，从而保证四舍五入到秒。 然后再除以100，得到以秒为单位的总时间n =（C2-C1+50）/ 100。 n / 3600 得到小时数hour，n % 3600 / 60 则得到了分钟数minute ，n % 3600 % 60则得到了秒数second。 123456789101112#include &lt;cstdio&gt;int main() &#123; int c1, c2; scanf("%d %d", &amp;c1, &amp;c2); int n = (c2 - c1 + 50) / 100; int hour = n / 3600; n = n % 3600; int minute = n / 60, second = n % 60; printf("%02d:%02d:%02d\n", hour, minute, second); return 0;&#125; 另一种解法： 使用浮点数来存储以秒为单位的总时间，为最后的秒数second加上0.5，从而保证大于等于0.5的小数位能进位。 12345678910111213#include &lt;cstdio&gt;int main() &#123; int c1, c2; double CLK_TCK = 100.0; scanf("%d %d", &amp;c1, &amp;c2); double seconds = (c2 - c1) / CLK_TCK; int h = seconds / (60 * 60); int m = (seconds - h * 60 * 60) / 60; int s = seconds - h * 60 * 60 - m * 60 + 0.5; printf("%02d:%02d:%02d\n", h, m, s); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1016.部分A+B （15 分)]]></title>
    <url>%2F2019%2F03%2F28%2Fpat-basic-1016%2F</url>
    <content type="text"><![CDATA[正整数 A 的“$D_A​$（为 1 位整数）部分”定义为由 A 中所有 $D_A​$ 组成的新整数 $P_A​$。例如：给定 A=3862767，$D_A​$=6，则 A的“6 部分”$P_A​$是66，因为 A 中有 2 个 6。 现给定 A、$D_A$、B、$D_A$，请编写程序计算 $P_A+P_B$。 输入格式：输入在一行中依次给出 A、$D_A​$、B、$D_B​$，中间以空格分隔，其中 0&lt;A,B&lt;$10^{10}​$。 输出格式：在一行中输出$P_A+P_B​$ 的值。 输入样例 1：13862767 6 13530293 3 输出样例 1：1399 输入样例 2：13862767 1 13530293 8 输出样例 2：10 分析：首先以字符数组（或者字符串）的形式输入A和B， 然后遍历A和B中的每一个字符， 通过减去’0’得到字符的数字形式， 接着，判断其是否等于$D_A$、$D_B$，若等于，则进行进位累加操作。 (1)若从前往后遍历字符数组（或字符串），则累加语句为： pa = 10 * pa + da； (2)若从后往前遍历字符数组（或字符串），则累加语句为 pa += da * carray; carry *= 10;（carry表示进位，初值为1）。 循环结束后，得到$P_A$和$P_B​$ 。 需要注意的是$10^{10}$超过了int的取值范围，故应使用long long 申明$P_A$和$P_B$。 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstring&gt;long long getP(char a[], int da) &#123; long long pa = 0; long long carry = 1;//进位 for (int i = strlen(a) - 1; i &gt;= 0; i--) &#123; if ((a[i] - '0') == da) &#123; pa += da * carry; carry *= 10; &#125; &#125; return pa;&#125;int main() &#123; char a[10], b[10]; int da, db; scanf("%s %d %s %d", a, &amp;da, b, &amp;db); printf("%lld\n", getP(a, da) + getP(b, db)); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1011.A+B 和 C （15 分)]]></title>
    <url>%2F2019%2F03%2F28%2Fpat-basic-1011%2F</url>
    <content type="text"><![CDATA[给定区间 [−2^31,2^31] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。 输入格式：输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行，顺序给出 A、B 和 C。整数间以空格分隔。 输出格式：对每组测试用例，在一行中输出 Case #X: true 如果 A+B&gt;C，否则输出 Case #X: false，其中 X 是测试用例的编号（从 1 开始）。 输入样例：1234541 2 32 3 42147483647 0 21474836460 -2147483648 -2147483647 输出样例：1234Case #1: falseCase #2: trueCase #3: trueCase #4: false 分析：本题有两点需要注意： 1.给定的取值范围为 [−2^31,2^31]，因此，A+B有可能会超过int的取值范围，故A、B和C应申明为long long； 2.输出时编号从1开始。 12345678910111213141516#include &lt;cstdio&gt;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; long long a, b, c; scanf("%d %d %d", &amp;a, &amp;b, &amp;c); if (a + b &gt; c) &#123; printf("Case #%d: true\n", i); &#125; else &#123; printf("Case #%d: false\n", i); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1001.害死人不偿命的(3n+1)猜想 （15 分)]]></title>
    <url>%2F2019%2F03%2F28%2Fpat-basic-1001%2F</url>
    <content type="text"><![CDATA[卡拉兹(Callatz)猜想： 对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？ 输入格式：每个测试输入包含 1 个测试用例，即给出正整数 n 的值。 输出格式：输出从 n 计算到 1 需要的步数。 输入样例：13 输出样例：15 分析：使用count记录总的步数， 如果n为偶数，则令n=n/2； 如果n为奇数，则令n=(3*n+1)/2， 然后步数count++， 直至n==1结束循环。 12345678910111213141516#include &lt;cstdio&gt;int main() &#123; int n, count = 0; scanf("%d", &amp;n); while (n != 1) &#123; if (n % 2 == 0) &#123; n /= 2; &#125; else &#123; n = (3 * n + 1) / 2; &#125; count++; &#125; printf("%d\n", count); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algorithm-advanced-maximum-subsequence-sum]]></title>
    <url>%2F2019%2F03%2F25%2Falgorithm-advanced-maximum-subsequence-sum%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[algorithm-maximum-subsequence-sum]]></title>
    <url>%2F2019%2F03%2F25%2Falgorithm-maximum-subsequence-sum%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[c++中char * a="xxx"引发的警告]]></title>
    <url>%2F2019%2F03%2F21%2Fc-or-cpp-char-pointer-string-constant-unmodified%2F</url>
    <content type="text"><![CDATA[在c++中，当char * 指向字符常量时（以下面的程序为例） 1234567#include &lt;cstdio&gt;int main() &#123; char *a = "I love China!"; printf("%s\n",a); return 0;&#125; 编译时，将产生如下warning： 12345ProblemC.cpp:4:12: warning: conversion from string literal to 'char *' is deprecated [-Wc++11-compat-deprecated-writable-strings] char *a = "I love China!"; ^1 warning generated. 为什么会产生该warning呢？ 因为此时a中存储的是“I love China!”在内存中的首地址，而“I love China!”是字符常量，存放在只读区中。程序员有可能通过a去修改“I love China!”的值，从而导致error。 如何解决该warning呢？ 在定义a时，使用const修饰，表明a所指地址中的内容不允许被修改。示例如下： 1234567#include &lt;cstdio&gt;int main() &#123; const char *a = "I love China!"; printf("%s\n",a); return 0;&#125;]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组元素循环右移问题]]></title>
    <url>%2F2019%2F03%2F15%2Falgorithm-array-right-move%2F</url>
    <content type="text"><![CDATA[本题是中国大学MOOC-陈越、何钦铭-数据结构-起步能力自测题 题目地址：https://pintia.cn/problem-sets/17/problems/262 一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（$A_0 A_1⋯A_{N−1}​$）变换为（$A_{N-M}⋯A_{N−1} A_0 A_1⋯A_{N−M−1}​$）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输入格式:每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。 输出格式:在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 输入样例:126 21 2 3 4 5 6 输出样例:15 6 1 2 3 4 解法一：直接法 算法思路：每次向右移动一位，循环执行m次 代码实现 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int arr[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; for (int i = 0; i &lt; m; i++) &#123; //保存数组的最后一位 int temp = arr[n - 1]; //自后向前，循环后移一位 for (int j = n - 2; j &gt;= 0; j--) &#123; arr[j + 1] = arr[j]; &#125; arr[0] = temp; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i]; if (i != n - 1) &#123; cout &lt;&lt; " "; &#125; &#125;&#125; 时间复杂度：每次向右移动一位，需要执行n次赋值操作，这个过程循环执行m次，所以共执行nm次赋值操作，时间复杂度为O(nm) 解法二：反转法 算法思想 假设N&gt;=M（若N&lt;M，只需令M=M%N即可），数组A中的数据为$A_0 A_1⋯A_{N−1}$，现在需要将数组A循环向右移M个位置，即将$A_{N-M}⋯A_{N−1}$移到数组的前面。 我们可以将数组A中的数据分为两个部分$A_0 A_1⋯A_{N−M-1}$和$A_{N-M}⋯A_{N−1}$来看， （1）先将$A_0 A_1⋯A_{N−M-1}​$反转，得到$A_{N−M-1} ⋯A_1 A_0​$； （2）再将$A_{N-M}⋯A_{N−1}​$反转，得到$A_{N-1}⋯A_{N−M}​$ （3）经过（1）和（2）后，数组A中的数据为$A_{N−M-1} ⋯A_1 A_0 A_{N-1}⋯A_{N−M}$，将数组A中的数据反转，此时数组A中的数据顺序为$A_{N-M}⋯A_{N−1} A_0 A_1⋯A_{N−M−1}$ 代码实现 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int arr[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; if(m &gt; n) &#123; m = m % n; &#125; int temp = 0; // 反转前n-m项 for(int i=0;i&lt;(n-m)/2;i++) &#123; temp = arr[n-m-i-1]; arr[n-m-i-1] = arr[i]; arr[i] = temp; &#125; // 反转后m项 for(int i=n-m;i&lt;n-m/2;i++) &#123; temp = arr[2*n-m-i-1]; arr[2*n-m-i-1] = arr[i]; arr[i] = temp; &#125; // 反转整个数组 for(int i=0;i&lt;n/2;i++) &#123; temp = arr[n-i-1]; arr[n-i-1] = arr[i]; arr[i] = temp; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i]; if (i != n - 1) &#123; cout &lt;&lt; " "; &#125; &#125;&#125; 时间复杂度 三次反转操作，共执行 $3 \times \frac{n-m}{2}+3 \times [n-\frac{m}{2}-(n-m)]+3 \times \frac{n}{2}=3n$次赋值操作，故时间复杂度为O(n)]]></content>
      <categories>
        <category>pat</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《推荐系统实践》4.推荐系统冷启动问题]]></title>
    <url>%2F2019%2F03%2F14%2Frecommend-system-cold-start%2F</url>
    <content type="text"><![CDATA[推荐系统需要根据用户的历史行为和兴趣预测用户未来的行为和兴趣，因此大量的用户行为数据就成为推荐系统的重要组成部分和先决条件。 如何在没有大量用户数据的情况下设计个性化推荐系统并且让用户对推荐结果满意从而愿意使用推荐系统，就是冷启动问题（cold start）。 冷启动分类 用户冷启动：如何给新用户做个性化推荐。 物品冷启动：如何将新的物品推荐给可能对它感兴趣的用户。 系统冷启动：如何在一个新开发的网站上（还没有用户，也没有用户行为，只有一些物品的信息）设计个性化推荐系统，从而在网站刚发布时就让用户体验到个性化推荐服务。 利用用户注册信息1.利用用户的注册信息可以很好地解决注册用户的冷启动问题。 当新用户刚注册时，我们不知道他喜欢什么物品，于是只能给他推荐一些热门的商品。但如果我们知道她是一位女性，那么可以给她推荐女性都喜欢的热门商品。虽然这种个性化的粒度很粗，因为所有刚注册的女性看到的都是同样的结果，但相对于不区分男女的方式，这种推荐的精度已经大大提高了。 2.用户的注册信息分3种： 人口统计学信息：包括用户的年龄、性别、职业、民族、学历和居住地。 用户兴趣的描述：有一些网站会让用户用文字描述他们的兴趣。 从其他网站导入的用户站外行为数据：比如用户通过豆瓣、新浪微博的账号登录，就可以在得到用户同意的情况下获取用户在豆瓣或者新浪微博的一些行为数据和社交网络数据。 3.基于注册信息的个性化推荐流程基本如下: (1) 获取用户的注册信息; (2) 根据用户的注册信息对用户分类; (3) 给用户推荐他所属分类中用户喜欢的物品。 4.基于用户注册信息的推荐算法的核心问题是计算每种特征的用户喜欢的物品。也就是说，对于 每种特征f，计算具有这种特征的用户对各个物品的喜好程度preference(f, i)。 preference( f ,i ) 可以简单地定义为物品i在具有特征f的用户中的热门程度：$$preference(f,i) = |N(i) \cap U(f)| \tag{1}$$其中，N(i)是喜欢物品i的用户集合，U(f)是具有特征f的用户集合。 上面这种定义可以比较准确地预测具有某种特征的用户是否喜欢某个物品。但是，在这种定义下，往往热门的物品会在各种特征的用户中都具有比较高的权重。 因此，我们可以将 preference(f,i) 定义为喜欢物品i的用户中具有特征f的比例:$$preference(f,i) = \frac{|N(i) \cap U(f)|}{|N(i)|+ \alpha} \tag{2}$$这里分母中使用参数$\alpha​$的目的是解决数据稀疏问题。比如有一个物品只被1个用户喜欢过，而这个用户刚好就有特征f，那么就有preference(f,i)=1 。但是，这种情况并没有统计意义，因此我们为分母加上一个比较大的数，可以避免这样的物品产生比较大的权重。 选择合适的物品启动用户的兴趣解决用户冷启动问题的另一个方法是在新用户第一次访问推荐系统时，不立即给用户展示推荐结果，而是给用户提供一些物品，让用户反馈他们对这些物品的兴趣，然后根据用户反馈给提供个性化推荐。 该方法的首要问题是如何选择物品让用户进行反馈。 一般来说，能够用来启动用户兴趣的物品需要具有以下特点: 比较热门 如果要让用户对一个物品进行反馈，前提是用户知道这个物品是什么东西。 以电影为例，如果一开始让用户进行反馈的电影都很冷门，而用户不知道这些电影的情节和内容，也就无法对它们做出准确的反馈。 具有代表性和区分性： 启动用户兴趣的物品不能是大众化或老少咸宜的，因为这样的物品对用户的兴趣没有区分性。 启动物品集合需要有多样性： 在冷启动时，我们不知道用户的兴趣，而用户兴趣的可能性非常多，为了匹配多样的兴趣，我们需要提供具有很高覆盖率的启动物品集合，这些物品能覆盖几乎所有主流的用户兴趣。 利用物品的内容信息对于基于物品的协同过滤算法（以下简称ItemCF）算法来说，物品冷启动是一个严重的问题了。因为ItemCF算法的原理是给用户推荐和他之前喜欢的物品相似的物品。ItemCF算法会每隔一段时间利用用户行为计算物品相似度表(一般一天计算一次)，在线服务时ItemCF算法会将之前计算好的物品相关度矩阵放在内存中。因此，当新物品加入时，内存中的物品相关表中不会存在这个物品，从而ItemCF算法无法推荐新的物品。 解决这一问题的办法是频繁更新物品相似度表，但基于用户行为计算物品相似度是非常耗时的事情，主要原因是用户行为日志非常庞大。而且，新物品如果不展示给用户，用户就无法对它产生行为，通过行为日志计算是计算不出包含新物品的相关矩阵的。为此，我们只能利用物品的内容信息计算物品相关表，并且频繁地更新相关表(比如半小时计算一次)。 一般来说，物品的内容可以通过向量空间模型表示，该模型会将物品表示成一个关键词向量。 从文本生成关键词向量的主要步骤： （1）对于中文，首先要对文本进行分词，将字流变成词流； （2）然后从词流中检测出命名实体(如人名、地名、组织名等)，这些实体和一些其他重要的词将组成关键词集合； （3）最后对关键词进行排名，计算每个关键词的权重，从而生成关键词向量。 对物品d，它的内容表示成一个关键词向量如下:$$d_i = {\left((e_1, w_1),(e_2, w_2),\dots \right)} \tag{3}$$其中，$e_i​$是关键词，$w_i​$是关键词对应的权重。 在给定物品内容的关键词向量后，物品的内容相似度可以通过向量之间的余弦相似度计算$$w_{ij} = \frac{d_i \cdot d_j}{\sqrt{||d_i||\times||d_j||}} \tag{4}$$得到物品的相似度之后，可以利用ItemCF算法的思想，给用户推荐和他历史上喜欢的物品内容相似的物品。]]></content>
      <categories>
        <category>recommend system</category>
      </categories>
      <tags>
        <tag>recommend system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《推荐系统实践》3.基于物品的协同过滤算法]]></title>
    <url>%2F2019%2F03%2F13%2Frecommend-system-item-based-collaborative-filtering%2F</url>
    <content type="text"><![CDATA[基于物品的协同过滤算法（item-based collaborative filtering，以下简称ItemCF）算法思想：给用户推荐那些和他们之前喜欢的物品相似的物品。 不过，ItemCF算法并不利用物品的内容属性计算物品之间的相似度，它主要通过分析用户的行为记录计算物品之间的相似度。该算法认为，物品A和物品B具有很大的相似度是因为喜欢物品A的用户大都也喜欢物品B。 基于物品的协同过滤算法可以利用用户的历史行为给推荐结果提供推荐解释，比如给用户推荐《天龙八部》的解释可以是因为用户之前喜欢《射雕英雄传》。 ItemCF算法主要分为两步。(1) 计算物品之间的相似度。(2) 根据物品的相似度和用户的历史行为给用户生成推荐列表。 计算物品相似度可以用下面的公式定义物品的相似度:$$w_{ij} = \frac {|N(i) \cap N(j)|} {|N(i)|}$$这里，分母|N(i)|是喜欢物品i的用户数，而分子 $|N(i) \cap N(j)|​$ 是同时喜欢物品i和物品j的用户数。因此，上述公式可以理解为喜欢物品i的用户中有多少比例的用户也喜欢物品j。 如果物品j很热门，很多人都喜欢， 那么$w_{ij}​$就会很大，接近1。因此，该公式会造成任何物品都会和热门的物品有很大的相似度。为了避免推荐出热门的物品，可以用下面的公式:$$w_{ij} = \frac{|N(i) \cap N(j)|}{\sqrt{|N(i)||N(j)|}}$$这个公式惩罚了物品j的权重，因此减轻了热门物品会和很多物品相似的可能性。 计算物品相似度时可以首先建立用户—物品倒排表(即对每个用户建立一个包含他喜欢的物品的列表)，然后对于每个用户，将他物品列表中的物品两两在共现矩阵C中加1。 1234567891011121314151617181920212223242526272829import mathfrom collections import defaultdictdef item_similarity(self, trainset): # 物品相似度矩阵 item_similarity_matrix = &#123;&#125; # 物品流行度 item_popularity = &#123;&#125; for user, items in trainset.items(): for item1 in items: # 构造物品相似度矩阵，计算物品共现次数 item_similarity_matrix.setdefault(item1, defaultdict(int)) for item2 in items: if item1 == item2: continue item_similarity_matrix[item1][item2] += 1 # 统计喜欢item1的用户数 if item1 not in item_popularity: item_popularity[item1] = 0 item_popularity[item1] += 1 # 计算最终的相似度矩阵 for item1, releated_items in item_similarity_matrix.items(): for item2, count in releated_items.items(): self.item_similarity_matrix[item1][item2] = count / \ math.sqrt(item_popularity[item1] * item_popularity[item2])return item_similarity_matrix 产生推荐列表在得到物品之间的相似度后，ItemCF通过如下公式计算用户u对一个物品j的兴趣:$$Interestingness_{uj} = \sum_{i \in N(u) \cap S(j,K)} w_{ji}r_{ui}$$这里N(u)是用户喜欢的物品的集合，S(j,K)是和物品j最相似的K个物品的集合,$w_{ji}​$是物品j和i的相似度，$r_{ui}​$是用户u对物品i的兴趣(对于隐反馈数据集，如果用户u对物品i有过行为，即可令 $r_{ui}=1​$。)该公式的含义是，和用户历史上感兴趣的物品越相似的物品，越有可能在用户的推荐列表中获得比较高的排名。 关于物品相似度的一些改进 用户活跃度对物品相似度的影响 John S. Breese在论文“Empirical Analysis of Predictive Algorithms for Collaborative Filtering ”中提出了一个称为IUF(Inverse User Frequence)，即用户活跃度对数的倒数的参数，他认为活跃用户对物品相似度的贡献应该小于不活跃的用户，他提出应该增加IUF参数来修正物品相似度的计算公式：$$w_{ij} = \frac{\sum_{u \in N(i) \cap N(j)} \frac{1}{\log{(1+|N(u)|)}}}{\sqrt{|N(i)||N(j)|}}$$当然，上面的公式只是对活跃用户做了一种软性的惩罚，但对于很多过于活跃的用户，为了避免相似度矩阵过于稠密，我们在实际计算中一般直接忽略他的兴趣列表，而不将其纳入到相似度计算的数据集中。 物品相似度归一化 研究发现，如果将ItemCF的相似度矩阵按最大值归一化，可以提高推荐的准确率。如果已经得到了物品相似度矩阵w，那么可以用如下公式得到归一化之后的相似度矩阵w’:$$w_{ij}^{‘} = \frac{w_{ij}}{\max_j {w_{ij}}}$$归一化的好处不仅仅在于增加推荐的准确度，它还可以提高推荐的覆盖率和多样性。]]></content>
      <categories>
        <category>recommend system</category>
      </categories>
      <tags>
        <tag>recommend system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《推荐系统实践》1.推荐系统评测]]></title>
    <url>%2F2019%2F03%2F04%2Frecommend-system-evaluation-metrics%2F</url>
    <content type="text"><![CDATA[推荐系统实验方法在推荐系统中，主要有3种评测推荐效果的实验方法，即离线实验(offline experiment)、用户调查(user study) 和在线实验(online experiment)。 离线实验离线实验的方法一般由如下几个步骤构成: (1) 通过日志系统获得用户行为数据，并按照一定格式生成一个标准的数据集; (2) 将数据集按照一定的规则分成训练集和测试集; (3) 在训练集上训练用户兴趣模型，在测试集上进行预测; (4) 通过事先定义的离线指标评测算法在测试集上的预测结果。 好处：不需要真实用户参与，可以直接快速地计算出来，从而方便、快速地测试大量不同的算法 缺点：无法获得很多商业上关注的指标，如点击率、转化率等 用户调查用户调查需要有一些真实用户，让他们在需要测试的推荐系统上完成一些任务。在他们完成任务时，我们需要观察和记录他们的行为，并让他们回答一些问题。最后，我们需要通过分析他们的行为和答案了解测试系统的性能。 优点：可以获得很多体现用户主观感受的指标，相对在线实验风险很低，出现错误后很容易弥补 缺点：招募测试用户代价较大，很难组织大规模的测试用户，因此会使测试结果的统计意义不足。 在线实验在完成离线实验和必要的用户调查后，可以将推荐系统上线做AB测试，将它和旧的算法进行比较。 AB测试是一种很常用的在线评测算法的实验方法。它通过一定的规则将用户随机分成几组，并对不同组的用户采用不同的算法，然后通过统计不同组用户的各种不同的评测指标比较不同算法，比如可以统计不同组用户的点击率，通过点击率比较不同算法的性能。 AB测试的优点：可以公平获得不同算法实际在线时的性能指标，包括商业上关注的指标。AB测试的缺点：周期比较长，必须进行长期的实验才能得到可靠的结果。 因此一般不会用AB测试测试所有的算法，而只是用它测试那些在离线实验和用户调查中表现很好的算法。 评测指标在《推荐系统实践》中，作者列举了用户满意度、预测准确度、覆盖率、多样性、新颖性、惊喜度、信任度、实时性、健壮性和商业目标共十种推荐系统的评测指标，这里，我只选取了一部分。 用户满意度用户作为推荐系统的重要参与者，其满意度是评测推荐系统的最重要指标。但是，用户满意度没有办法离线计算，只能通过用户调查或者在线实验获得。 用户调查获得用户满意度主要是通过调查问卷的形式。 在在线系统中，用户满意度主要通过一些对用户行为的统计得到。比如在电子商务网站中，用户如果购买了推荐的商品，就表示他们在一定程度上满意。因此，我们可以利用购买率度量用户的满意度。此外，有些网站会通过设计一些用户反馈界面收集用户满意度。 更一般的情况下，我们可以用点击率、用户停留时间和转化率等指标度量用户的满意度。 预测准确度预测准确度度量一个推荐系统或者推荐算法预测用户行为的能力。 在计算该指标时需要有一个离线的数据集，该数据集包含用户的历史行为记录。然后，将该数据集通过时间分成训练集和测试集。最后，通过在训练集上建立用户的行为和兴趣模型预测用户在测试集上的行为，并计算预测行为和测试集上实际行为的重合度作为预测准确度。 由于离线的推荐算法有不同的研究方向，因此下面将针对不同的研究方向介绍它们的预测准确度指标。 评分预测 预测用户对物品评分的行为称为评分预测（rating prediction）。 评分预测的预测准确度一般通过均方根误差(Root Mean Squared Error，简称RMSE)和平均绝对误差(Mean Absolute Error，简称MAE)计算。对于测试集中的一个用户u和物品i ，令$r_{ui}$是用户对物品i的实际评分，而$\hat{r}_{ui}$是推荐算法给出的预测评分，那么RMSE的定义为 $$RMSE = \frac {\sqrt{\sum_{u,i\in Test}{(r_{ui}-\hat{r}_{ui})^2}}} {|Test|}$$ MAE采用绝对值计算预测误差，它的定义为: $$MAE = \frac {\sum_{u,i\in Test}{|r_{ui}-\hat{r}_{ui}|}} {|Test|}$$ 假设我们用一个列表records存放用户评分数据，令records[i] = [u,i,rui,pui]，其中rui是用户u对物品i的实际评分，pui是算法预测出来的用户u对物品i的评分，那么下面的代码分别实现了RMSE和MAE的计算过程。 123456789import mathdef RMSE(records): return math.sqrt(sum([pow(rui-pui,2) for u,i,rui,pui in records])) \ / float(len(records)) def MAE(records): return sum([abs(rui-pui) for u,i,rui,pui in records]) \ / float(len(records)) TopN推荐 网站在提供推荐服务时，一般是给用户一个个性化的推荐列表，这种推荐叫做TopN推荐。 TopN推荐的预测准确率一般通过准确率(precision)/召回率(recall)度量。 令R(u)是根据用户在训练集上的行为给用户作出的推荐列表，而T(u)是用户在测试集上的行为列表。那么，推荐结果的召回率定义为:$$Recall = \frac {\sum_{u \in U}|R(u) \cap T(u)|} {\sum_{u \in U}|T(u)|}$$推荐结果的准确率定义为：$$Precision = \frac {\sum_{u \in U}|R(u) \cap T(u)|} {\sum_{u \in U}|R(u)|}$$下面用代码同时计算一个推荐算法的准确率和召回率： 1234567891011def PrecisionRecall(test,N): hit = 0 n_recall = 0 n_precision = 0 for user,items in test.items(): rank = Recommend(user,N) # &amp;按位与，表示取两个集合的交集 hit += len(rank &amp; items) n_recall += len(items) n_precision += N return [hit / (1.0 * n_recall), hit / (1.0 * n_precision) 信任度度量推荐系统的信任度只能通过问卷调查的方式，询问用户是否信任推荐系统的推荐结果。 提高推荐系统的信任度主要有两种方法。 1.首先需要增加推荐系统的透明度(transparency)，而增加推荐系统透明度的主要办法是提供推荐解释。只有让用户了解推荐系统的运行机制，让用户认同推荐系统的运行机制，才会提高用户对推荐系统的信任度。 2.其次是考虑用户的社交网络信息，利用用户的好友信息给用户做推荐，并且用好友进行推荐解释。这是因为用户对他们的好友一般都比较信任，因此如果推荐的商品是好友购买过的，那么他们对推荐结果就会相对比较信任。 参考文献《推荐系统实践》，项亮]]></content>
      <categories>
        <category>recommend system</category>
      </categories>
      <tags>
        <tag>recommend system</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 82.删除排序链表中的重复元素 II]]></title>
    <url>%2F2019%2F02%2F27%2Fleetcode-82-remove-duplicates-from-sorted-list-ii%2F</url>
    <content type="text"><![CDATA[题目描述给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 12输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 示例 2: 12输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 解决方案方法一：递归法 思路 按照递归的思想，该题可以分为以下三种情况： 1）待处理的排序链表为空，或者仅含有一个元素。此时，直接返回排序链表的头节点head即可。 2）待处理的排序链表头部节点head的值为重复元素head.val。此时，依次遍历链表，直至找到第一个值不等于head.val的节点node，对node递归执行deleteDuplicates方法。 3）第一个节点head的值不是重复元素。此时，对第二个节点递归执行deleteDuplicates方法即可，产生的新链表成为head的后继。 算法实现 1234567891011121314151617181920212223/*public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;*/class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; //1.如果链表为空或者仅含一个节点 if(head == null || head.next == null) &#123; return head; &#125; //2.如果链表的头部是重复出现的数字 if(head.val == head.next.val) &#123; while(head.next != null &amp;&amp; head.val == head.next.val) &#123; head = head.next; &#125; return deleteDuplicates(head.next); &#125; //3.如果链表首部节点不需要删除 head.next = deleteDuplicates(head.next); return head; &#125;&#125; 复杂度分析 设链表的长度为L 时间复杂度：O(L)，仅对链表执行一次遍历操作 空间复杂度：O(1)，没有使用额外的变量 算法效率 执行用时：1ms，战胜 98.69 % 的 java 提交记录 内存消耗：38.6 MB 方法二：非递归法 思路 首先我们仍将判断待处理的排序链表是否为空，或仅含有一个节点。 然后，我们将添加一个哑结点list作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如，需要删除链表的头部。 在遍历链表的同时，使用while循环寻找与当前节点node值不相等的第一个节点，若while循环得以成功执行，则让得到的新节点成为head的后继；否则，当前节点node与其后继节点值不相等，while循环未被执行，则该节点不需要被删除，head后移。 算法实现 1234567891011121314151617181920212223242526272829/*public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;*/class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null) &#123; return head; &#125; ListNode list = new ListNode(0); list.next = head; head = list; ListNode pre,node; while(head.next != null) &#123; pre = head.next; node = pre; while(node.next != null &amp;&amp; pre.val == node.next.val) &#123; node = node.next; &#125; if(node == pre) &#123; head = head.next; &#125; else &#123; head.next = node.next; &#125; &#125; return list.next; &#125;&#125; 复杂度分析 设链表的长度为L 时间复杂度：O(L)，仅对链表执行一次遍历操作 空间复杂度：O(1)，我们只用了常量级的额外空间 算法效率 执行用时：1ms，战胜 98.69 % 的 java 提交记录 内存消耗：35.2 MB]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 23.合并K个排序链表]]></title>
    <url>%2F2019%2F02%2F22%2Fleetcode-23-merge-k-sorted-lists%2F</url>
    <content type="text"><![CDATA[题目描述合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 算法思路已知K个有序链表，采用二路归并实现两个链表的合并，在此基础上，按照折半查找的思想，递归执行二路归并。 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MergeKSortedLists23 &#123; public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; public ListNode mergeKLists(ListNode[] lists) &#123; if(lists == null || lists.length == 0) &#123; return null; &#125; if(lists.length == 1) &#123; return lists[0]; &#125; return merge(lists,0,lists.length-1); &#125; public ListNode merge(ListNode[] lists,int start,int end) &#123; if(start &gt; end) &#123; return null; &#125; if(start == end) &#123; return lists[start]; &#125; int mid = (start + end) / 2; ListNode l1 = merge(lists,start,mid); ListNode l2 = merge(lists,mid+1,end); return mergeTwoLists(l1,l2); &#125; public ListNode mergeTwoLists(ListNode l1,ListNode l2) &#123; ListNode head = new ListNode(0); ListNode p = l1, q=l2,node,rear = head; while(p != null &amp;&amp; q != null) &#123; if(p.val &lt;= q.val) &#123; node = new ListNode(p.val); p = p.next; &#125; else &#123; node = new ListNode(q.val); q = q.next; &#125; node.next = null; rear.next = node; rear = node; &#125; if(p != null) &#123; rear.next = p; rear = p; &#125; if(q != null) &#123; rear.next = q; rear = q; &#125; return head.next; &#125;&#125; 复杂度分析时间复杂度：O($n\log_2n​$) 空间复杂度：O($n​$) 算法效率执行用时: 11 ms, 在Merge k Sorted Lists的Java提交中击败了92.02% 的用户 内存消耗: 28.5 MB, 在Merge k Sorted Lists的Java提交中击败了80.66% 的用户]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS常用快捷键总结]]></title>
    <url>%2F2019%2F01%2F26%2Fmacos-keyboard-shortcut%2F</url>
    <content type="text"><![CDATA[2018年双十一期间，博主在京东入手了一台17版256G的MacBook Pro。由于一些外在原因，直到最近一段时间才真正使用上。经过最初的磨合，现在已经比较熟练了。这里总结下MacOS中的一些常用快捷键。 control-空格键：切换输入法 command-C：拷贝到剪切板 command-V：粘贴 command-X：剪切 command-Z：撤销上一个命令 command-D：复制（生成文件副本） command-tab：在打开的应用中切换到下一个最近使用的应用 command-delete：将所选项移到废纸篓（或者将废纸篓中的文件还回原处） shift-command-delete：清空废纸篓 shift-command-N：在”访达”中创建一个文件夹 shift-command-.:显示隐藏文件（或者恢复隐藏状态） enter：重命名 关于MacOS的更多快捷键，请参看这里。]]></content>
      <categories>
        <category>macos</category>
      </categories>
      <tags>
        <tag>macos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的异常处理]]></title>
    <url>%2F2019%2F01%2F17%2Fjava-exception-handle%2F</url>
    <content type="text"><![CDATA[Java异常处理 异常分类​ 在Java中，所有的异常都是继承自Throwable。 Java中的异常层次结构 ​ 派生于Error类或RuntimeException类的所有异常称为非受查（unchecked）异常，所有其他异常称为受查（check）异常。 声明异常​ 方法应该在其首部声明所有可能抛出的异常。语法如下： 1public FileInputStream(String name) throws FileNotFoundException 抛出异常创建异常捕获异常finally子句带资源的try语句]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的命令行工具javap]]></title>
    <url>%2F2019%2F01%2F15%2Fjava-command-javap%2F</url>
    <content type="text"><![CDATA[javap，全称java printer，是JDK中的一个基础命令行工具，用于反编译一个或多个class文件。其输出取决于使用的选项。如果未使用任何选项，则javap命令将打印具有包，protected和public权限的字段和方法，并将其输出打印到标准输出stdout。 关于javap的详细用法如下： 12345678910111213141516171819用法: javap &lt;options&gt; &lt;classes&gt;其中, 可能的选项包括: -help --help -? 输出此用法消息 -version 版本信息 -v -verbose 输出附加信息 -l 输出行号和本地变量表 -public 仅显示公共类和成员 -protected 显示受保护的/公共类和成员 -package 显示程序包/受保护的/公共类 和成员 (默认) -p -private 显示所有类和成员 -c 对代码进行反汇编 -s 输出内部类型签名 -sysinfo 显示正在处理的类的 系统信息 (路径, 大小, 日期, MD5 散列) -constants 显示最终常量 -classpath &lt;path&gt; 指定查找用户类文件的位置 -cp &lt;path&gt; 指定查找用户类文件的位置 -bootclasspath &lt;path&gt; 覆盖引导类文件的位置 其中，常用的选项有 123456-public-protected-package-p -private-c -s 以下面的程序为例，Main类包含了private、default(缺省)、protected和public四种访问权限的字段和方法。 123456789101112131415161718192021222324252627282930313233343536public class Main &#123; private int number = 1; int UID = 1234; protected String name = "Main"; public String javaVersion = "1.8"; public Main() &#123; printNumber(); &#125; private void printNumber() &#123; System.out.println("number:"+number); &#125; void printUID() &#123; System.out.println("UID:"+UID); &#125; protected void printName() &#123; System.out.println("name:"+name); &#125; public void printVersion() &#123; System.out.println("javaVersion:"+javaVersion); &#125; public static void main(String[] args) &#123; Main main = new Main(); main.printUID(); main.printName(); main.printVersion(); &#125;&#125; 编译Main.java，得到Main.class文件 1.javap的默认选项为-package，只输出具有包、protected和public的字段和方法。在命令行中使用javap或者javap -package查看Main.class，输出的内容如下： 123456789101112hgs:~ hegongshan$ javap Main.class Compiled from "Main.java"public class Main &#123; int UID; protected java.lang.String name; public java.lang.String javaVersion; public Main(); void printUID(); protected void printName(); public void printVersion(); public static void main(java.lang.String[]);&#125; 2.使用javap -public将只输出class文件中的public字段和方法。以Main.class为例，输出内容如下： 12345678hgs:~ hegongshan$ javap -public Main.classCompiled from "Main.java"public class com.hegongshan.Main &#123; public java.lang.String javaVersion; public com.hegongshan.Main(); public void printVersion(); public static void main(java.lang.String[]);&#125; 3.javap -protected将输出类中的public和protected的字段和方法。以Main.class为例，输出内容如下： 12345678910hgs:~ hegongshan$ javap -protected Main.classCompiled from "Main.java"public class com.hegongshan.Main &#123; protected java.lang.String name; public java.lang.String javaVersion; public com.hegongshan.Main(); protected void printName(); public void printVersion(); public static void main(java.lang.String[]);&#125; 4.javap -p或者javap -private将输出类中的所有字段和方法。以Main.class为例，输出内容如下： 1234567891011121314hgs:~ hegongshan$ javap -p Main.classCompiled from "Main.java"public class com.hegongshan.Main &#123; private int number; int UID; protected java.lang.String name; public java.lang.String javaVersion; public com.hegongshan.Main(); private void printNumber(); void printUID(); protected void printName(); public void printVersion(); public static void main(java.lang.String[]);&#125; 5.javap -c将对class文件进行反编译。以Main.class为例，输出内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485hgs:~ hegongshan$ javap -c Main.classCompiled from "Main.java"public class com.hegongshan.Main &#123; int UID; protected java.lang.String name; public java.lang.String javaVersion; public com.hegongshan.Main(); Code: 0: aload_0 1: invokespecial #14 // Method java/lang/Object."&lt;init&gt;":()V 4: aload_0 5: iconst_1 6: putfield #16 // Field number:I 9: aload_0 10: sipush 1234 13: putfield #18 // Field UID:I 16: aload_0 17: ldc #20 // String Main 19: putfield #22 // Field name:Ljava/lang/String; 22: aload_0 23: ldc #24 // String 1.8 25: putfield #26 // Field javaVersion:Ljava/lang/String; 28: aload_0 29: invokespecial #28 // Method printNumber:()V 32: return void printUID(); Code: 0: getstatic #35 // Field java/lang/System.out:Ljava/io/PrintStream; 3: new #41 // class java/lang/StringBuilder 6: dup 7: ldc #62 // String UID: 9: invokespecial #45 // Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V 12: aload_0 13: getfield #18 // Field UID:I 16: invokevirtual #48 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder; 19: invokevirtual #52 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 22: invokevirtual #56 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 25: return protected void printName(); Code: 0: getstatic #35 // Field java/lang/System.out:Ljava/io/PrintStream; 3: new #41 // class java/lang/StringBuilder 6: dup 7: ldc #65 // String name: 9: invokespecial #45 // Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V 12: aload_0 13: getfield #22 // Field name:Ljava/lang/String; 16: invokevirtual #67 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: invokevirtual #52 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 22: invokevirtual #56 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 25: return public void printVersion(); Code: 0: getstatic #35 // Field java/lang/System.out:Ljava/io/PrintStream; 3: new #41 // class java/lang/StringBuilder 6: dup 7: ldc #71 // String javaVersion: 9: invokespecial #45 // Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V 12: aload_0 13: getfield #26 // Field javaVersion:Ljava/lang/String; 16: invokevirtual #67 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: invokevirtual #52 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 22: invokevirtual #56 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 25: return public static void main(java.lang.String[]); Code: 0: new #1 // class com/hegongshan/Main 3: dup 4: invokespecial #75 // Method "&lt;init&gt;":()V 7: astore_1 8: aload_1 9: invokevirtual #76 // Method printUID:()V 12: aload_1 13: invokevirtual #78 // Method printName:()V 16: aload_1 17: invokevirtual #80 // Method printVersion:()V 20: return&#125; 6.javap -s将输出内部类型签名。以Main.class为例，输出内容如下： 123456789101112131415161718192021222324hgs:~ hegongshan$ javap -s Main.classCompiled from "Main.java"public class com.hegongshan.Main &#123; int UID; descriptor: I protected java.lang.String name; descriptor: Ljava/lang/String; public java.lang.String javaVersion; descriptor: Ljava/lang/String; public com.hegongshan.Main(); descriptor: ()V void printUID(); descriptor: ()V protected void printName(); descriptor: ()V public void printVersion(); descriptor: ()V public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V&#125; 上述输出内容中，对于字段，descriptor:后的字符，表示字段的类型，对应关系如下： 12345678910B : byteC : charD : doubleF : floatI : intJ : longL类名; : 引用类型,如Ljava/lang/String; 表示 String类型S : shortZ : boolean[ : 数组,如[Ljava/lang/String; 表示String[] 对于方法，descriptor:后的字符(参数类型描述)返回值类型描述，表示方法的参数及其返回值的类型。 1V : void,表示没有返回值]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类实现原理分析]]></title>
    <url>%2F2019%2F01%2F14%2Fjava-inner-class-implementation-principle%2F</url>
    <content type="text"><![CDATA[​ 本文通过分析编译后的class文件，来揭秘Java中内部类的实现原理。 在解开内部类的神秘面纱之前，让我们先来看如下代码： 12345678910111213141516171819202122232425262728293031public class OuterClass &#123; private String name; public OuterClass(String name) &#123; this.name = name; System.out.println("OuterClass初始化"); System.out.println("name："+this.name); &#125; class InnerClass &#123; public InnerClass() &#123; System.out.println("InnerClass初始化"); &#125; public void print() &#123; if(name.equals("hegongshan.com")) &#123; name = "software engineering"; System.out.println("InnerClass.print()"); System.out.println("更新后的name："+name); &#125; &#125; &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass("hegongshan.com"); OuterClass.InnerClass inner = outer.new InnerClass(); inner.print(); &#125;&#125;输出结果：OuterClass初始化name：hegongshan.comInnerClass初始化InnerClass.print()更新后的name：software engineering 上述程序编译之后生成了如下两个class文件： 12OuterClass$InnerClass.classOuterClass.class 可以看到，编译器将内部类InnerClass翻译成了名为OuterClass$InnerClass.class的class文件。 下面我们在命令行中使用javap命令来查看下编译之后的OuterClass$InnerClass.class文件（关于javap的更多描述请参看《Java中的命令行工具javap》） 12//在UNIX中，需要对$转义，其他系统中不需要加\javap -p OuterClass\$InnerClass.class 输出内容如下： 123456Compiled from "OuterClass.java"class OuterClass$InnerClass &#123; final OuterClass this$0; public OuterClass$InnerClass(OuterClass); public void print();&#125; 可以清楚地看到，编译器为了引用外部类，生成了一个使用final修饰的外部类变量，命名为this$0（名字this$0是由编译器合成的，在自己编写的代码中不能够引用它）。 另外，可以看到构造器的参数，在InnerClass中，我们并没有写构造方法，编译器为InnerClass自动生成了一个带参数的构造方法，传入一个外部类对象的引用。 开篇提到，内部类可以访问外围类中的所有方法和变量，即使这些方法和变量声明为private。既然内部类可以被编译器翻译为名字古怪的普通类（虚拟机对此一无所知），内部类如何管理那些额外的访问特权呢？ 再次使用javap命令查看生成的Outerclass.class,结果如下： 12345678Compiled from "OuterClass.java"public class OuterClass &#123; private java.lang.String name; public OuterClass(java.lang.String); public static void main(java.lang.String[]); static java.lang.String access$0(OuterClass); static void access$1(OuterClass, java.lang.String);&#125; 我们注意到，编译器在外围类中添加了两个静态方法access$0和access$1，它们均需要传入一个外围类对象的引用。此外，access$1还需要传入一个字符串变量。（方法名可能稍有不同，如access$00，这取决于你的编译器。） 内部类通过调用access$0方法，从而实现对外围类的私有属性name的访问；通过调用access$1方法，从而实现对外围类的私有属性name的修改。 如果编译器能够自动地进行转换，那么我们能不能编写程序实现这种机制呢？ 1234567891011121314151617181920212223242526272829303132333435public class Main &#123; public static void main(String[] args) &#123; Outer outer = new Outer("hegongshan.com"); Inner inner = new Inner(outer); inner.print(); &#125;&#125;class Inner &#123; final Outer outer; public Inner(Outer outer) &#123; this.outer = outer; System.out.println("Inner初始化"); &#125; public void print() &#123; System.out.println("name:"+Outer.getName(outer)); if(Outer.getName(outer).equals("hegongshan.com")) &#123; Outer.setName(outer, "software engineering"); System.out.println("更新后的name:"+Outer.getName(outer)); &#125; &#125;&#125;class Outer &#123; private String name; public Outer(String name) &#123; this.name = name; System.out.println("Outer初始化"); System.out.println("name:"+name); &#125; static String getName(Outer outer) &#123; return outer.name; &#125; static void setName(Outer outer,String name) &#123; outer.name = name; &#125;&#125; 输出结果： 12345Outer初始化name:hegongshan.comInner初始化name:hegongshan.com更新后的name:software engineering 可以看到，通过模仿编译后的class文件中的代码，在Outer中添加一些特殊的方法，在Inner类中添加特殊的构造器，我们在Inner类中访问和修改了Outer类中的私有属性。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的内部类继承]]></title>
    <url>%2F2019%2F01%2F13%2Fjava-inner-class-extends%2F</url>
    <content type="text"><![CDATA[由于Java中的匿名内部类不能被继承，而局部内部类和静态内部类的继承，与普通类继承没有区别。故本文主要描述成员内部类的继承问题。 成员内部类的继承可分为以下三种情况： 内部类及其子类在同一个外围类中 内部类及其子类在不同的外围类中 内部类的子类不是内部类 下面对这三种情况逐一分析 内部类及其子类在同一个外围类中在这种情况下，内部类和子类都是同一个外围类的内部类，此时成员内部类的继承与普通类的继承没有区别。下面通过一个示例来说明这个问题： 1234567891011121314151617181920212223class WithInner &#123; class Inner&#123; public Inner() &#123; System.out.println("Inner"); &#125; &#125; class InheritInner extends Inner &#123; public InheritInner() &#123; System.out.println("InheritInner"); &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; WithInner wi = new WithInner(); WithInner.InheritInner ii = wi.new InheritInner(); &#125;&#125;输出如下：InnerInheritInner 上述程序编译后，生成了如下的class文件 1234Main.classWithInner$InheritInner.classWithInner$Inner.classWithInner.class 在《Java内部类实现原理分析》中，我们已经知道编译器会为内部类自动添加一个声明为final的外围类字段，并为内部类自动生成一个带参数的构造方法，就像下面这样： 12345Compiled from "Main.java"class WithInner$InheritInner extends WithInner$Inner &#123; final WithInner this$0; public WithInner$InheritInner(WithInner);&#125; 由于WithInner$InheritInner类和WithInner$Inner类都在WithInner类中，编译器会为WithInner$InheritInner类自动添加声明为final的WithInner，故WithInner$InheritInner类继承WithInner$Inner类时，我们并不需要做什么额外的工作，就像普通类继承一样。 内部类及其子类在不同的外围类中先来看下面的程序 12345678910111213141516171819202122232425class WithInner &#123; class Inner&#123; public Inner() &#123; System.out.println("Inner"); &#125; &#125;&#125;class Outer &#123; class InheritInner extends WithInner.Inner &#123; public InheritInner(WithInner wi) &#123; wi.super(); System.out.println("InheritInner"); &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; WithInner wi = new WithInner(); Outer outer = new Outer(); Outer.InheritInner ii = outer.new InheritInner(wi); &#125;&#125;输出如下：InnerInheritInner InheritInner继承自内部类WithInner.Inner，由于InheritInner不在WithInner中，编译器不会为其自动添加具有WithInner参数的构造器，当要生成一个构造器时，必须传入一个指向外围类对象的引用。此外，还必须在构造器内使用如下语法，显式地调用其父类WithInner.Inner的构造器： 1enclosingClassReference.super(); 否则，将会产生如下错误： 123No enclosing instance of type WithInner is accessible to invoke the super constructor. Must define a constructor and explicitly qualify its super constructor invocationwith an instance of WithInner (e.g. x.super() where x is an instance of WithInner). 翻译过来就是 123没有外围类WithInner的实例，无法调用父类构造器。必须定义一个构造器，并且用WithInner的实例显式地调用父类构造器。（如，x.super(),其中x是WithInner的一个实例） 上述程序编译后，生成了如下的class文件 12345Main.classOuter$InheritInner.classOuter.classWithInner$Inner.classWithInner.class 使用javap -p查看Outer$InheritInner.class,输出内容如下： 12345Compiled from "Main.java"class Outer$InheritInner extends WithInner$Inner &#123; final Outer this$0; public Outer$InheritInner(Outer, WithInner);&#125; 不难想到，编译之后的Outer$InheritInner应该是下面这个样子: 123456789class Outer$InheritInner extends WithInner$Inner &#123; final Outer this$0; public Outer$InheritInner(Outer outer, WithInner wi) &#123;//先初始化父内部类，从而初始化父内部类中的final WithInner this$0，继而通过继承得到对WithInner的引用 wi.super(wi); this$0 = outer; ... &#125;&#125; 内部类的子类不是内部类下面通过一个示例来说明这个问题： 1234567891011121314class WithInner &#123; class Inner&#123;&#125;&#125;class InheritInner extends WithInner.Inner&#123; public InheritInner(WithInner wi) &#123; wi.super(); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; WithInner wi = new WithInner(); InheritInner ii = new InheritInner(wi); &#125;&#125; 和“内部类及其子类在不同的外围类中”的情况一样，当内部类的子类不是一个内部类时，我们也必须显式地添加一个带外围类对象的构造器，并在构造器内使用如下语法： 1enclosingClassReference.super(); 否则，会产生如下错误： 1No enclosing instance of type WithInner is available due to some intermediate constructor invocation 翻译过来就是 1由于一些中间构造器的调用，没有外围类WithInner的实例可用]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的内部类]]></title>
    <url>%2F2019%2F01%2F12%2Fjava-inner-class%2F</url>
    <content type="text"><![CDATA[将一个类的定义放在另一个类的定义内部，这就是内部类。如下所示 123456class OuterClass &#123; ... class InnerClass &#123; ... &#125;&#125; 从总体上来讲，Java中的内部类可以分为： 静态内部类（static inner class）：声明为static的内部类 非静态内部类（non-static inner class） 123456789class OuterClass &#123; ... static class StaticInnerClass &#123; ... &#125; class InnerClass &#123; ... &#125;&#125; 其中，非静态内部类又可细分为以下三种： 成员内部类：作为外部类的成员定义 局部内部类（local inner class）：在外部类的方法中定义 匿名内部类（anonymous inner class）：没有名字的内部类 内部类是一种编译器现象，与虚拟机无关。它可以访问外部类中定义的所有方法和域，即使这些方法和域声明为private。此外，内部类可以使用访问说明符public、protected和private修饰。 非静态内部类非静态内部类中不能声明static方法，声明的所有静态域都必须是final。 内部类的特殊语法要想实例化一个非静态内部类，需要使用一种特殊的语法.new，就像下面这样： 1234567public class OuterClass &#123; class InnerClass &#123;&#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); InnerClass inner = outer.new InnerClass(); &#125;&#125; 在外部类的作用域之外，可以这样引用内部类： 1OuterClass.InnerClass 下面是示例展示了如何在外部类的作用域之外，实例化它的内部类。 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); OuterClass.InnerClass inner = outer.new InnerClass(); &#125;&#125;class OuterClass &#123; class InnerClass &#123; public InnerClass() &#123; System.out.println("InnerClass实例化"); &#125; &#125;&#125;输出结果：InnerClass实例化 在内部类中，如果需要使用外部类对象的引用，可以使用外部类的名字后紧跟圆点和this，就像这样OuterClass.this​,下面是一个简单的示例： 1234567891011121314151617public class OuterClass &#123; public void print() &#123; System.out.println("OuterClass.print()"); &#125; class InnerClass &#123; public OuterClass getOuter() &#123; return OuterClass.this; &#125; &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); InnerClass inner = outer.new InnerClass(); inner.getOuter().print(); &#125;&#125;输出结果：OuterClass.print() 成员内部类成员内部类是最常见的内部类，也称为普通内部类。成员内部类作为外部类的成员来定义，如下所示： 12345public class OuterClass &#123; class InnerClass &#123; &#125;&#125; 局部内部类在外围类的方法中声明的类，称为局部内部类。下面是一个简单的例子 123456789101112131415161718192021222324252627public class Outer &#123; private int count = 0; public void start() &#123; class LocalInnerClass &#123; public void service() &#123; System.out.println(count); count++; &#125; &#125; LocalInnerClass inner = new LocalInnerClass(); for (int i = 0; i &lt; 5; i++) &#123; inner.service(); &#125; &#125; public static void main(String[] args) &#123; Outer main = new Outer(); main.start(); &#125;&#125;输出结果：01234 局部内部类不能用public、protected或private访问说明符声明。它的优势是对外部世界可以完全地隐藏起来，除了start方法之外，Outer的其他地方均不能访问它。 匿名内部类匿名内部类，顾名思义，就是没有命名的内部类。语法格式如下 123new SuperType(construction parameters) &#123; 方法和属性&#125; 下面是匿名内部类的一个示例。 12345678910111213141516171819202122232425262728293031interface Counter &#123; int next();&#125;public class Outer &#123; private int count = 0; Counter getCounter(final String name) &#123; return new Counter() &#123; &#123; System.out.println("Counter()"); &#125; public int next() &#123; System.out.print(name); return count++; &#125; &#125;; &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Counter c = outer.getCounter(); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(c.next()); &#125; &#125;&#125;输出结果：Counter()01234 在上面的程序中，由于getCounter方法中的name这个变量不是外围类中定义的属性，所以必须声明为final类型，才能在匿名内部类中使用（对于局部内部类，情况也是一样的），否则，将产生如下的语法错误： 1Cannot refer to the non-final local variable name defined in an enclosing scope 由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。因此，将参数传递给超类（父类）构造器。在匿名内部类实现接口的时候，不能有任何构造参数。 静态内部类静态内部类，就是声明为static的内部类。实例化静态内部类，不需要其外围类对象。下面是一个静态内部类的示例： 12345678910111213141516171819202122public class Outer &#123; private int count = 0; private static String className = "OUTER"; public static class StaticInnerClass &#123; public StaticInnerClass(String name) &#123; System.out.println(name); System.out.println("outer class name:"+className); &#125; &#125; public static void main(String[] args) &#123; Outer main = new Outer(); //下面两种实例化方法是等价的 StaticInnerClass inner = new StaticInnerClass("inner"); Outer.StaticInnerClass inner2 = new Outer.StaticInnerClass("inner2"); &#125;&#125;输出结果：innerouter class name:OUTERinner2outer class name:OUTER 值得一提的是，静态内部类不能访问外围类中的非静态的域和方法。以上面的程序为例，StaticInnerClass类可以访问到Outer类的className属性，因为className声明为static，但StaticInnerClass类不能访问count。 什么时候使用静态内部类？在内部类不需要访问外围类对象的时候，应该使用静态内部类。 内部类标识符对于成员内部类和静态内部类，编译器将会把它编译成文件名为外围类名$内部类名.class的class文件。 对于匿名内部类，编译器会将它编译名为外围类名$n.class的class文件；对于局部内部类，则被编译为外围类名$n内部类名的class文件。（n是由编译器简单生成的一个数字） 下面通过一个简单的例子来展示这四种内部类的字节码文件的命名规则 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152interface Counter &#123; int next();&#125;public class Outer &#123; private int count = 0; class NormalCounter implements Counter &#123; public int next() &#123; return count++; &#125; &#125; Counter getCounter(final String name) &#123; class LocalCounter implements Counter &#123; static final String name = ""; public LocalCounter() &#123; System.out.println("LocalCounter()"); &#125; public int next() &#123; System.out.print(name); return count++; &#125; &#125; return new LocalCounter(); &#125; Counter getCounter2(final String name) &#123; return new Counter() &#123; &#123; System.out.println("Counter()"); &#125; public int next() &#123; System.out.print(name); return count++; &#125; &#125;; &#125; static class StaticInnerClass&#123; &#125; public static void main(String[] args) &#123; Outer lic = new Outer(); Counter c1 = lic.getCounter("Local inner class "); Counter c2 = lic.getCounter2("Anonymous inner class "); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(c1.next()); &#125; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(c2.next()); &#125; &#125;&#125; Outer.java编译之后，生成了如下几个class文件： 123456Counter.classOuter$1.classOuter$1LocalCounter.classOuter$NormalCounter.classOuter$StaticInnerClass.classOuter.class]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的final关键字]]></title>
    <url>%2F2019%2F01%2F10%2Fjava-final%2F</url>
    <content type="text"><![CDATA[​ 在Java中，final关键字可以用于域、方法和类的声明，所处位置不同，其作用也不同。 final域使用final声明的域，在使用前必须被初始化，且一旦被初始化便无法改变。下面是一个简单的例子： 1234567public class Main &#123; final int number = 1; public static void main(String[] args) &#123; Main main = new Main(); //main.number = 2; &#125;&#125; 当我们想改变number的值时，产生了如下错误： 1The final field Main.number cannot be assigned 空白final空白final是指被声明为final但又未给定初始值的域。必须在构造器中对空白final进行赋值，以确保空白final在使用前被初始化。下面是空白final的一个例子： 1234567891011public class Main &#123; final int x = 20; final int number;//空白final public Main(int number) &#123; this.number = number; &#125; public static void main(String[] args) &#123; Main main = new Main(2); &#125;&#125; 因此，综合空白final和定义时已被初始化的final字段，我们可以说：final字段必须在域的定义处或者构造器中被初始化。 static final域和final域的区别当域声明为static final时，表示该字段在类装载时已被初始化，而不是每次创建新对象时都初始化。此外，声明为static final的字段，在该类的所有对象中值是唯一的且不能改变。而final域是在创建对象时才被初始化，每个对象中该字段的值不一定相同，但在同一对象中，该字段的值是唯一的。下面的例子直白地说明了二者的区别： 1234567891011121314151617181920public class Main &#123; public static final int CAPACITY = 10; private final int id; public Main(int id) &#123; this.id = id; &#125; public String toString() &#123; return "id=" + id + ",CAPACITY=" + CAPACITY; &#125; public static void main(String[] args) &#123; Main main = new Main(2); System.out.println(main); Main main2 = new Main(3); System.out.println(main2); System.out.println(main); &#125;&#125; 输出结果： 123id=2,CAPACITY=10id=3,CAPACITY=10id=2,CAPACITY=10 final参数Java允许在参数列表中以声明的方式将参数指明为final。这一特性主要用来向匿名类传递数据。 123456789101112public class Main &#123; public void say(final String name) &#123; System.out.println("hello "+name); //name = "new"+name; &#125; public static void main(String[] args) &#123; Main main = new Main(); main.say("hgs"); &#125;&#125; 当我们想改变name的值时，将产生如下错误： 1The final local variable name cannot be assigned. It must be blank and not using a compound assignment final方法使用final声明的方法，表示在子类中不允许被覆盖。下面我们尝试下覆盖父类中的final方法 12345678910class Parent &#123; public final void say(String word) &#123; System.out.println(word); &#125;&#125;class Child extends Parent &#123; /*public void say(String word) &#123; &#125;*/&#125; 产生了如下错误： 1Cannot override the final method from Parent final和private 关键字类中所有的private方法都隐式地指定为是final的。可以将private方法声明为final，但这并不会给方法增加任何额外的意义。 final类当某个类用final声明时，表明这个类不允许被继承。由于final类禁止继承，所以final类中所有的方法都隐式指定为是final的，但类中的域并不会自动地成为final。 123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args) &#123; FinalClass fc = new FinalClass("final class"); System.out.println("number="+fc.number); System.out.println("name="+fc.getName()); fc.setName("name"); System.out.println("name="+fc.getName()); //fc.number += 1; //The final field FinalClass.number cannot be assigned &#125;&#125;final class FinalClass &#123; private String name; public final int number = 1; public FinalClass(String name) &#123; this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;//class ChildFinalClass extends FinalClass&#123;&#125;//The type ChildFinalClass cannot subclass the final class FinalClass 输出结果如下： 123number=1name=final classname=name 在final类中可以给方法添加final修饰符，但这并不会增添任何意义。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年度总结]]></title>
    <url>%2F2019%2F01%2F04%2F2018-year-end-summary%2F</url>
    <content type="text"><![CDATA[目标明确，才能不迷失方向！是时候总结下过去一年的收获了，顺便给新的一年制定下计划。 2018年度总结 3月27日，武汉大学计算机学院硕士研究生拟录取结果公布 4月12日，进入朱卫平老师的智慧爬虫小组 7月3日，“乐渔”课程教学系统 软件著作权申请（10月15日审批通过） 9月5日，进入丁立新老师的课题组（原国软的老师不能带原计算机的学生） 11月22日，结束考研辅导（6月1日开始） 12月5日，“锐捷杯”华中区研究生程序设计大赛一轮游(accept 3/10)，rank 34/105 12月16日，第十五次CSP 130分 2019年度计划 1-2月，项目开发（软著） 3月17日，第十六次CSP，目标300 5月，CET6，标500+ 5月25日，软考系统分析师 9月22日，第十七次CSP，目标400 10月，CCSP竞赛，目标铜牌 11月9日，软考系统架构设计师 12月，“锐捷杯”华中区研究生程序设计大赛，目标三等奖]]></content>
      <categories>
        <category>任重而道远</category>
      </categories>
      <tags>
        <tag>任重而道远</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx返回413 Request Entity Too Large]]></title>
    <url>%2F2018%2F10%2F14%2Fnginx-413-request-entity-too-large%2F</url>
    <content type="text"><![CDATA[问题描述 晚上9点55分，前老板在讨论组中截了一张图片，显示的是课程网站上传文件失败的弹框，弹框内容如下 1SyntaxError: JSON.parse: unexpected character at line2 column 1 of the JSON data 下意识以为是自己代码写的有问题，赶紧在本机测试了下，发现很小的文件都能正常上传，但是稍大一点的文件就会出现如下错误 1SyntaxError: Unexpected token &lt; in JSON at position 1 浏览器控制台报错内容如下 1413 Request Entity Too Large 查看了下Spring MVC的配置文件，上传大小写的足够大，这显然不是Spring MVC的问题。后来发现可能是Nginx的问题，试着改了下本地Nginx的配置文件，果然就传成功了。 原因 nginx服务器做反向代理时，对上传的文件大小有限制，默认为2M 解决办法 在nginx.conf的http{}中，添加一行 1client_max_body_size 200m; 文件大小限制可以根据需求自行改变。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL中的空值处理(null)]]></title>
    <url>%2F2018%2F09%2F19%2Fsql-null-value%2F</url>
    <content type="text"><![CDATA[SQL中的空值处理主要分为以下两种情况： 1.涉及空值的条件判断；2.涉及空值的更新操作。 涉及空值的条件判断where子句中不能使用 = null 来进行空值判断，必须使用 is null 和 is not null 。 示例： 某些学生选修某门课程后没有参加考试，所以有选课记录，但没有考试成绩。 试查询缺少成绩的学生的学号和相应的课程号。 123select sno,cnofrom scwhere grade is null; 注意，” grade is null “不能写为“ grade = null”。 查所有有成绩记录的学生的学号和相应的课程号。 123select sno,cnofrom scwhere grade is not null; 涉及空值的更新操作在update语句的set中，使用 = null 设置某列为空。 将选修“高级算法分析与设计”课不及格的学生成绩设置为空值。 1234567update scset grade = nullwhere grade &lt; 60 and cno in ( select cno from course where cname = "高级算法分析与设计");]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL中删除表中数据的几种方法]]></title>
    <url>%2F2018%2F09%2F19%2Fsql-drop-delete-and-truncate-table%2F</url>
    <content type="text"><![CDATA[SQL中删除表数据有以下三种方法： 1.使用drop table语句；2. 使用delete语句；3. 使用truncate table语句。 drop table1drop table 表名; 功能：删除表，表的结构、表中的数据以及索引等全部被删除。 delete1delete from 表名 [where 条件]; 功能：根据条件删除表中的数据，但不删除表的定义。 truncate table1truncate table 表名; 功能：清空表中的全部数据，但不删除表的定义。 truncate table 与delete语句不同的地方在于， 1.truncate table语句没有where条件。 2.truncate table语句会使表回到刚创建的初始状态，如重置表中的自增值等，而delete 语句不会。 3.truncate table语句不会触发触发器，而delete语句会触发触发器。 若要清空表中的数据，但不删除表，推荐使用 truncate table语句。]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL中的字符匹配（like）]]></title>
    <url>%2F2018%2F09%2F19%2Fsql-like%2F</url>
    <content type="text"><![CDATA[like可以用于字符串的匹配，其一般语法如下： 1[not] like '&lt;匹配串&gt;' [escape '&lt;换码字符&gt;'] 其含义是查找指定的属性列值与&lt;匹配串&gt;相匹配的元组。&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符 % 和 _ 。 %：匹配任意长度(长度可以为0)的字符串 _：匹配任意单个字符(一个汉字占两个字符) 示例： 1.查询所有姓刘的学生的姓名、学号和性别。 123select sname,sno,sexfrom studentwhere sname like '刘%'; 2.查询所有姓“贺”且全名为两个汉字的学生的姓名 123select snamefrom studentwhere sname like '贺__'; 由于一个汉字占两个字符，所以贺字后需要跟两个_ 3.查询名字中第二个字为“扬”字的学生姓名和学号 123select sname,snofrom studentwhere sname like '__扬%'; ４.查询名字中包含”山”的学生姓名 123select snamefrom studentwhere sname like '%山%'; ５.查询所有不姓刘的学生姓名 123select snamefrom studentwhere sname not like '刘%' 如果需要查询的匹配字符串本身就含有%和_，可以使用escape ‘&lt;换码字符&gt;’对通配符进行转义。 示例： 6.查询Algorithms_Design课程的课程号和学分 123select cno,creditfrom coursewhere cname like 'Algorithms\_Design' escape '\'; 7.查询课程名以“算法_”开头，且倒数第二个汉字为“设”的课程详情。 123select *from coursewhere cname like '算法\_%设__' escape '\'; 注意：换码字符是可以变化的，一般取不常用的符号。若匹配串中本身含有 “ \ “，则换码字符可取 “ ? ”等。]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL中的各种join]]></title>
    <url>%2F2018%2F09%2F14%2Fsql-join%2F</url>
    <content type="text"><![CDATA[SQL中的连接操作很多，这里总结一下。 假设有以下两张表 教师表teacher teacher_id teacher_name 1 刘娟 2 朱卫平 3 刘婧 4 李春葆 课程表 course_id course_name teacher_id 1 商务智能 2 2 高级算法分析与设计 1 3 程序设计方法学 3 4 模式识别 2 sql如下： 1234567891011121314151617181920create table teacher ( teacher_id int, teacher_name varchar(32), primary key(teacher_id));insert into teacher(teacher_id,teacher_name) values (1,'刘娟');insert into teacher(teacher_id,teacher_name) values (2,'朱卫平');insert into teacher(teacher_id,teacher_name) values (3,'刘婧');insert into teacher(teacher_id,teacher_name) values (4,'李春葆');create table course( course_id int, course_name varchar(32), teacher_id int, primary key(course_id), foreign key(teacher_id) references teacher(teacher_id));insert into course(course_id,course_name,teacher_id) values (1,'商务智能',2);insert into course(course_id,course_name,teacher_id) values (2,'高级算法分析与设计',1);insert into course(course_id,course_name,teacher_id) values (3,'程序设计方法学',3);insert into course(course_id,course_name,teacher_id) values (4,'模式识别',2); cross join笛卡尔积(cross join)。 inner join等值连接（inner join或join）:返回两张表中相互匹配的行。 语法： 1234select 列名,...from table1[inner] join table2on table1.column_name = table2.column_name; 其中的inner是可省略的。 示例： 123select course.*,teacher.teacher_name from courseinner join teacheron course.teacher_id = teacher.teacher_id; 输出： natural join自然连接(natural join)：在inner join的基础上，去除重复的列名。 left join左外连接(left outer join)：返回左表中的所有行及右表中满足on条件的行，如果右表没有匹配的行，对应列填充NULL。 其中outer是可省略的，即可写为left join。 示例： 查询所有的教师信息，即使他尚未被安排课程 123select course.*,teacher.teacher_name from teacherleft outer join courseon course.teacher_id = teacher.teacher_id; 输出： right join右外连接(right outer join)：返回右表有行和左表中满足on条件的行，如果左表没有匹配的行，对应列填充NULL。 其中outer是可省略的，即可写为right join。 示例： 查询所有的教师信息，即使他尚未被安排课程 123select * from courseright outer join teacheron course.teacher_id = teacher.teacher_id; 输出： full join全外连接(full outer join或full join)：返回左表和右表中的所有行。若某一张表中的行在另一张表中没有匹配的行，对应列填充NULL。 123select * from coursefull outer join teacheron course.teacher_id = teacher.teacher_id; 注意：MySQL不支持full outer join，可以使用左连接和右连接的并来实现。 1234567select * from courseleft join teacheron course.teacher_id = teacher.teacher_idunion select * from courseright join teacheron course.teacher_id = teacher.teacher_id;]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL中的并运算(union)]]></title>
    <url>%2F2018%2F09%2F12%2Fsql-union%2F</url>
    <content type="text"><![CDATA[union用于合并两个或多个select语句的结果集。 需要注意的是，union合并的两个或多个表必须有相同的列数，且相应的列必须取自同一个域（即数据类型相似，如都是数值型），此外，每条select语句中列的顺序必须相同。 语法123select 列名 from table1union select 列名 from table2 注意：union会去除重复行，如果需要保留重复的行，可使用union all。 示例假设有以下两张雇员表 123456789101112131415161718create table employee_cn( eno int, name varchar(32), primary key(eno));insert into employee_cn values(1,'San Zhang');insert into employee_cn values(2,'Xindong Wu');insert into employee_cn values(3,'Gongshan he');insert into employee_cn values(4,'Jiawei Han');create table employee_us( eno int, name varchar(32), primary key(eno));insert into employee_us values(1,'Jiawei Han');insert into employee_us values(2,'Xindong Wu');insert into employee_us values(3,'Bill Gates');insert into employee_us values(4,'Steve Jobs'); 查询中国和美国的所有雇员的姓名 123select name from employee_cnunionselect name from employee_us; 结果： 12345678910+-------------+| name |+-------------+| San Zhang || Xindong Wu || Gongshan he || Jiawei Han || Bill Gates || Steve Jobs |+-------------+ 可以看到，union无法查询出所有的中国和美国雇员，一旦出现同名的雇员，则只有一个被列出。 下面使用union all。 123select name from employee_cnunion allselect name from employee_us; 结果: 123456789101112+-------------+| name |+-------------+| San Zhang || Xindong Wu || Gongshan he || Jiawei Han || Jiawei Han || Xindong Wu || Bill Gates || Steve Jobs |+-------------+]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL]]></title>
    <url>%2F2018%2F09%2F08%2Fsql-summary%2F</url>
    <content type="text"><![CDATA[结构化查询语言（structured query language, 简称SQL）分为四类： 数据定义语句（Data Definition Language，简称DDL）、数据查询语句（Data Query Language，简称DQL）、数据更新语句（Data Manipulation Language，简称DML）以及数据控制语句。 DDL 表的创建 1234create table 表名 ( 列名 数据类型 列级完整性约束, ...[,表级完整性约束]) 表的删除 1drop table 表名 [cascade | restrict] 表的扩充和修改 1.增加新列 1alter table 表名 add (列名 数据类型,...) 2.删除已存在的某个列 1alter table 表名 drop 列名 [cascade | restrict] 3.修改原有列的类型 1alter table 表名 modify 列名 数据类型 DQL12345select [all | distinct]from 表名或视图名[,表名或视图名...][where 条件表达式][group by 列名1 [having 条件表达式]][order by 列名2 [asc | desc]] DML 插入数据 1.插入一条数据 1insert into 表名 [(列名,列名,...)] values(常量1[,常量2,...]) 2.插入子查询结果 1insert into 表名 [(列名,列名,...)] 查询语句 修改数据 123update 表名 set 列名 = 表达式[,列名 = 表达式,...][where 条件] 删除数据 1delete from 表名 [where 条件]]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇异值分解]]></title>
    <url>%2F2018%2F08%2F28%2Fmatrix-singular-value-decomposition%2F</url>
    <content type="text"><![CDATA[奇异值分解（Singular Value Decomposition，简称SVD），是一种矩阵分解技术，可以用于机器学习中数据集的降维。 预备知识 单位矩阵 主对角元素全为1，其余元素全为0的n阶矩阵，称为单位矩阵，记为$E_{n}$或$I_{n}$，通常用$E$或$I$表示。 自看机器学习以来，看到好多次$I$这个符号，以前一直不知道是啥意思，原来就是本科线性代数里单位矩阵$E$的另一种表示符号。 正交矩阵 如果n阶实矩阵满足$$A^{T}A = AA^{T} = I$$则称$A$为正定矩阵。 正规矩阵 设$A \in C^{\ m \times n}$，如果$$A^{H}A = AA^{H}$$则称$A$ 为正规矩阵。 酉矩阵 如果n阶复矩阵$A$满足$$A^{H}A = AA^{H} = I$$则称$A$为酉矩阵。 奇异值分解设$A \in C^{\ m \times n}$，如果存在非负实数$\sigma$和非零向量$u \in C^{n}，v \in C^{m}$使得$$Au = \sigma v，A^{H}v = \sigma u$$则称$\sigma$为$A$的奇异值，$u$和$v$分别称为$A$对应于奇异值$\sigma$的右奇异向量和左奇异向量。$$A^{H}Au = \sigma A^{H} v = \sigma^{2} u$$ $$A A^{H} v = \sigma A u = \sigma^{2}v$$ 因此，$\sigma^{2}$是$A^{H} A$的特征值，也是$A A^{H}$的特征值，而$u$和$v$分别是$A^{H}A$和$A A^{H}$对应于特征值$\sigma^{2}$的特征向量。 设$A \in C^{\ m \times n}$，rank（A）=r，且$A^{H}A$的特征值为$\lambda_{1} \geq \lambda_{2} \geq \dots \geq \lambda_{n}$。$$\lambda_{1} \geq \dots \geq \lambda_{r} &gt; \lambda_{r+1} = \dots = \lambda_{n} = 0$$记$k = \min\{m,n\}$，也称$\sigma_{i} = \sqrt{\lambda_{i}} （i=1,\dots,k）$为$A$的奇异值，特别地，称$\sigma_{1}，\dots，\sigma_{r}$为$A$的正奇异值。 定理：若$A$是正规矩阵，则$A$的奇异值是$A$的特征值的模。 定理：设$A$是$m \times n$矩阵，且rank（A）= r，则存在m阶酉矩阵$V$和n阶酉矩阵$U$，使得$$V^{H}AU =\begin{bmatrix}\Sigma &amp; 0 \\0 &amp; 0\end{bmatrix}$$其中，$\Sigma = diag（\sigma_{1}，\dots，\sigma_{r}）$，且$\sigma_{1} \geq \dots \geq \sigma_{r} &gt; 0$。 $U$的列向量是$A^{H}A$的标准正交特征向量，$U$的前 r 列向量是$A^{H}A$对应于r个非零特征值$\sigma_{1}^{2},\dots,\sigma_{r}^{2}$的标准正交特征向量；而$V$的列向量是$AA^{H}$的标准正交特征向量，前 r 列向量恰是$AA^{H}$对应于特征值$\sigma_{1}^{2},\dots,\sigma_{r}^{2}$的标准正交特征向量。 例题 设$$A =\begin{bmatrix}0 &amp; 1 \\-1 &amp; 0 \\0 &amp; 2 \\1 &amp; 0 \\\end{bmatrix}$$作出矩阵$A$的奇异值分解。 解：$$A^{H}A =\begin{bmatrix}2 &amp; 0 \\0 &amp; 5\end{bmatrix},AA^{H} =\begin{bmatrix}1 &amp; 0 &amp; 2 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; -1 \\2 &amp; 0 &amp; 4 &amp; 0 \\0 &amp; -1 &amp; 0 &amp; 1\end{bmatrix},$$则$A$的非零奇异值为$\sqrt{2}，\sqrt{5}$ . $A^{H} A $对应于特征值5和2的标准正交特征向量为$$u_1 =\begin{pmatrix}0 \\ 1\end{pmatrix}，u_2 =\begin{pmatrix}1 \\ 0\end{pmatrix}$$$AA^{H}$对应于特征值5和2的标准正交特征向量为$$v_1 =\begin{bmatrix}\frac{1}{\sqrt{5}} \\ 0 \\ \frac{2}{\sqrt{5}} \\ 0\end{bmatrix},v_2 =\begin{bmatrix}0 \\ -\frac{1}{\sqrt{2}} \\ 0 \\ \frac{1}{\sqrt{2}}\end{bmatrix}$$$AA^{H}$对应于特征值0的标准正交特征向量为$$v_3 =\begin{bmatrix}-\frac{2}{\sqrt{5}} \\ 0 \\ \frac{1}{\sqrt{5}} \\ 0\end{bmatrix},v_4 =\begin{bmatrix}0 \\ \frac{1}{\sqrt{2}} \\ 0 \\ \frac{1}{\sqrt{2}}\end{bmatrix}$$因此，$A$的奇异值分解为$$A =\begin{bmatrix}0 &amp; 1 \\-1 &amp; 0 \\0 &amp; 2 \\1 &amp; 0 \\\end{bmatrix}=\begin{bmatrix}\frac{1}{\sqrt{5}} &amp; 0 &amp; -\frac{2}{\sqrt{5}} &amp; 0\\0 &amp; -\frac{1}{\sqrt{2}} &amp; 0 &amp; \frac{1}{\sqrt{2}}\\\frac{2}{\sqrt{5}} &amp; 0 &amp; \frac{1}{\sqrt{5}} &amp; 0\\0 &amp; \frac{1}{\sqrt{2}} &amp; 0 &amp; \frac{1}{\sqrt{2}}\end{bmatrix}\begin{bmatrix}\sqrt{5} &amp; 0 \\0 &amp; \sqrt{2} \\0 &amp; 0 \\0 &amp; 0\end{bmatrix}\begin{pmatrix}0 &amp; 1 \\1 &amp; 0\end{pmatrix}^{H}$$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>矩阵论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向量和矩阵的范数]]></title>
    <url>%2F2018%2F08%2F27%2Fvector-and-matrix-norm%2F</url>
    <content type="text"><![CDATA[阅读《机器学习》和《机器学习实战》的时候，都碰到过范数（norm）这个概念，这里记录一下。 向量范数 定义 设V是数域P上的线性空间，$\lVert \alpha \rVert$是以V中的向量$\alpha$为自变量的非负实值函数，如果它满足以下三个条件： （1）非负性：当$\alpha \neq 0$时，$\lVert \alpha \rVert &gt; 0$；当$\alpha = 0$时，$\lVert \alpha \rVert = 0$； （2）齐次性：对任意$k \in P，\alpha \in V$，有$\lVert k \alpha \rVert = \lvert k \rvert\ \lVert\alpha \rVert $； （3）三角不等式：对任意$\alpha，\beta \in V$，有$\lVert \alpha + \beta \rVert \leq \lVert \alpha \rVert + \lVert \beta \rVert$， 则称$\lVert \alpha \rVert$ 为向量$\alpha$的范数，并称定义了范数的线性空间为赋范线性空间。 什么是数域？ 设P是包含0和1在内的数集，如果P中任意两个数的和、差、积、商（除数不为0）仍是P中的数，则称P为一个数域。 常见的向量范数 在n维向量空间$C^n$中，对任意的向量$x = (x_1,x_2,\dots,x_n)^{T} \in C^{n} $,有$$\lVert x \rVert_{1} = \sum_{i=1}^{n} \lvert x_{i} \rvert \tag{1}$$ $$\lVert x \rVert_{2} = (\sum_{i=1}^{n} \lvert x_{i} \rvert^{2})^{\frac{1}{2}} \tag{2}$$ $$\lVert x \rVert_{\infty} = \max_{1 \leq i \leq n} \lvert x_{i} \rvert \tag{3}$$ 其中，$\lVert x \rVert_{1}、\lVert x \rVert_{2}、\lVert x \rVert_{\infty}$分别称为1范数，2范数（Euclid范数或欧式范数）和$\infty$范数。 对$1\leq p &lt; +\infty$，在$C^{n}$上定义$$\lVert x \rVert_{p} = (\sum_{i=1}^{n} \lvert x_{i} \rvert^{p})^{\frac{1}{p}}，1 \leq p &lt; +\infty \tag{4}$$$\lVert x \rVert_{p}$称为p范数。若未标明p，则默认为2范数。 矩阵范数 定义 设$\lVert \mathbf{A} \rVert$是以$C^{m \times n}$中的矩阵$\mathbf{A}$为自变量的非负实值函数，如果它满足以下三个条件： （1）非负性：当$\mathbf{A} \neq 0$时，$\lVert \mathbf{A} \rVert&gt; 0$；当$\mathbf{A}= 0$时，$\lVert \mathbf{A} \rVert = 0$； （2）齐次性：对任意$k \in C，\mathbf{A} \in C^{m \times n}$，有$\lVert k \mathbf{A} \rVert = \lvert k \rvert\ \lVert A \rVert $； （3）三角不等式：对任意$\mathbf{A}，\mathbf{B} \in C^{m \times n}$，有$\lVert \mathbf{A} + \mathbf{B} \rVert \leq \lVert \mathbf{A} \rVert + \lVert \mathbf{B} \rVert$， 则称$\lVert \mathbf{A} \rVert$ 为$m \times n$矩阵$\mathbf{A}$的范数。 常见的矩阵范数 对于$\mathbf{A} = (a_{ij}) \in \mathbf{C}^{m \times n}$，令$$\lVert \mathbf{A} \rVert_{1} \equiv \sum_{i=1}^{m}\sum_{j=1}^{n}\ \lvert a_{ij} \rvert \tag{5}$$ $$\lVert \mathbf{A} \rVert_{\infty} \equiv \max_{i,\ j}\ \lvert a_{ij} \rvert \tag{6}$$ $$\lVert \mathbf{A} \rVert_{F} \equiv (\sum_{i=1}^{m}\sum_{j=1}^{n}\ \lvert a_{ij} \rvert^{2})^{\frac{1}{2}}= (tr({\mathbf{A}^{H}\mathbf{A}}))^{\frac{1}{2}} \tag{7}$$ 其中，$\lVert \mathbf{A} \rVert_{F}$称为$\mathbf{A}$的Frobenius范数，$A^{H}$是$A$的共轭转置矩阵。 补充知识1.复矩阵：元素中含有复数的矩阵。 2.共轭矩阵： 当$A=(a_{ij})$为复矩阵时，用 $ \overline{a} $ 表示 $a $的共轭复数，记 $\overline{A} = (\overline{a_{ji}})$，则$\overline{A}$为A的共轭矩阵。 例如，$$A =\begin{vmatrix}3+i &amp; 5\\2-2i &amp; i\end{vmatrix}$$其共轭矩阵$\overline{A}$为$$\overline{A} =\begin{vmatrix}3-i &amp; 5 \\2+2i &amp; -i\end{vmatrix}$$3.共轭转置矩阵 当$A=(a_{ij})$为复矩阵时，用 $ \overline{a} $ 表示 $a $的共轭复数，记 $\overline{A} = (\overline{a_{ji}})$，则$（\overline{A}）^{T} = \overline{A^{T}}$为A的共轭转置矩阵。 还是用上面的例子，$$(\overline{A})^{T} =\begin{vmatrix}3-i &amp; 5 \\2+2i &amp; -i\end{vmatrix}^{T} =\begin{vmatrix}3-i &amp; 2+2i \\5 &amp; -i\end{vmatrix}$$ 4.Hermite矩阵 n阶复方阵A的对称元素互为共轭，即A的共轭转置矩阵等于它本身，则A是Hermite矩阵。 例如，$$B =\begin{vmatrix}3 &amp; 2+i \\2-i &amp; 2\end{vmatrix}$$B的共轭转置矩阵如下$$\overline{B}^{T} =\begin{vmatrix}3 &amp; 2-i \\2+i &amp; 2\end{vmatrix}^{T}=\begin{vmatrix}3 &amp; 2+i \\2-i &amp; 2\end{vmatrix} = B$$故，B是一个Hermite矩阵。 参考资料 戴华，矩阵论，科学出版社]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之PCA算法]]></title>
    <url>%2F2018%2F08%2F26%2Fmachine-learning-pca%2F</url>
    <content type="text"><![CDATA[主成分分析（Principal Component Analysis，简称PCA）。 $$\begin{align}\hline&amp; PCA算法 \\\hline&amp; 输入：样本集D=\{x_1,x_2,\dots,x_m\};低维空间维数d^{‘} \\&amp; 过程： \\&amp; 1. 对所有样本进行中心化：x_i \leftarrow x_i - \frac{1}{m} \sum_{i=1}^{m} x_i;\\&amp; 2.计算样本的协方差矩阵XX^{T}; \\&amp; 3.对协方差矩阵XX^{T}做特征值分解; \\&amp; 4.取最大的d^{‘}个特征值所对应的特征向量w_1,w_2,\dots,w_{d^{‘}}. \\&amp; 输出：投影矩阵W=(w_1,w_2,\dots,w_{d^{‘}})\end{align}$$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>降维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之PageRank算法]]></title>
    <url>%2F2018%2F08%2F25%2Fmachine-learning-pagerank%2F</url>
    <content type="text"><![CDATA[PageRank是一个搜索排名算法，由Sergey Brin和Larry Page在1998年第七届国际万维网大会上提出的。基于这一算法，他们创建了Google搜索引擎。 在介绍PageRank之前，先来了解一些主要概念。 页面i的入链（In-links of page i）：从其他网页链接到网页$i$的超链接数，通常不包括来自同一站点内网页的链接。 网页i的出链（Out-links of page i）：从网页$i$链接到其他网页的超链接数，通常不包括链接到同一站点内网页的超链接。 算法根据社交网络的排序声望原理，页面$i$的重要程度（页面$i$的PageRank分数），由所有指向页面i的所有页面的PageRank分数之和决定。因为一个页面可能指向很多其他的页面，它的声望分数应该被所有它指向的页面所共享。 将网络看做一个有向图G = (V , E)，其中V是所有顶点或结点的集合，例如，所有网页的集合，E是图中有向边的集合，例如，超链接。 设网络中的网页总数为n，网页i的PageRank分数为P(i)，$$P(i) = \sum_{(j,i) \in E} \frac{P(j)}{O_{j}} \tag{1}$$其中，$O_{j}$是网页$j$的出链数。 设P是一个由PageRank值组成的n维列向量（n-dimensional column vector）。$$P = (P(1),P(2),\dots,P(n))^{T} \tag{2}$$设A是图的邻接矩阵（adjacency matrix），$$A_{ij} =\begin{cases}\frac{1}{O_{j}},&amp; (i,j) \in E \\0, &amp; 其他\end{cases} \tag{3}$$由公式(1)~(3)，可以得到如下n阶方程组$$P = A^{T}P \tag{4}$$显然，P是一个特征值为1的特征向量（eigenvector）。 如果满足以下条件： 1.A是一个随机矩阵；2.A是不可约的；3.A是非周期的。 那么PageRank向量P就是对应矩阵A的最大特征值1的那个主特征向量。 实际上，公式(4)也可基于马尔科夫链（Markov chain）推导出来。 模型修正然而，Web图并不满足以上三个条件。 1.Web图中，A不是一个随机矩阵。 原因 有限马尔科夫链的状态转移矩阵是随机矩阵，它要求每个元素都是非负实数，且每行元素之和为1。这要求每一个网页至少要有一个出链，但实际上，很多网页根本就没有出链，从而导致状态转移矩阵A某些行全为0。这样的网页称为悬挂网页。 解决办法 从每个悬挂网页$i$向其他各个网页添加一条出链，将网页$i$到其他网页的转换概率均设为$\frac{1}{n}$。也就是说，将A中全为0的行用$\frac{\mathbf{ e}}{n}$（$\mathbf{e}$是元素全为1的n维向量）来替换。 2.Web图在一般情况下是可约的。 原因：Web图G不是强连通的。通常存在一些节点对&lt;u, v&gt;，没有从u到v的路径。 强连通图：若图G中的任意两个顶点$i$和$j$都连通，即从顶点$i$到顶点$j$和从顶点$j$到顶点$i$都存在路径，则图G是强连通图。 解决办法：同问题三 3.”A是非周期的”，并不一定成立。 周期图：状态$i$是周期的，并且具有周期$k&gt;1$，是指存在一个最小的正整数$k$，使得所有从状态$i$出发又回到状态$i$的路径长度都是$k$的整数倍。 如果一个状态不是周期的（或者$k=1$），那么它就是非周期的。如果一个马尔科夫链的所有状态都是非周期的，那么就说这个马尔科夫链是非周期的。 解决办法 从任一页面出发，到每个页面都加上一条链接，并给这一链接分配一个由参数$d$控制的微小转换概率。 通过以上修正，状态转换矩阵A满足之前的三个条件，从而得到了一个改进后的PageRank模型：$$P = \left[(1-d) \frac{E}{n} + d A^{T}\right]P \tag{5}$$其中，$E=ee^{T}$（e是元素全为1的列向量，从而E是一个nxn的元素全为1的矩阵），n是Web图中的节点总数。 公式（5）化简后，得到$$P = (1-d)e + dA^{T}P \tag{6}$$其中，e是全为1的列向量。 从而，可以得到$$P(i) = (1-d) + d \sum_{j=1}^{n} A_{ji} P(j) \tag{7}$$上式等价于$$P(i) = (1-d) + d \sum_{(j,i) \in E} \frac{P(j)}{O_{j}} \tag{8}$$其中，$d$称之为阻尼系数（damping factor），且$0 \leq d \leq 1$。一些论文中认为，$d = 0.85$是一个不错的选择。 可以使用幂迭代（power iteration）求解特征向量P，算法如下$$\begin{align}&amp; PageRank-Iterate(G) \\&amp; \quad P_{0} \leftarrow \frac{e}{n} \\&amp; \quad k \leftarrow 1 \\&amp; \quad repeat \\&amp; \qquad P_{k} \leftarrow (1-d)e+dA^{T}P_{k-1}; \\&amp; \qquad k \leftarrow k+1; \\&amp; \quad until\ \Vert P_{k} - P_{k-1} \Vert_{1} &lt; \epsilon \\&amp; \quad return\ P_{k}\end{align}$$ 参考资料 Xindong Wu，Top 10 algorithms in data mining，Knowledge and Information Systems，2008 （美）吴信东，库玛尔编著；李文波，吴素研译.数据挖掘十大算法，清华大学出版社，2013.5]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>链接挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之Apriori算法]]></title>
    <url>%2F2018%2F08%2F23%2Fmachine-learning-apriori%2F</url>
    <content type="text"><![CDATA[支持度(support)：数据集中包含该项集的记录所占的比例。 可信度或置信度（confidence）： $A \rightarrow B$的置信度为$$confidence（A\rightarrow B） = \frac{support(A , B)}{support(A)}$$Apriori原理：如果一个项集是非频繁的，那么它的所有超集也是非频繁的。 If an itemset is not frequent, any of its superset is never frequent. Apriori算法 1.从大小为k的频繁项集中生成大小为k+1的候选频繁项集$C_{k+1}$ 2.扫描数据库，计算每一个候选频繁项集的支持度 3.将满足最小支持度的频繁项集加到$F_{k+1}$中$$\begin{align}\hline&amp; 算法\ Apriori \\\hline \\&amp; F_1 = (大小为1的频繁项集); \\&amp; for(k = 1; F_k \neq \varnothing; k++)\ do\ begin \\&amp; \qquad C_{k+1} = apriori-gen(F_k);//新的候选频繁集 \\&amp; \qquad for\ 所有的交易记录t \in 数据集\ do\ begin \\&amp; \qquad \qquad C_{t}^{‘}= subset(C_{k+1},t);\ //包含在t中的候选集 \\&amp; \qquad \qquad for\ 所有的候选c \in C_{t}^{‘}\ do \\&amp; \qquad \qquad \qquad c.count ++; \\&amp; \qquad \qquad end \\&amp; \qquad \qquad F_{k+1} = \{C \in C_{k+1} |\ c.count \geq 最小的支持度 \} \\&amp; \qquad end \\&amp; end \\&amp; Answer \cup_{k} F_k;\end{align}$$算法第三行中的apriori-gen函数经过下面两步，从$F_k$生成$C_{k+1}$ 1.连接 通过合并两个大小为k，且前$k-1$项相同的频繁项集$P_k$和$Q_k$，生成大小为k+1的频繁项集$R_{k+1}$$$\begin{align}&amp; R_{k+1} = P_{k} \cup Q_{k} = \{items_{1},\dots ,items_{k-1},items_{k},items_{k^{‘}}\} \\&amp; P_{k} = \{items_{1},\dots ,items_{k-1},items_{k}\} \\&amp; Q_{k} = \{items_{1},\dots ,items_{k-1},items_{k^{‘}}\}\end{align}$$其中，$items_1 &lt; \dots &lt; items_k &lt; items_{k^{‘}}$ 2.剪枝 检查$R_{k+1}$中的所有大小为的项集中的所有大小为的项集是不是频繁的，删除中的所有大小为的项集中的所有大小为k的项集是不是频繁的，删除$R_{k+1}$中那些非频繁的项集，从而得到中那些非频繁的项集，从而得到$C_{k+1}$。因为$C_{k+1}$中大小为且非频繁的所有子集不是大小为中大小为k且非频繁的所有子集不是大小为k+1的频繁项集的子集。 示例： 假设最小支持度为2 数据库D TID Items 100 $1 \quad 3 \quad 4$ 200 $2 \quad 3 \quad 5$ 300 $1 \quad 2 \quad 3 \quad 5$ 400 $2 \quad 5$ $C_1$ {1} 2 {2} 3 {3} 3 {4} 1 {5} 3 $F_1$ 项集 支持度 {1} 2 {2} 3 {3} 3 {5} 3 $C_2$ 项集 支持度 { 1, 2 } 1 { 1, 3 } 2 { 1, 5 } 1 { 2, 3 } 2 { 2, 5 } 3 { 3, 5 } 2 $F_2$ 项集 支持度 { 1, 3 } 2 { 2, 3 } 2 { 2, 5 } 3 { 3, 5 } 2 $C_3$ 项集 支持度 { 1 , 2 , 3 } 1 { 1 , 2 , 5 } 1 { 1 , 3 , 5 } 1 { 2 , 3 , 5 } 2 $F_3$ 项集 支持度 { 2 , 3 , 5 } 2]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>关联分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的初始化块]]></title>
    <url>%2F2018%2F08%2F23%2Fjava-initialization-block%2F</url>
    <content type="text"><![CDATA[Java中的初始化代码块用一对花括号{}标明，初始化代码块在构造方法之前执行。 一个简单的例子： 12345678910111213public class Main &#123; public static void main(String[] args) &#123; Test test = new Test(); &#125;&#125;class Test &#123; &#123; System.out.println("Hello 初始化代码块"); &#125; public Test() &#123; System.out.println("执行构造方法"); &#125;&#125; 输出结果： 12Hello 初始化代码块执行构造方法 另外，Java中还有一个静态初始化代码块，用static{}来标明。静态初始化代码块在普通代码块之前被调用。 示例： 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; Test test = new Test(); &#125;&#125;class Test &#123; static&#123; System.out.println("执行静态代码块"); &#125; &#123; System.out.println("执行普通代码块"); &#125; public Test() &#123; System.out.println("执行构造方法"); &#125;&#125; 输出结果： 123执行静态代码块执行普通代码块执行构造方法 总的来说，执行顺序：静态初始化代码块&gt;普通初始化代码块&gt;构造方法]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的Object类]]></title>
    <url>%2F2018%2F08%2F22%2Fjava-object%2F</url>
    <content type="text"><![CDATA[java.lang.Object是Java中所有类的父类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Object &#123; private static native void registerNatives(); static &#123; registerNatives(); &#125; public final native Class&lt;?&gt; getClass(); public native int hashCode(); public boolean equals(Object obj) &#123; return (this == obj); &#125; protected native Object clone() throws CloneNotSupportedException; public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125; public final native void notify(); public final native void notifyAll(); public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout); &#125; public final void wait() throws InterruptedException &#123; wait(0); &#125; protected void finalize() throws Throwable &#123; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的枚举类型]]></title>
    <url>%2F2018%2F08%2F20%2Fjava-enum%2F</url>
    <content type="text"><![CDATA[枚举类的主要作用是便捷地定义静态常量，替代public static final xxx。 所有的枚举类型都是java.lang.Enum类的子类，java.lang.Enum的类结构如下： 12public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable 方法列表： 1234public final String name();public String toString();public static Enum valueOf(Class enumClass,String name);public final int ordinal(); 枚举类型的一个简单的例子： 123enum Week &#123; MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;&#125; 事实上，上面定义了一个类，它只有七个实例，这些实例只能在其他代码之前定义，并以封号结束。 如果需要的话，可以在枚举类型中添加一些构造器、方法和域。不过，枚举类型只能包含私有构造，且构造器只在构造枚举常量的时候被调用。 12345678910111213enum Week &#123; //只能在其他代码之前定义 MONDAY(1),TUESDAY(2),WEDNESDAY(3), THURSDAY(4),FRIDAY(5),SATURDAY(6),SUNDAY(7); private int day; //只在构造枚举常量的时候被调用 private Week(int day) &#123; this.day = day; &#125; public int getDay() &#123; return day; &#125;&#125; name()方法描述：返回枚举常量名。 12345678enum Week &#123; MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;&#125;public class Main &#123; public static void main(String[] args) &#123; System.out.println(Week.MONDAY.name()); &#125;&#125; 输出结果： 1MONDAY toString()方法描述：返回枚举常量名。 12345678enum Week &#123; MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;&#125;public class Main &#123; public static void main(String[] args) &#123; System.out.println(Week.MONDAY.toString()); &#125;&#125; 输出结果： 1MONDAY 通过查看源码，可以看到，toString()方法返回的是name属性。 123public String toString() &#123; return name;&#125; valueOf()1public static Enum valueOf(Class enumClass,String name); 方法描述：返回指定名字、给定类的枚举常量 123456789enum Week &#123; MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;&#125;public class Main &#123; public static void main(String[] args) &#123; Week week = Enum.valueOf(Week.class,"FRIDAY"); System.out.println(week); &#125;&#125; 输出结果： 1FRIDAY ordinal()方法描述：返回枚举常量在enum中声明的位置，位置从0开始计数。 12345678enum Week &#123; MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;&#125;public class Main &#123; public static void main(String[] args) &#123; System.out.println(Week.THURSDAY.ordinal()); &#125;&#125; 输出结果： 13 正如这个方法注释中描述的那样， 123Most programmers will have no use for this method. It is designed for use by sophisticated enum-based data structures,such as java.util.EnumSet and java.util.EnumMap. 大多数程序员用不到这个方法，它是为EnumSet和EnumMap这些基于枚举的复杂数据结构设计的。 values()每个枚举类都有一个静态方法values()，它返回一个包含全部枚举值的数组。 示例： 123456789101112131415161718192021enum Week &#123; MONDAY(1),TUESDAY(2),WEDNESDAY(3), THURSDAY(4),FRIDAY(5),SATURDAY(6),SUNDAY(7); private int day; private Week(int day) &#123; this.day = day; &#125; public int getDay() &#123; return day; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Week[] weeks = Week.values(); StringBuilder sb = new StringBuilder(); for(Week week : weeks) &#123; sb.append(week.getDay()+" "); &#125; System.out.println(sb); &#125;&#125; 输出结果： 11 2 3 4 5 6 7 equals()和==在比较两个枚举类型的值时，不需要调用equals，可以直接使用“==”。 查看源码，可以知道，Enum类的equals也是直接使用的”==”来比较。 123public final boolean equals(Object other) &#123; return this==other;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之局部加权线性回归]]></title>
    <url>%2F2018%2F08%2F17%2Fmachine-learning-locally-weighted-linear-regression%2F</url>
    <content type="text"><![CDATA[局部加权线性回归（Locally Weighted Linear Regression，LWLR）。 在该算法中，给预测点附近的每个点赋予一定的权重，在这个子集上基于最小均方差来进行普通的回归。 局部加权线性回归的均值误差可用下式表示$$\sum_{i=1}^{m} w_i (y_i - x_i^{T} \theta_i)^2$$其中，$w_i$是权重，$y_i$是真实值，$x_i$是输入值，$\theta_i$为对应的回归系数。 回归系数$w$为$$\hat w = (X^{T} W X )^{-1} X^{T} W y$$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之线性回归]]></title>
    <url>%2F2018%2F08%2F17%2Fmachine-learning-linear-regression%2F</url>
    <content type="text"><![CDATA[线性回归（linear regression），就是将输入项分别乘以一些常量，再将结果加起来得到预测值，而这些常量称之为回归系数。 线性回归可以用如下的等式来表示：$$Y = X^{T} w$$其中，$Y$为预测值，$X$为输入值，$w$是一个包含回归系数的向量 已知$X$和对应的$Y$，怎么才能找到$w$呢？一个常用的方法就是找出使误差最小的$w$。这里的误差是指预测Y值和真实Y值之间的差值，使用该误差的简单累加将使得正差值和负差值相互抵消，为了避免这种情况，可以使用平方误差。 平方误差可写为：$$\sum_{i=1}^{m} (y_i - x_i ^{T} w) ^2$$若用矩阵表示，则可写为：$$(Y - X w)^{T} (Y - Xw)$$令$$\begin{align}f(w) &amp;= (Y - X w)^{T} (Y - Xw) \\&amp;= Y^{T} Y - Y^{T} X w - w^{T} X^{T} Y + w^{T} X^{T} X w \\\end{align}$$f(w) 对$w$求导，得到$$\begin{align}\frac{\partial f(w)}{\partial w} &amp;= \frac{\partial (Y^{T} Y)} {\partial w} - \frac{\partial ( Y^{T} X w)} {\partial w} - \frac{\partial (w^{T} X^{T} Y)} {\partial w} + \frac{\partial (w^{T} X^{T} X w )} {\partial w} \\&amp;= 0 - X^{T} Y - X^{T} Y + 2 X^{T} X w \\&amp;= 2 X^{T} (Xw - Y)\end{align}$$令$\frac{\partial f(w)}{\partial w} = 0$，则$$X^{T} (X w - Y) = 0 \\=&gt; X^{T} X w = X^{T} Y \\$$两边左乘$(X^{T}X)^{-1}$，得$$\hat w = (X^{T} X )^{-1} X^{T} Y$$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵求导]]></title>
    <url>%2F2018%2F08%2F17%2Fmatrix-derivative%2F</url>
    <content type="text"><![CDATA[最近在学习机器学习的时候，经常会碰到矩阵求导，这里记录下矩阵的求导操作。 向量和矩阵的导数满足乘法法则（product rule）$$\frac {\partial x^{T} \alpha}{ \partial x } = \frac {\partial \alpha^{T} x }{ \partial x } = \alpha$$ $$\frac {\partial AB} {\alpha x} = \frac{\partial A} {\partial x} B + A \frac{\partial B} {\partial x}$$ 由于$A^{-1} A = I$和上式，逆矩阵的导数可表示为$$\frac {\partial A^{-1} } {\partial x} = - A^{-1} \frac {\partial A} {\partial x} A^{-1}$$证明：$$\begin{align}\frac{\partial I} {\partial x} &amp;= \frac{\partial A^{-1} A} {\partial x} \\&amp;= \frac{\partial A} {\partial x} A^{-1} + A \frac{\partial A^{-1} } {\partial x} \\&amp;= 0\end{align}$$从而，$$\begin{align}&amp;=&gt; -A \frac{\partial A^{-1} } {\partial x} = \frac{\partial A} {\partial x} A^{-1} \\&amp;=&gt; \frac{\partial A^{-1}} {\partial x} = -A^{-1} \frac{\partial A } {\partial x} A^{-1}\end{align}$$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux中存活下来之ssh和scp命令]]></title>
    <url>%2F2018%2F08%2F17%2Flinux-command-ssh-and-scp%2F</url>
    <content type="text"><![CDATA[前面我们讲了如何在Windows系统中登录Linux服务器，以及实现windows和Linux之间的文件传输操作。今天我们来讲下在Linux系统（如ubuntu）中如何登录Linux服务器及实现文件传输。 Linux中使用ssh命令登录其他的Linux，使用scp命令实现文件传输。 sshssh，全称Secure Shell，是一种用于远程登录的协议。 语法： 1ssh 用户名@IP地址 示例： 这里以root用户和 IP 地址118.190.95.35（从网上随便找的一个IP）为例 1ssh root@118.190.95.35 scpscp，全称secure copy，用于Linux之间复制文件和目录。 语法： 1scp [options] 源文件路径 目标路径 参数: -r：递归复制目录下的所有文件，包括目录本身 示例： 从本地上传文件到服务器 将本地的/home/hegongshan/Desktop/robots.txt文件上传到服务器118.190.95.35的/usr/local/tomcat/目录下 1scp /home/hegongshan/Desktop/xxx.txt root@118.190.95.35:/usr/local/tomcat/ 从服务器下载文件 从118.190.95.35将/usr/local/tomcat/webapps/ROOT.war下载到本机的/home/hegongshan/Desktop/目录下 1scp root@118.190.95.35:/usr/local/tomcat/webapps/ROOT.war /home/hegongshan/Desktop/ 从服务器复制目录（文件夹） 从118.190.95.35将/usr/local/tomcat/webapps/ROOT复制到本机的/home/hegongshan/Desktop/目录下 1scp -r root@118.190.95.35:/usr/local/tomcat/webapps/ROOT /home/hegongshan/Desktop/ 结果将是在/home/hegongshan/Desktop/下有一个ROOT文件夹。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用PuTTY实现Windows和Linux的文件传输]]></title>
    <url>%2F2018%2F08%2F17%2Fputty-file-upload-and-download%2F</url>
    <content type="text"><![CDATA[安装完PuTTY以后，进入命令行界面，就可以使用PuTTY的pscp命令进行文件传输。 pscp语法： 1pscp 源文件路径 目标文件路径 示例： 1pscp root@111.199.227.74:/mnt/files/abc.txt D:/file/ 值得一提的是，pscp命令只能用于文件的上传下载，若要进行文件夹（目录）的上传下载，可以先压缩，然后再使用pscp命令进行文件传输。 若命令行中显示找不到pscp命令，只需将PuTTY的安装路径添加到系统变量Path中即可。]]></content>
      <categories>
        <category>putty</category>
      </categories>
      <tags>
        <tag>putty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用PuTTY远程登录Linux服务器]]></title>
    <url>%2F2018%2F08%2F16%2Fputty-ssh%2F</url>
    <content type="text"><![CDATA[使用PuTTY已经很长时间了，是时候总结下PuTTY的用法了。 什么是PuTTY? 下面是PuTTY官网的介绍 PuTTY is an SSH and telnet client, developed originally by Simon Tatham for the Windows platform. 翻译过来就是说，PuTTY是Windows平台下的一个SSH客户端。 为什么要使用PuTTY？ 与商用的XShell相比，PuTTY是开源免费的&gt;_&lt;。 安装PuTTY从PuTTY官网下载合适的版本，目前的最新稳定版本是0.70。 成功安装后目录结构如下，我的安装路径为G:\putty 远程登录双击putty.exe，将会显示如下界面 在Host Name(or IP address)，也就是下图中红框标明的地方，输入远程Linux服务器的IP地址 然后点击Open按钮，将会显示如下界面。 在login as：后输入用户名 按照要求输入密码即可登录，值得一提的是，密码是不会显示的，这也很符合Linux设计的哲学。 小经验刚才那样的登录，每次都需要输入服务器IP地址，实际上，PuTTY提供了保存IP地址，下次自动导入的功能。 第一次登录时，输入IP地址，在Saved Sessions下的输入框中输入想保存的名字，然后点击Save按钮（图中用红框标明）。 这里以127.0.0.1为例，设置session的名字为server，点击Save按钮，Default Settings下出现了一个server 下一次登录时，只需要选择server，然后点击Load按钮，IP地址将会被自动导入。 如果不想再保存该IP地址了，则选中session的名字，然后点击Delete按钮即可删除存储的session。]]></content>
      <categories>
        <category>putty</category>
      </categories>
      <tags>
        <tag>putty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的定时器Timer]]></title>
    <url>%2F2018%2F08%2F02%2Fjava-timer%2F</url>
    <content type="text"><![CDATA[在Java中，定时任务功能使用的是Timer类，其主要作用是设置计划任务， 最近课题组的项目用到了Java中的定时器Timer类，这里记录下定时器Timer的相关知识。 Timer的构造方法如下： 1234567public Timer() public Timer(boolean isDaemon) public Timer(String name) public Timer(String name, boolean isDaemon) 方法列表如下： 123456789101112131415public void schedule(TimerTask task, long delay) public void schedule(TimerTask task, Date time) public void schedule(TimerTask task, long delay, long period) public void schedule(TimerTask task, Date firstTime, long period) public void scheduleAtFixedRate(TimerTask task, long delay, long period)public void scheduleAtFixedRate(TimerTask task, Date firstTime,long period)public void cancel()public int purge() 但封装任务的类却是TimerTask类，类结构如下： 1public abstract class TimerTask implements Runnable schedule(TimerTask task, Date time)执行任务的时间晚于当前时间，即任务在未来执行 12345678910111213141516171819202122232425import java.text.ParseException;import java.text.SimpleDateFormat;import java.time.Instant;import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class TimerDemo &#123; private static Timer timer = new Timer(); static class Task extends TimerTask &#123; @Override public void run() &#123; System.out.println("成功执行！时间："+Date.from(Instant.now())); &#125; &#125; public static void main(String[] args) throws ParseException &#123; String taskTime = "2018-08-06 20:03:30"; System.out.println("计划执行任务时间：" + taskTime); Task task = new Task(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); System.out.println("当前时间：" + sdf.format(Date.from(Instant.now()))); timer.schedule(task, sdf.parse(taskTime)); &#125;&#125; 输出结果： 可以看到，任务虽然执行完了，但进程并未销毁。这是为什么呢？ 我们先来看下Timer的无参构造， 123public Timer() &#123; this("Timer-" + serialNumber());&#125; 其内部调用的是如下构造方法 1234public Timer(String name) &#123; thread.setName(name); thread.start();&#125; 从源代码可以得知，创建一个Timer就是启动一个新线程，这个新启动的线程并不是守护进程，它一直在运行。如果需要Timer执行完任务就结束，可以使用如下构造方法，并将参数isDaemon设置为true 1public Timer(boolean isDaemon) schedule(TimerTask task, long delay, long period)作用：以执行该方法的当前时间作为参考时间，在此基础上延迟指定的毫秒数，再以指定的时间间隔无限次执行某一任务。 cancel()作用：将任务队列中的全部任务清空。 （未完待续）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之AdaBoost]]></title>
    <url>%2F2018%2F08%2F02%2Fmachine-learning-adaboost%2F</url>
    <content type="text"><![CDATA[AdaBoost（adaptive boosting）算法是提升（boosting）方法的一个最流行版本，1995年由Freund和Schapire提出。其基本思想是使用多个弱分类器（即分类器的性能并不好，错误率较高）来构建一个强分类器。 运行过程训练数据集中的每个样本，并赋予其一个权重，这些权重构成了向量D。一开始，这些权重都初始化成相等值。首先在训练数据集上训练出一个弱分类器并计算该分类器的错误率，然后在同一数据集上再次训练弱分类器。在分类器的第二次训练中，将会重新调整每个样本的权重，其中第一次分对的样本的权重将会降低，而第一次分错的样本的权重将会提高。为了从所有弱分类器中得到最终的分类结果，AdaBoost为每个分类器都分配了一个权重值$\alpha$，这些$\alpha$值是基于每个若分类器的错误率进行计算的。 错误率$\epsilon$的定义如下：$$\epsilon = \frac{未正确分类的样本数目}{所有样本数目}$$$\alpha$的计算公式如下：$$\alpha = \frac{1}{2} \ln (\frac{1-\epsilon}{\epsilon})$$计算出$\alpha$值后，需要更新权重向量D，以使得那些正确分类的样本的权重降低而错分样本的权重升高。 D的计算方法如下：$$D_{i} ^{ ( t+1) } =\begin{cases}\frac { D_{i} ^{ (t) } e^{-\alpha} } { sum(D) }, &amp; i分类正确 \\\frac{ D_{i} ^{ (t) } e^{\alpha} }{ sum(D) }, &amp; i分类错误\end{cases}$$在计算出D之后，AdaBoost又开始进入下一轮迭代。AdaBoost算法会不断地重复训练分类器和调整权重的过程，直到训练错误率为0或者弱分类器的数目达到用户的指定值为止。 $\alpha$作为每个分类器分类结果$G_{m}(x)$的权重，对所有分类器的加权分类结果进行累加求和，$$f(x) = \sum_{m=1}^{N} \alpha_{m} G_{m}(x)$$从而得到最终的分类器 $$G(x) = sign(f(x)) = sign( \sum_{m=1}^{N} \alpha_{m} G_{m}(x) )$$ AdaBoost的例子 序号 1 2 3 4 5 6 7 8 9 10 x 0 1 2 3 4 5 6 7 8 9 y 1 1 1 -1 -1 -1 1 1 1 -1 可选的阈值有2.5，5.5和8.5 若阈值为2.5，则7、8、9分类错误，分类错误率为$e = \frac {3}{10}$ 若阈值为5.5， a.$$G(x) =\begin{cases}1, &amp; x &lt; 5.5 \\-1, &amp; x &gt; 5.5\end{cases}$$此时，4、5、６以及7、８、９分类错误，分类误差率为$e = \frac {6}{10}$ b.$$G(x) =\begin{cases}1, &amp; x &gt; 5.5 \\-1, &amp; x &lt; 5.5\end{cases}$$此时，1、2、3和10分类错误，分类误差率为$e = \frac {4} {10}$ 因此，最低误差率为0.4 若阈值为8.5， a.$$G(x) =\begin{cases}1, &amp; x &lt; 8.5 \\-1, &amp; x &gt; 8.5\end{cases}$$此时，4、5、6分类错误，分类误差率为$e = \frac {3} {10}$ 可以看到当阈值为2.5或8.5时，分类误差率最低，因此，我们可任取其中一个阈值，比如2.5。 基本分类器$$G(x) =\begin{cases}1, &amp; x &lt; 2.5 \\-1, &amp; x &gt; 2.5\end{cases}$$ 算法实现我们可以选择任一分类器作为AdaBoost算法的弱分类器，这里选择单层决策树（decision stump）作为弱分类器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899"""基于单层决策树的AdaBoost分类器"""import numpy as npclass AdaBoost(): def loadDataSet(self,filename): """ 从文件中导入数据集 filename : 文件名 """ dataMat = [] labelMat = [] with open(filename) as file: for line in file.readlines(): numFeature = len(line.split('\t')) lineArr = [] currentLine = line.strip().split("\t") for i in range(numFeature-1): lineArr.append(float(currentLine[i])) dataMat.append(lineArr) labelMat.append(float(currentLine[-1])) return dataMat,labelMat def _stumpClassify(self,dataMatrix,dimension,threshold,thresholdInequality): arr = np.ones((np.shape(dataMatrix)[0],1)) if thresholdInequality == 'lt': arr[dataMatrix[:,dimension] &lt;= threshold] = -1.0 else: arr[dataMatrix[:,dimension] &gt; threshold] = -1.0 return arr def _buildStump(self,dataArr,classLabels,D): dataMatrix = np.mat(dataArr) labelMat = np.mat(classLabels).T m,n = np.shape(dataMatrix) numSteps = 10.0 bestStump = &#123;&#125; bestClassEst = np.mat(np.zeros((m,1))) minError = np.inf # 遍历每一个特征 for i in range(n): rangeMin = dataMatrix[:,i].min() rangeMax = dataMatrix[:,i].max() stepSize = (rangeMax-rangeMin)/numSteps for j in range(-1,int(numSteps)+1): for inequal in ['lt','gt']: threshold = (rangeMin + float(j) * stepSize) predictedVals = self._stumpClassify(dataMatrix,i,threshold,inequal) errArr = np.mat(np.ones((m,1))) errArr[predictedVals == labelMat] = 0 weightedError = D.T * errArr if weightedError &lt; minError: minError = weightedError bestClassEst = predictedVals.copy() bestStump['dimension'] = i bestStump['threshold'] = threshold bestStump['inequal'] = inequal return bestStump,minError,bestClassEst def adaBoostTrainDS(self,dataArr,classLabels,numIter=40): """AdaBoost训练过程""" weakClassArr = [] m = np.shape(dataArr)[0] D = np.mat(np.ones((m,1))/m) aggClassEst = np.mat(np.zeros((m,1))) for i in range(numIter): bestStump,error,classEst = self._buildStump(dataArr, classLabels, D) print("D:",D.T) alpha = float(0.5*np.log((1.0-error)/max(error,1e-16))) bestStump['alpha'] = alpha weakClassArr.append(bestStump) print("classEst:",classEst.T) expon = np.multiply(-1*alpha*np.mat(classLabels).T,classEst) D = np.multiply(D,np.exp(expon)) D = D/D.sum() aggClassEst += alpha*classEst print("aggClassEst:",aggClassEst.T) aggErrors = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T,np.ones((m,1))) errorRate = aggErrors.sum()/m print("total error:",errorRate,"\n") if errorRate == 0.0: break return weakClassArr,aggClassEst def adaClassify(self,dataToClass,classifierArr): """AdaBoost分类函数""" dataMatrix = np.mat(dataToClass) m = np.shape(dataMatrix)[0] aggClassEstimate = np.mat(np.zeros((m,1))) for i in range(len(classifierArr)): classEstimate = self.stumpClassify(dataMatrix, classifierArr[i]['dimension'], classifierArr[i]['threshold'], classifierArr[i]['inequal']) aggClassEstimate += classifierArr[i]['alpha'] * classEstimate print(aggClassEstimate) return np.sign(aggClassEstimate) (未完待续)]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列最小最优化算法SMO]]></title>
    <url>%2F2018%2F07%2F28%2Fmachine-learning-svm-smo%2F</url>
    <content type="text"><![CDATA[如何高效地实现支持向量机学习呢？常用的是1998年Platt提出的序列最小最优化算法(Sequential minimal optimization，SMO)算法。 SMO算法要解的是如下的一个最优化问题：$$\min_{\alpha} \left( \frac{1}{2} \sum_{i=1}^N \sum_{j=1}^N \alpha_i \alpha_j y_i y_j K(x_i,x_j) - \sum_{i=1}^N \alpha_i\right) \tag{1}$$ $$subject \; to \sum_{i=1}^N \alpha_i y_i = 0, \tag{2}$$ $$0 \leq \alpha_i \leq C, \forall i \tag{3}$$ 整个SMO算法包括两个部分：求解两个变量二次规划的解析方法和选择变量的启发式方法。 两个变量二次规划的求解方法假设选择的两个变量是$\alpha_1,\alpha_2$，其他变量$\alpha_i (i=3,4,\dots,N)$是固定的。因此，上面的最优化问题(1)~(3)的子问题可写为$$\min_{\alpha_1,\alpha_2} G(\alpha_1,\alpha_2) = \frac{1}{2} K_{11} \alpha_1^2 + \frac{1}{2} K_{22} \alpha_2^2 + y_1 y_2 K_{12} \alpha_1 \alpha_2 - (\alpha_1 + \alpha_2) + \\y_1 \alpha_1 \sum_{i=3}^{N} y_i \alpha_i K_{i1} + y_2 \alpha_2 \sum_{i=3}^{N} y_i \alpha_i K_{i2} \tag{4}$$ $$subject \; to \; \alpha_1 y_1 + \alpha_2 y_2 = - \sum_{i=3}^{N} y_i \alpha_i = \beta, \tag{5}$$ $$0 \leq \alpha_i \leq C, \forall i \tag{6}$$ 其中，$K_{ij} = K(x_i,x_j) ,i,j = 1,2, \dots ,N$，（４）中省略了不含$\alpha_1,\alpha_2$的常数项。 由于只有两个变量$(\alpha_1,\alpha_2)$，约束可以用二维空间中的图形表示。 不等式约束（6）使得$（\alpha_1,\alpha_2）$在区域 [0, C] x [0, C] 内，等式约束（５）使得$（\alpha_1,\alpha_2）$在平行于区域 [0, C] x [0, C] 的对角线的直线上。因此要求的是目标函数在一条平行于对角线的线段上的最优值。这使得两个变量的最优化问题成为实质上的单变量的最优化问题，不妨考虑为变量$\alpha_2$的最优化问题。 假设问题（４）～（６）的初始可行解为$\alpha_1,\alpha_2$，最优解为$\alpha_1^{new},\alpha_2^{new}$，沿着约束方向经剪辑后$\alpha_2$的最优解为$\alpha_2^{new,clipped}$。 由于$\alpha_2^{new}$满足不等式约束（５），所以最优值$\alpha_2^{new}$的取值范围必须满足条件$$L \leq \alpha_2^{new} \leq H$$其中，L与H分别是$\alpha_2^{new}$所在的对角线段端点的下、上界。 如果$y_1 \neq y_2$ ，则$$L = \max (0, \alpha_2 - \alpha_1)，H = \min ( C, C + \alpha_2 - \alpha_1 ) \tag{7}$$如果$y_i = y_2$，则$$L = \max (0, \alpha_2 + \alpha_1 - C)，H = \min ( C, \alpha_2 + \alpha_1 ) \tag{8}$$ 记$$w(x) = \sum_{i=1}^{N} \alpha_i y_i K(x_i,x) + b \tag{9}$$令$$E_i = w(x_i) - y_i = \left ( \sum_{i=1}^{N} \alpha_i y_i K(x_i,x) + b \right) - y_i, i = 1,2, \tag{10}$$当i = 1, 2时，$E_i$为函数w(x)对输入$x_i$的预测值与真实输出$y_i$之间的误差。 由$$\alpha_1 y_1 + \alpha_2 y_2 = \beta 及 y_i^2 = 1$$$\alpha_1$可表示为$$\alpha_1 = ( \beta - y_2 \alpha_2 ) y_1 \tag{11}$$代入（４）中，得到仅含$\alpha_2$的目标函数：$$G(\alpha_2) = \frac{1}{2} K_{11} ( \beta - y_2 \alpha_2 )^2 + \frac{1}{2} K_{22} \alpha_2^2 + y_2 K_{12} ( \beta - y_2 \alpha_2 ) \alpha_2 - ( \beta - y_2 \alpha_2 )y_1 - \alpha_2 + \\( \beta - y_2 \alpha_2 ) \sum_{i=3}^{N} y_i \alpha_i K_{i1} + y_2 \alpha_2 \sum_{i=3}^{N} y_i \alpha_i K_{i2}$$对$\alpha_2$求导数，并令其为 0$$\frac {\partial G} {\partial \alpha_2} = K_{11}( \alpha_2 - \beta y_2) + K_{22} \alpha_2 + y_2 K_{12} (\beta - 2 y_2 \alpha_2) + \\y_1 y_2 -1 - y_2 \sum_{i=3}^{N} y_i \alpha_i K_{i1} + y_2 \sum_{i=3}^{N} y_i \alpha_i K_{i2} = 0$$ $$\begin{align}=&gt; ( K_{11} +K_{22} -2 K_{12} ) \alpha_2 &amp;= y_2 ( y_2 - y_1 + \beta K_{11} - \beta K_{12} + \sum_{i=3}^{N} y_i \alpha_i K_{i1} - \sum_{i=3}^{N} y_i \alpha_i K_{i2} ) \\&amp;= y_2 [ y_2 - y_1 + \beta K_{11} - \beta K_{12} + \left( w(x_1) - \sum_{j=1}^{2} y_j \alpha_j K_{1j} - b \right) \\&amp; - \left( w(x_2) - \sum_{j=1}^{2} y_j \alpha_j K_{2j} - b \right) ]\end{align}$$ 将$\beta = \alpha_1 y_1 + \alpha_2 y_2 $代入，得到$$\begin{align}( K_{11} +K_{22} -2 K_{12} ) \alpha_2^{new} &amp;= y_2 \left ( y_2 - y_1 + (\alpha_1 y_1 + \alpha_2 y_2) K_{11} - (\alpha_1 y_1 + \alpha_2 y_2) K_{12} + \\w(x_1) - w(x_2) \tag {12} - y_1 \alpha_1 K_{11} - y_2 \alpha_2 K_{12} + y_1 \alpha_1 K_{21} + y_2 \alpha_2 K_{22} \right) \\&amp; = y_2 \left( E_1 - E_2 + \alpha_2 y_2 (K_{11} - 2 K_{12} + K_{22}) \right) \\&amp; = \alpha_2 (K_{11} - 2 K_{12} + K_{22}) + y_2(E_1 - E_2)\end{align}$$令$$\eta = K_{11} - 2 K_{12} + K_{22} \tag{13}$$将$\eta$代入（１２）$$\eta \alpha_2^{new} = \alpha_2 \eta + y_2 (E_1 - E_2) \\=&gt; \alpha_2^{new} = \alpha_2 + \frac {y_2 (E_1 - E_2)}{\eta} \tag {14}$$要将$\alpha_2^{new}$限制在区间[L, H]中 ，则$$\alpha_2^{new,clipped} =\begin{cases}H, &amp; \alpha_2^{new} &gt; H \\\alpha_2^{new}, &amp; L \leq \alpha_2^{new} \leq H \\L, &amp; \alpha_2^{new} &lt; L\end{cases} \tag {15}$$由式（５）可得$$\alpha_1 y_1 + \alpha_2 y_2 = \alpha_1^{new} y_1 + \alpha_2^{new,clipped} y_2$$两边同乘以$y_1$，得$$\alpha_1 + \alpha_2 y_1 y_2 = \alpha_1^{new} + \alpha_2^{new,clipped} y_1 y_2$$从而，$$\alpha_1^{new} = \alpha_1 + y_1 y_2 ( \alpha_2^{new,clipped} - \alpha_2) \tag{16}$$故，最优化问题（４）～（６）的解为$（\alpha_1^{new},\alpha_2^{new,clipped}）$ （未完待续。。。）]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax语法]]></title>
    <url>%2F2018%2F07%2F16%2Fmathjax-tutorial%2F</url>
    <content type="text"><![CDATA[如何在网页中便捷地输入数学公式呢？MathJax就是一个不错的选择。 使用$或者$$来标明需要MathJax解析的公式。$表示行内公式，而$$表示的数学公式会独占一行，如 $y=ax+b$： $y=ax+b$ $$y=ax+b$$：$$y=ax+b$$ 输入分数示例：$\frac{1}{3}$ 或者 $1 \over 3$ 显示：$\frac{1}{3}$ 开根号示例：$\sqrt{3}$ 或者 $\sqrt[n]{3}$ 显示：$\sqrt{3}$、$\sqrt[n]{3}$ 上下标^表示上标，_表示下标。如果上下标的内容多于一个字符，则需要用{ }括起来。 示例：$e^2$、$e^{ax+b}$、 显示：$e^2$、$e^{ax+b}$ 对数 普通对数：$\log_2{8}$ =&gt; $\log_2{8}$ 自然对数：$\ln 8$ =&gt; $\ln 8$ 常用对数：$\lg 100$ =&gt; $\lg 100$\ 累加、累乘 累加：$\sum_{i=1}^{n}{I^2+1}$ =&gt; $\sum_{i=1}^n{(i^2+2i+1)}$ 累乘：$\prod_{i=1}^n{\frac{1}{i^2}}$ =&gt; $\prod_{i=1}^n{\frac{1}{i^2}}$ 向量示例：$\vec x$ =&gt; $\vec x$ 积分示例：$\int_a^b sinx dx$ =&gt; $\int_a^b sinx dx$ 无穷示例：$\infty$ $\Rightarrow$ $\infty$ 偏导数示例：$\frac{\partial f(x,y)}{\partial x}$ =&gt; $\frac{\partial f(x,y)}{\partial x}$ 标签示例：$$(a+b)(a-b)=a^2-b^2 \tag{1.1}$$$$(a+b)(a-b)=a^2-b^2 \tag{1.1}$$ 最大、最小最大：$$\max_{x} y$$$$\max_{x} y$$最小：$$\min_{x} y$$$$\min_{x} y$$ 统计估计示例：$$\hat y$$$$\hat y$$ 空格空一格：a\ b =&gt; $a \ b$ 空四格：a \quad b =&gt; $a \quad b$ 空八格：a \qquad b $\Rightarrow$ $a \qquad b$ 绝对值、范数绝对值：\lvert x \rvert $\Rightarrow$ $\lvert x \rvert$ 范数：\lVert x \rVert $\Rightarrow$ $\lVert x \rVert$ 对齐123456$$\begin&#123;align&#125;y &amp;= (a-b)(a+b) \\&amp;= a^2 - b^2\end&#123;align&#125;$$ $$\begin{align}y &amp;= (a-b)(a+b) \\&amp;= a^2 - b^2\end{align}$$ 分段函数12345678$$y=\begin&#123;cases&#125;0,&amp; x &lt; 0 \\0.5,&amp; x = 0 \\1,&amp; x &gt; 0\end&#123;cases&#125;$$ $$y=\begin{cases}0,&amp; x &lt; 0 \\0.5,&amp; x = 0 \\1,&amp; x &gt; 0\end{cases}$$ 矩阵 不带括号的矩阵 1234567$$A = \begin&#123;matrix&#125;2 &amp; 0 \\0 &amp; 5\end&#123;matrix&#125;$$ $$A =\begin{matrix}2 &amp; 0 \\0 &amp; 5\end{matrix}$$ 带括号的矩阵 1.\begin{vmatrix}...\end{vmatrix}$$A =\begin{vmatrix}2 &amp; 0 \\0 &amp; 5\end{vmatrix}$$ 2.\begin{bmatrix}...\end{bmatrix}$$A =\begin{bmatrix}2 &amp; 0 \\0 &amp; 5\end{bmatrix}$$ 3.\begin{Bmatrix}...\end{Bmatrix}$$A =\begin{Bmatrix}2 &amp; 0 \0 &amp; 5\end{Bmatrix}$$4.\begin{pmatrix}...\end{pmatrix}$$A =\begin{pmatrix}2 &amp; 0 \0 &amp; 5\end{pmatrix}$$ 括号 括号 符号 $\overbrace{x,y,z}$ \overbrace{x,y,z} $\underbrace{x_1,x_2}$ \underbrace{x_1,x_2} 箭头 箭头 符号 $\uparrow$ \uparrow $\Uparrow$ \Uparrow $\downarrow$ \downarrow $\Downarrow$ \Downarrow $\rightarrow$ \rightarrow $\Rightarrow$ \Rightarrow $\leftarrow$ \leftarrow $\Leftarrow$ \Leftarrow 四则运算 四则运算 符号 + + - - $\times$ \times $\div$ \div 关系运算法 关系运算 符号 $\leq$ \leq $\geq$ \geq $\neq$ \neq 逻辑运算符 逻辑运算 符号 $\forall$ \forall $\cup$ \cup $\cap$ \cap $\in$ \in $\notin$ \notin $\varnothing$ \varnothing 希腊字母 字母 符号 $\alpha$ \alpha $\beta$ \beta $\gamma$ \gamma $\lambda$ \lambda $\eta$ \eta $\epsilon$ \epsilon $\theta$ \theta $ \sigma $ \sigma $\Sigma$ \Sigma]]></content>
      <categories>
        <category>mathjax</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性可分支持向量机]]></title>
    <url>%2F2018%2F07%2F16%2Fmachine-learning-svm-linearly-separable%2F</url>
    <content type="text"><![CDATA[线性可分支持向量机分离超平面$$\mathbf w \cdot \mathbf x +b = 0 \tag {1}$$ 其中，w为分离超平面的法向量，b为截距 分类决策函数$$f(x) = sign(\mathbf w \cdot \mathbf x +b)$$其中，sign()称为符号函数，$$sign(x) =\begin{cases}-1, &amp; x &lt; 0 \\0, &amp; x = 0 \\1, &amp; x &gt; 0\end{cases}$$ 函数间隔定义：对于给定的训练数据集T和超平面(w,b)，定义超平面(w,b)关于样本点($x_i,y_i$)的函数间隔为$$\hat \gamma_i = y_i ( w \cdot x_i + b)$$定义超平面(w,b)关于训练数据集T的函数间隔为超平面(w,b)关于T中所有样本点($x_i,y_i$)的函数间隔之最小值，即$$\hat \gamma = \min_{i=1,\dots,N} \hat \gamma_i$$ 几何间隔定义：对于给定的训练数据集T和超平面(w,b)，定义超平面(w,b)关于样本点($x_i,y_i$)的几何间隔为$$\gamma_i = y_i \frac {w \cdot x_i + b}{||w||}$$定义超平面(w,b)关于训练数据集T的几何间隔为超平面(w,b)关于T中所有样本点($x_i,y_i$)的几何间隔之最小值，即$$\gamma = \min_{i=1,\dots,N} \gamma_i$$超平面（w，b）关于样本点（$x_i,y_i$）的几何间隔是实例点到超平面的带符号的距离。 函数间隔和几何间隔有如下关系：$$\gamma_i = \frac{\hat \gamma_i}{||w||}$$ $$\gamma = \frac{\hat \gamma}{||w||}$$ 若||w||=1，则函数间隔和几何间隔相等。如果超平面参数w和b成比例地改变（超平面没有改变），函数间隔也会按比例改变，而几何间隔不变。 间隔最大化如何求得几何间隔最大的分离超平面，即最大间隔分离超平面呢？可用下面的约束最优化问题来表示$$\max_{w,b} \gamma \\s.t. y_i \frac{w \cdot x_i +b }{||w||} \geq \gamma, i=1,2,\dots,N$$约束条件表示超平面(w,b)关于每个训练样本点的几何间隔至少是$\gamma$ 根据函数间隔和几何间隔的关系，上面的问题可写为$$\max_{w,b} \frac{\hat \gamma}{||w||}$$ $$s.t. y_i ( w \cdot x_i +b ) \geq \hat \gamma, i=1,2,\dots,N$$ 函数间隔$\hat \gamma$的取值并不影响最优化问题的解。因为将w和b按比例改变为$\lambda w 和\lambda b$，这时函数间隔变为$\lambda \hat \gamma$，函数间隔的改变对上面的最优化问题的不等式约束没有影响，对目标函数的优化也没有影响。 不妨取$\hat \gamma = 1$，将其代入上面的最优化问题，得$\max_{w,b} \frac{1}{||w||}$，又最大化$\frac{1}{||w||}$等价于最小化$\frac{1}{2}||w||^2$。 故得到了下面的线性可分支持向量机学习的最优化问题$$\min_{w,b} \frac{1}{2}||w||^2$$ $$s.t. y_i ( w \cdot x_i +b ) - 1 \geq 0, i = 1,2,\dots,N$$ 对式（4）使用拉格朗日乘数法（Lagrange multipliers）可得到其“对偶问题”(dual problem)。对式（4）的每条约束添加拉格朗日乘数$\alpha_i \geq 0$，则该问题的拉格朗日函数可写为$$L(w,b,\alpha) = \frac{1}{2}||w||^2 + \sum_{i=1}^{m} \alpha_i (1-y_i(w \cdot x_i +b)) \tag{5}，\\其中 \alpha = (\alpha_i,\alpha_2,\dots,\alpha_m)^T$$令L(w,b,$\alpha$)对w和b的偏导数为零，$$\begin{align}&amp; \frac{\partial L}{\partial w} = w - \sum_{i=1}^{m} \alpha_i y_i \mathbf x_i = 0\\&amp; \frac{\partial L}{\partial b} = -\sum_{i=1}^{m} \alpha_i y_i = 0\end{align}$$从而，$$w = \sum_{i=1}^{m} \alpha_i y_i \mathbf x_i \tag {6}$$ $$0 = \sum_{i=1}^{m} \alpha_i y_i \tag {7}$$ 将式（6）、（7）代入式（5）中，得：$$\begin{align}L(w,b,\alpha) &amp; = \frac{1}{2} \sum_{i=1}^{m} \alpha_I y_i \mathbf x_i^T \sum_{j=1}^{m} \alpha_j y_j \mathbf x_j + \sum_{i=1}^{m} \alpha_i ( 1 - y_i( \mathbf x_i \sum_{j=1}^{m} \alpha_j y_j \mathbf x_j^T + b) )\\&amp; =\sum_{i=1}^{m} \alpha_i - \frac{1}{2}\sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_i \alpha_j y_i y_j \mathbf x_i^T x_j\end{align}$$ 故，式(4)的对偶问题为$$\max_\alpha [ \sum_{i=1}^{m} \alpha_i - \frac{1}{2}\sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_i \alpha_j y_i y_j (\mathbf x_i \cdot \mathbf x_j) ] \tag{8} \\s.t. \sum_{i=1}^{m} \alpha_i y_i = 0,\\\alpha_i \geq 0, i = 1,2,\dots,m$$ 例题已知一个训练数据集，其正例点是$x_1 = (3,3),x_2 = (4,3)$,负例点是$x_3 = (1,1)$，求线性可分支持向量机。 解：对偶问题是$$\min_\alpha \left ( \frac{1}{2}\sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_i \alpha_j y_i y_j (\mathbf x_i \cdot \mathbf x_j) - \sum_{i=1}^{m} \alpha_i \right) \\= \frac{1}{2}(18 \alpha_1^2+25 \alpha_2^2 + 2 \alpha_3^2 + 42\alpha_1 \alpha_2 - 12 \alpha_1 \alpha_3 - 14 \alpha_2 \alpha_3) -\alpha_1 - \alpha_2 - \alpha_3 \\s.t. \alpha_1 + \alpha_2 - \alpha_3 = 0 \\\alpha_i \geq 0 , i = 1,2,3$$将$\alpha_3 = \alpha_1 + \alpha_2$代入目标函数并记为$$s(\alpha_1,\alpha_2) = 4 \alpha_1^2 + \frac{13}{2} \alpha_2^2 + 10 \alpha_1 \alpha_2 - 2 \alpha_1 - 2 \alpha_2$$ 对$\alpha_1,\alpha_2$求偏导数，并其为0$$\frac{\partial s}{\partial \alpha_1} = 8 \alpha_1 + 10 \alpha_2 - 2 = 0\\\frac{\partial s}{\partial \alpha_2} = 13 \alpha_2 + 10 \alpha_1 - 2 = 0$$联立上式，解得：$$\alpha_1 = \frac{3}{2}, \alpha_2 = -1$$从而，$s(\alpha_1,\alpha_2)在（\frac{3}{2}, -1）$取极值，但该点不满足约束条件$\alpha_2 \geq 0$，所以最小值应在边界上取得。 当$\alpha_1 = 0$时，$$\begin{align}s(\alpha_2) &amp;= \frac{13}{2} \alpha_2^2 - 2 \alpha_2 \\&amp;= \frac{13}{2} (\alpha_2^2 - \frac{4}{13} \alpha_2) \\&amp;= \frac{13}{2} (\alpha_2 - \frac{2}{13})^2 - \frac{2}{13}\end{align}$$显然，当$\alpha_2 = \frac{2}{13}$时，$s(\alpha_1,\alpha_2)$取得最小值$s(0,\frac{2}{13}) = - \frac{2}{13}$。 同理可得，当$\alpha_2 = 0$时，$s(\alpha_1,\alpha_2)$的最小值$s(\frac{1}{4},0) = - \frac{1}{4}$。 故，$s(\alpha_1,\alpha_2)$在$\alpha_1 = \frac{1}{4} ,\alpha_2 = 0)$处达到最小，此时，$\alpha_3 = \frac{1}{4}$ 因此，$\alpha_1^* = \alpha_3^* = \frac{1}{4}$对应的实例点$x_1,x_3$是支持向量。$$\begin{align}w_1^{*} &amp; = \alpha_1^{*} y_1 x_{11} + \alpha_3^{*} y_3 x_{31}\\&amp;=\frac{1}{4} \times 1 \times 3 + \frac{1}{4} \times (-1) \times 1\\&amp;=\frac{1}{2}\end{align}$$同理可得，$$w_2^* = \alpha_1^* y_1 x_{12} + \alpha_3^* y_3 x_{32} =\frac{1}{2}$$ $$\begin{align}b^* &amp;= y_1 - [ \alpha_1^*y_1(x_1 \cdot x_1) + \alpha_3^*y_3(x_3 \cdot x_1)] \\&amp;= 1 - \left( \frac{1}{4} \times 1 \times [ (3,3) \cdot (3,3) ] + \frac{1}{4} \times (-1) \times [(1,1) \cdot (3,3) \right) \\&amp;= -2\end{align}$$ 故，分离超平面为$$\frac{1}{2}x^{(1)} + \frac{1}{2} x^{(1)} - 2 = 0$$分类决策函数为$$f(x) = sign \left( \frac{1}{2}x^{(1)} + \frac{1}{2} x^{(1)} - 2 \right)$$ （未完待续。。。）]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之logistic回归]]></title>
    <url>%2F2018%2F07%2F10%2Fmachine-learning-logistic-regression%2F</url>
    <content type="text"><![CDATA[对于二分类任务，其输出标记为y ∈ {0,1}，因此我们需要一个将自变量z转换为0/1值，最理想的是 “单位阶跃函数”（unit-step function），亦称Heaviside函数。$$y=\begin{cases}0, &amp; \text{z &lt; 0} \\0.5, &amp; \text{z = 0} \\1, &amp; \text{z &gt; 0}\end{cases}$$ 然而，单位阶跃函数的问题在于：该函数是一个不连续的分段函数，它在x=0处从0瞬间跳跃到了1。 我们希望找到一个近似单位阶跃函数的“替代函数”（surrogate function），并希望它单调可微。对数几率函数正是这样一个替代函数。 对数几率函数：$$y=\frac{1}{1+e^{-z}}$$ 对数几率函数是一种Sigmoid函数（形似S的函数），它将z值转化为一个接近0或1的y值。从上面[-5,5]以及[-60,60]两张局部图可以看出，其在[-5,5]这个区间范围内变化很陡，函数值从0快速跳跃到了1。 算法思想在每个特征上都乘以一个回归系数，然后把所有的结果值相加，将这个总和代入Sigmoid函数中，进而得到一个范围在0~1之间的数值。任何大于0.5的数据被分入1类，小于0.5则被归入0类。 二项logistic回归模型：$$P(Y=1|x)=\frac{1}{1+e^{-(w \cdot x + b)}}=\frac{e^{w \cdot x+b}}{1+e^{w \cdot x+b}}=h(x)$$ $$P(Y=0|x)=\frac{1}{1+e^{w \cdot x+b}}$$ 其中，x ∈ $R^n$是输入向量，w ∈ $R^n$是权重向量，$w \cdot x$为w和x的内积。 方便起见，将输入向量和权重向量加以扩充，仍记作w，x，即$$w = (w^{(1)},w^{(2)},\dots,w^{(n)},b)^T$$ $$x=(x^{(1)},x^{(2)},\dots,x^{(n)},1)^T$$ 此时，二项logistic回归模型：$$P(Y=1|x)=\frac{e^{w \cdot x}}{1+e^{w \cdot x}}=h(x)$$ $$P(Y=0|x)=\frac{1}{1+e^{w \cdot x}}$$ 我们可以通过最大似然估计法（maximum likelihood method）来估计w。 似然函数：$$\prod^{n}_{i=1}[{h(x_i)]^{y_i}}[1-h(x_i)]^{1-y_i}$$对数似然函数：$$L(w)=\sum^n_{i=1} [ {y_i \ln h(x_i)+(1-y_i) \ln (1-h(x_i))}]\\=\sum^n_{i=1} [y_i \ln \frac{h(x_i)}{1-h(x_i)}+\ln(1-h(x_i))]\\=\sum^n_{i=1}[{y_i ( w \cdot x_i)-\ln(1+\rm e^{w \cdot x_i})}]$$从而$$\hat w = argmax_w L(w)$$ 求最优回归系数梯度上升法算法思想大学高等数学下册中说，沿梯度方向的方向导数最大，也就是说，梯度方向是函数f(x,y)在某一点(x,y)处增长最快的方向。 要找到某函数的最大值，最好的方法就是沿着该函数的梯度方向探寻。 梯度上升算法的迭代公式： $$w=w+\alpha \cdot grad L(w)$$其中，$\alpha$为步长，表示每次沿梯度方向移动的距离；grad L(w)表示L(w)的梯度。 梯度公式$$grad f(x,y,z) = \frac{\partial f}{\partial x} \cdot \vec i + \frac{\partial f}{\partial y} \cdot \vec j + \frac{\partial f}{\partial z} \cdot \vec k$$根据之前求得的对数似然函数，对w求偏导数$$\frac{\partial L(w)}{\partial w}=\sum^n_{i=1}[{y_i x_{i}} - \frac{x_{i}e^{w \cdot x_i}}{1+e^{w \cdot x_i}}]\\=\sum^n_{i=1}{x_{i}(y_i-h(x_i))}$$故$$grad L(w_1,w_2,\dots,w_n)=\sum_{k=1}^n \frac{\partial L(w)}{\partial w_k}\cdot \vec{i_k}\\= ( \sum_{i=1}^{n}x_{i1}(y_i-h(\vec{x_i})), \sum_{i=1}^{n}x_{i2}(y_i-h(\vec{x_i})),\dots,\sum_{i=1}^{n}x_{in}(y_i-h(\vec{x_i})))^T$$ 代码实现12345678910111213141516171819202122232425import numpy as npdef sigmoid(inputVector): return 1.0/(1+np.exp(-inputVector))def gradientAscent(dataMatrix,classLabels,iterations=500,alpha=0.001): """梯度上升算法""" dataMatrix = np.mat(dataMatrix) # transpose()将矩阵转置 labelMatrix = np.mat(classLabels).transpose() m,n = np.shape(dataMatrix) weights = ones((n,1)) for k in range(iterations): h = sigmoid(dataMatrix*weights) error = (labelMatrix-h) weights = weights + alpha * dataMatrix.transpose() * error return weightsdef classifyVector(inputVector,weights): """logistic回归分类函数""" p = sigmoid(inputVector*weights) if p &gt; 0.5: return 1 else: return 0 随机梯度上升一次仅用一个样本点来更新回归系数。 12345678910def randomGradientAscent(dataMatrix,classLabels,alpha=0.001): """随机梯度上升算法""" m,n = np.shape(dataMatrix) weights = np.ones(n) for i in range(m): # dataMatrix[i]*weights 逐元素相乘 h = sigmoid(sum(dataMatrix[i]*weights)) error = classLabels[i]-h weights = weights + alpha*dataMatrix[i]*errorreturn weights 改进的随机梯度上升改进 动态调整alpha 随机选取样本来更新回归系数 代码实现： 1234567891011121314def improvedRandomGradientAscent(dataMatrix,classLabels, iterations=500,alpha=0.001) m,n = np.shape(dataMatrix) weights = np.ones(n) for j in range(iterations): dataIndex = range(m) for i in range(m): alpha = alpha + 4/(1+i+j) randomIndex = int(np.random.uniform(0,len(dataIndex))) h = sigmoid(sum(dataMatrix[randomIndex]*weights)) error = classLabels[randomIndex] - h weights = weights + alpha * error * dataMatrix[randomIndex] del dataIndex[randomIndex] return weights 梯度下降法梯度下降法与梯度上升法类似，用于求函数的最小值，其迭代公式如下：$$w=w-\alpha \cdot grad L(w)$$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之朴素贝叶斯]]></title>
    <url>%2F2018%2F07%2F02%2Fmachine-learning-navie-bayes%2F</url>
    <content type="text"><![CDATA[在讲朴素贝叶斯之前，我们先来回顾一下大学二年级概率论中的相关知识． 条件概率公式： $$P(A|B) = \frac{P(AB)}{P(B)}$$ $$=&gt; P(AB) = P(A|B)P(B)$$ 全概率公式： $$P(A)=\sum_{i=1}^{\infty}{P(B_i)P(A|B_i)}$$ 贝叶斯公式： $$P(B_i|A)=\frac{P(AB_i)}{P(A)}=\frac{P(A|B_i)P(B_i)}{\sum_{i=1}^{\infty}{P(B_i)P(A|B_i)}}$$ 算法思想朴素贝叶斯是贝叶斯决策理论的一部分，而贝叶斯决策理论的核心思想是选择具有最高概率的决策． 举个很简单的例子，一般网站评论或者游戏聊天都会对侮辱性词汇进行屏蔽过滤． 假设现在存在一条评论，如何判断它是否包含侮辱性词汇？我们用P1(w)表示评论w包含侮辱性词汇的概率，用p2(w)表示评论w不包含侮辱性词汇的概率，那么对于评论w，可以用下面的规则来判断它的类别： 如果P1(w) &gt; P2(w) ，那么w为包含侮辱性词汇的评论． 如果P2(w) &gt; P1(w)，那么w为不包含侮辱性词汇的评论． 假设前提朴素贝叶斯是用于文档分类的常用算法，它是基于以下假设对贝叶斯分类器的一个扩展． 特征之间相互独立，即一个特征出现的可能性与其他特征没有关系．比如，如果文档中一个词出现的概率不依赖于文档中的其他词，那么文档中词与词之间相互独立． 每个特征同等重要． 我们知道这两个假设过于简单，这也是之所以称之为朴素（navie）贝叶斯的原因． 理论模型$$P(c|\mathbf{x})=\frac{P(c)P(\mathbf{x}|c)}{P(\mathbf{x})}$$ 其中，P(c)是类＂先验＂(prior)概率，$P(\mathbf{x}|c)$是样本x相对于类标记c的类条件概率，或称为＂似然＂，$P(\mathbf{x})$是用于归一化的＂证据＂因子． 对于给定样本x，证据因子$P(\mathbf{x})$与类标记无关，因此估计$P(c|\mathbf{x})$的问题就转化为如何基于训练数据D来估计先验概率P(c)和条件概率$P(\mathbf{x}|c)$ 根据大数定律，当训练集包含充足的独立同分布样本时，P(c)可通过各类样本出现的频率来进行估计． 对于条件概率$P(\mathbf{x}|c)$来说，由于假设x的各个属性相互独立，因此 $$P(\mathbf{x}|c) = P(x_1x_2…x_n|c) = P(x_1|c)P(x_2|c) \cdot\cdot\cdot P(x_n|c) = \prod_{i=1}^{n}{P(x_i|c)}$$ 其中，n为x的属性个数 由于连乘操作易造成下溢出，即太多很小的数相乘导致结果四舍五入后得到0，通常使用对数进行处理，将连乘变为累加，从而避免下溢出．因此， 令$$L = P(c)P(\mathbf{x}|c)$$ 则$$log L = log P(c) + log P(\mathbf{x}|c) = log P(c) + \sum_{i=1}^{n}{log P(x_i|c)}$$ 拉普拉斯修正为了避免其他属性（特征）携带的信息被训练集中未出现的属性值＂抹去＂，即为了避免多个条件概率相乘时某个概率值为0，导致最后的乘积为0，在估计概率值时通常要进行＂平滑＂，常用＂拉普拉斯修正＂． 具体来说，令N表示训练集D中可能的类别数，$N_i$表示第i个属性可能的取值数，则 $$P(c)=\frac{|D_c|+1}{|D|+N}$$ $$P(w_i|c)=\frac{|D_{c,x_i}|+1}{|D_c|+N_i}$$ 示例：文本分类朴素贝叶斯分类器通常有以下两种实现方式 词集模型：将每个词的出现与否作为一个特征，值为1表示词条出现在文档中，0表示词条未出现 词袋模型：将每个词在文档中出现的次数作为一个特征 下面我们用词集模型，来实现一个区分某一评论是否包含侮辱性词汇的朴素贝叶斯分类器． 创建一个bayes.py文件， 将训练集转化为词汇列表 1234567891011from numpy import *def createVocabularyList(dataset): """ 从数据集中抽取不重复的词汇列表 dataset: 给定的数据集 """ vocabularySet = set([]) # 创建一个空集合 for document in dataset: # 操作符｜表示求两个集合的并集 vocabularySet = vocabulary | set(document) return list(vocabularySet) 将训练集中的某一条数据转化为向量 1234567891011121314def setOfWords2Vector(vocabularyList,inputSet): """ 根据词汇列表，将输入的数据集转化为与词汇列表维度相同的向量 """ # 创建一个长度为len(vocabularyList)，所含元素都为0的向量 # 等价于 # returnVector = [] # for i in range(len(vocabularyList)): # returnVector[i] = 0 returnVector = [0]*len(vocabularyList) for word in inputSet: if word in vocabularyList: returnVector[vocabularyList.index(word)] = 1 return returnVector 创建朴素贝叶斯分类器训练函数 123456789101112131415161718192021222324252627282930def trainNavieBayes(trainMatrix,trainCategory): """ 贝叶斯分类器训练函数 trainMatrix: numpy中array类型，是由训练集转化的所有向量组成的矩阵 trainCategory: 由矩阵中每一向量的所属类别组成的列表 """ numTrainDocs = len(trainMatrix) numWords = len(trainMatrix[0]) # pAbusive = sum(trainCategory)/float(numTrainDocs) # 拉普拉斯修正 pAbusive = (sum(trainCategory) + 1)/(float(numTrainDocs) + 2) p0Vector = zeros(numWords);p1Vector = zeros(numWords) # 计算某一类别下的总词数 # p0NumWords = 0.0;p1NumWords = 0.0 # 使用拉普拉斯修正后 p0NumWords = 2.0;p1NumWords = 2.0 for i in range(numTrainDocs): if trainCategory[i] == 1: p1Vector += trainMatrix[i] p1NumWords += sum(trainMatrix[i]) else: p0Vector += trainMatrix[i] p0NumWords += sum(trainMatrix[i]) # 用某个类别下某个词出现的次数除以该类别下的总词数， # 即求得某一类别c在每一个属性上的概率p(ci) # p0Vector = p0Vector/p0NumWords # p1Vector = p1Vector/p1NumWords p0Vector = log(p0Vector/p0NumWords) p1Vector = log(p1Vector/p1NumWords) return p0Vector,p1Vector,pAbusive 创建朴素贝叶斯分类函数 1234567def classifyNavieBayes(vector2Classify,p0Vector,p1Vector,pc1): p1 = sum(vector2Classify*p1Vector) + log(pc1) p0 = sum(vector2Classify*p0Vector) + log(1.0-pc1) if p1 &gt; p0: return 1 else: return 0 上面程序的第2行，就是在求 $$log L = log P(c) + log P(\mathbf{x}|c) = log P(c) + \sum_{i=1}^{n}{log P(x_i|c)}$$ 接下来我们测试一下刚才的分类器是否有效 1234567891011121314151617181920212223242526def loadDataSet(): postingList = [['my','dog','has','flea','problems','help','please'], ['maybe','not','take','him','to','dog','park','stupid'], ['my','dalmation','is','so','cute','I','love','him'], ['stop','posting','stupid','worthless','garbage'], ['mr','licks','ate','my','steak','how','to','stop','him'], ['quit','buying','worthless','dog','food','stupid']] # 0表示正常言论，１表示包含侮辱性词汇的评论 categoryVector = [0,1,0,1,0,1] return postingList,categoryVectordef testNavieBayes(): listOfPosts,listClasses = loadDataSet() vocabularyList = createVocabularyList(listOfPosts) trainMatrix = [] for post in listOfPosts: trainMatrix.append(setOfWords2Vector(vocabularyList,post)) p0Vector,p1Vector,pc1 = trainNavieBayes(array(trainMatrix),array(listClaasses)) testPost = ['love','my','dalmation'] testVector = array(setOfWords2Vector(vocabularyList,testPost)) print(str(testPost)+" 被分类为:"+ classifNavieBayes(testVector,p0Vector,p1Vector,pc1)) testPost = ['stupid','garbage'] testVector = array(setOfWords2Vector(vocabularyList,testPost)) print(str(testPost)+" 被分类为:"+ classifNavieBayes(testVector,p0Vector,p1Vector,pc1)) 参考资料 机器学习实战, Peter Harrington, 人民邮电出版社 机器学习, 周志华, 清华大学出版社]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Command 'scrapy' not found]]></title>
    <url>%2F2018%2F06%2F30%2Fcommand-scrapy-not-found%2F</url>
    <content type="text"><![CDATA[问题描述在ubuntu中执行 1pip3 install scrapy 成功安装scrapy，且在python命令行交互模式中成功执行 1import scrapy 但是在终端中执行scrapy startproject xxx时，出现＂Command ‘scrapy’ not found＂ 解决办法找到python的主目录，我的是 1/home/hegongshan/.local/lib/python3.6 在上面lib的同级目录bin下有一个scrapy文件，我的是/home/hegongshan/.local/bin 为该目录下的scrapy文件在/usr/bin目录下建立一个软链接 1sudo ln -s /home/hegongshan/.local/bin/scrapy /usr/bin 然后在终端下执行scrapy，可以看到，]]></content>
      <categories>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之k-近邻算法]]></title>
    <url>%2F2018%2F06%2F27%2Fmachine-learning-knn%2F</url>
    <content type="text"><![CDATA[k-近邻算法（k-Nearest Neighbor，简称kNN）,工作原理： 存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系． 输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似的数据（最近邻）的分类标签．一般来说，只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数． 最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类． 算法实现创建一个kNN.py文件 123456789101112131415161718192021222324252627282930313233343536373839from numpy import *import operatordef classify(inputData,dataSet,labels,k): """ k-近邻算法 inputData: 需要预测分类的数据 dataSet: 训练样本集 labels: 样本集的分类标签 k: k-近邻算法中k,选择最近邻居的数目 """ # 取得样本集合中的样本个数，shape是numpy中用于计算矩阵维度的元组，这里的shape[0]可以理解为求二维矩阵dataSet的行数 dataSetSize = dataSet.shape[0] # 求输入数据与样本集合的差值，tile()是numpy中用于扩展矩阵的函数，这里是将inputData扩展为dataSize行的矩阵，以确保inputData与dataSize同维度，可以相减 differenceMatrix = tile(inputData,(dataSize,1)) - dataSet # 差矩阵的每个元素平方 sqDifferenceMatrix = sqDifferenceMatrix**2 # 对平方后的差距阵每一行求和 sqDistances = sqDifferenceMatrix.sum(axis=1) # 求得输入数据与所有样本的距离 distances = sqDistances**0.5 # 按照从小到大的顺序对距离列表中的每个距离排序，按排序顺序返回排序之前的索引号 sortedDistanceIndicies = distances.argsort() # kClassData 用于存储最相似的k个数据中出现的所有分类及该分类出现的次数，以分类标签作为键，以频度作为值 kClassData = &#123;&#125; for i in range(k): label = labels[sortedDistanceIndicies[k]] # 以下三行，书上简写为kClassCount[label] = kClassData.get(label,0) + 1 # 其中的get()方法，表示若不存在键label，则执行kClassData[label] = 0 if label not in kClassData: kClassData[label] = 0 kClassData[label] += 1 # 对kClassData 按出现的频度降序排序 # 书上这里写的是kClassData.iteritems()，这是python2中字典的方法，python3中只有items()方法 sortedkClassData = sorted(kClassData.items(), key=operator.itemgetter(1), reverse=True) # 返回k个最相似数据中出现频度最高的分类标签 return sortedkClassData[0][0] 上面的程序使用了欧式距离公式，计算两个n维向量A和B之间的距离: $$d=\sqrt{\sum_{i=1}^n{(A_i- B_i)^2}}$$ 例如，点(2,1,5)和(1,2,3)之间的距离计算为： $$d=\sqrt{(2-1)^2+(1-2)^2+(5-3)^2}$$ 测试算法已知6部电影的打斗镜头，接吻镜头及其类型（模拟的数据），判断一部已知打斗镜头和接吻镜头数的新电影，它的类型是动作片，还是爱情片，具体数据如下: 电影名称 打斗镜头 接吻镜头 电影类型 小时代 0 50 爱情片 鬼吹灯之寻龙诀 100 15 动作片 战狼 150 5 动作片 让子弹飞 80 2 动作片 左耳 6 50 爱情片 心花路放 5 40 爱情片 ? 18 90 待定 我们当然可以一眼看出来，这部新电影应该是爱情片，但是，如何让程序自动预测它的类别呢？ 创建一个test.py，代码如下: 1234567891011121314import kNNdef createDataSet(): dataSet = array([0,50],[100,15],[150,5], [80,2],[6,50],[5,40]) labels = ['爱情片','动作片','动作片','动作片','爱情片','爱情片'] return dataSet,labelsdef testKNN(): inputData = [18,90] dataSet,labels = createDataSet() return kNN.classify(inputData,dataSet,labels,3) label = testKNN()print(label) 输出结果： 1爱情片 可以看到，kNN算法确实准确的预测了新电影的分类． 算法改进欧式距离中，数字差值越大的属性对计算结果的影响也越大．若想消除这种影响，使各属性权重相等，可以将数值归一化，如将取值范围处理为0到1，或者-1到1之间． 下面的公式可以将任意取值范围的特征值转化为0到1区间内的值： $$newValue = \frac{oldValue-min}{max-min}$$ 其中，min和max分别是数据集中某一特征（属性）的最小值和最大值 在kNN.py中新增如下代码： 12345678910def autoNorm(dataSet): """将训练集中的数据归一化""" minValues = dataSet.min(0) maxValues = dataSet.max(0) ranges = maxValues - minValues normDataSet = zeros(shape(dataSet)) m = dataSet.shape[0] normDataSet = dataSet - tile(minVals,(m,1)) normDataSet = normDataSet/tile(ranges,(m,1)) return normDataSet 接着修改classify()函数 12345678910111213141516171819202122232425def classify(inputData,dataSet,labels,k): """ k-近邻算法 inputData: 需要预测分类的数据 dataSet: 训练样本集 labels: 样本集的分类标签 k: k-近邻算法中k,选择最近邻居的数目 """ dataSet = autoNorm(dataSet)# 添加这一行 dataSetSize = dataSet.shape[0] differenceMatrix = tile(inputData,(dataSize,1)) - dataSet sqDifferenceMatrix = sqDifferenceMatrix**2 sqDistances = sqDifferenceMatrix.sum(axis=1) distances = sqDistances**0.5 sortedDistanceIndicies = distances.argsort() kClassData = &#123;&#125; for i in range(k): label = labels[sortedDistanceIndicies[k]] if label not in kClassData: kClassData[label] = 0 kClassData[label] += 1 sortedkClassData = sorted(kClassData.items(), key=operator.itemgetter(1), reverse=True) return sortedkClassData[0][0] 涉及的一些numpy中的函数]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析之matplotlib]]></title>
    <url>%2F2018%2F06%2F26%2Fpython-data-analysis-matplotlib%2F</url>
    <content type="text"><![CDATA[matplotlib 折线图1234import matplotlib.pyplot as plty = [1,4,9,16]plt.plot(y)plt.show() 修改标签文字和线条粗细 12345678910import matplotlib.pyplot as plty = [1,4,9,16,25]plt.plot(y,linewidth=5)# plt.title('Squares Numbers',fontsize=24)plt.xlabel('value',fontsize=14)plt.ylabel('square of value',fontsize=14)plt.tick_params(axis='both',labelsize=14)plt.show() 校正图形 1234567891011import matplotlib.pyplot as pltx = [1,2,3,4,5]y = [i**2 for i in x]plt.plot(x,y,linewidth=5)# plt.title('Squares Numbers',fontsize=24)plt.xlabel('value',fontsize=14)plt.ylabel('square of value',fontsize=14)plt.tick_params(axis='both',labelsize=14)plt.show() 散点图画分段函数]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据分析之NumPy]]></title>
    <url>%2F2018%2F06%2F25%2Fpython-data-analysis-numpy%2F</url>
    <content type="text"><![CDATA[NumPy（Numerical Python）是高性能科学计算和数据分析的基础包。 下面记录一些NumPy中的基础函数及应用。 按照标准约定，我们在使用NumPy时，最好遵循如下格式： 1import numpy as np ndarrayndarray是一个n维数组对象，其中的所有元素必须是相同类型的值。 ndarray常见属性： shape：表示各个维度大小的元组 dtype：表示数组数据类型的对象 通过NumPy中的array()函数，即可将一切序列型的对象转换为NumPy中的数组。 示例： 1234import numpy as npdata = np.array([[1,2,4,5],[1.1,23,1234,5]])print(data.shape)print(data.dtype) 输出结果： zeros, ones除了可以使用array()函数创建数组外，还可以使用zeros、ones来创建数组。 接受参数： 表示维度大小的元组shape 表示数据类型的dtype 返回：一个指定维度且元素值全为0或1的数组 示例： 12345678910import numpy as np# 创建一个１行３列的全0数组np.zeros(3)# 创建一个３行3列的全0数组np.zeros((3,3))# 创建一个3x3x2的全0数组np.zeros((3,3,2))np.ones(3)np.ones((3,3))np.ones((3,3,2)) 输出结果： 可以看到，如果我们只传入一个数字n，则会创建一个1xn的数组。 shapeshape()函数用于测量NumPy中数组、矩阵等的维度，返回一个表示维度的元组。 示例： 1234567import numpy as npnp.shape([[1, 2]])np.shape([0])np.shape(0)data = np.array([[[1,2,3],[1,2,3]], [[4,5,6],[7,8,9]]])np.shape(data) 输出： eyeeye()函数用于创建一个指定大小的单位数组(类似于线性代数中的单位矩阵)。 接受参数：一个表示维度大小的整数 示例： 12import numpy as npnp.eye(3) 输出： arangearange()函数类似于python中的range()，但它返回的是一个NumPy数组。 randomrandom.uniform matmat()函数用于创建矩阵。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程]]></title>
    <url>%2F2018%2F06%2F21%2Fpython3-tutorial-content%2F</url>
    <content type="text"><![CDATA[python3教程目录 第1章 入门 第2章 标准输入和输出 第3章 第4章 字符串 第5章 条件判断 第6章 循环 第7章 列表 第8章 元组 第9章 字典 第10章 函数(1) 第10章 函数(2) 第11章 类 第12章 文件 第13章 异常 第14章 json]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程-第14章 json]]></title>
    <url>%2F2018%2F06%2F20%2Fpython3-tutorial-chapter14-json%2F</url>
    <content type="text"><![CDATA[使用json函数，需要导入json库：import json 保存数据函数json.dump()可以将数据保存到json文件中，它接受两个实参：要存储的数据以及可用于存储数据的文件对象． json_dump.py 123456import jsonsettings = &#123;'username':'hegongshan','password':'2018!'&#125;filename = "settings.json"with open(filename,'w') as file: json.dump(settings,file) 执行该文件后，目录下多了一个settings.json，内容如下： 1&#123;"username": "hegongshan", "password": "2018!"&#125; 读取数据使用函数json.load()可以将json文件中的内容读取到内存中，它接受一个实参：一个文件对象． json_load.py 123456import jsonfilename = 'settings.json'with open(filename) as file: settings = json.load(file)print(settings) 输出结果：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程-第13章 异常]]></title>
    <url>%2F2018%2F06%2F19%2Fpython3-tutorial-chapter13-error%2F</url>
    <content type="text"><![CDATA[python使用被称为异常的特殊对象来管理程序执行期间发生的错误．每当发生让python不知所措的错误时，它都会创建一个异常对象． 如果你编写了处理该异常的代码，程序将继续运行；如果你未对异常进行处理，程序将停止，并显示一个traceback，其中包含有关异常的报告． 就像下面这样 1print(2/0) 输出结果： 这里报了一个ZeroDivisionError，如果不想让python报错，则可以使用异常处理． 异常是使用try-except代码块处理的． 语法如下： 123456try: 指定的操作except 需要处理的异常: 发生异常时需要执行的操作else: try中操作成功执行后，需要执行的操作 上述结构中，else 部分是可选的． 简单的异常处理示例： except.py 1234try: result = 2/0except ZeroDivisionError: print("can't divide by zero") 输出结果： 带else的异常处理下面我们来尝试读取一个不存在的文件． except.py 1234# 当前目录下不存在except.txtfilename = 'except.txt'with open(filename) as file: content = file.read() 输出结果： 这里报了一个FileNotFoundError，顾名思义，python找不到except.txt这个不存在的文件．下面我们用try-except-else来处理FileNotFoundError． except.py 12345678filename = 'except.txt'try: with open(filename) as file: content = file.read().rstrip()except FileNotFoundError: print("This directory can't found "+filename)else: print(content) 输出结果： 可以看到，这里没有执行print(content) 现在我们创建except.txt这个文件，内容如下： 12https://www.baidu.comhttps://www.aliyun.com 然后重新执行except.py，输出如下： 不处理异常如果发生异常时，我们不想处理它，也不想告诉用户程序出错了，就像什么都没有发生一样继续运行，可以使用pass语句． except.py 1234567891011121314def count_words(filename): try: with open(filename) as file: content = file.read() except FileNotFoundError: pass else: words = content.split() numOfWords = len(words) print("文件'"+filename+"'有"+numOfWords+"个词")filenames = ['except.txt','websites.txt','schools.txt']for filename in filenames: count_words(filename) except.txt 12ZeroDivisionErrorFileNotFoundError websites.txt 12https://www.baidu.comhttps://www.aliyun.com 这里我故意多写了一个不存在的schools.txt文件，看下会产生什么结果： 可以看到，虽然有一个不存在的schools.txt，但是程序在处理的时候，什么信息也没有．]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程-第12章 文件]]></title>
    <url>%2F2018%2F06%2F19%2Fpython3-tutorial-chapter12-file%2F</url>
    <content type="text"><![CDATA[前面我们已经学习了python的基础语法和一些数据结构，今天我们来学习下python中的文件操作． 从文件中读取数据读取整个文件基本语法： 12with open(filename) as file_object: 对文件的处理 open()函数用于打开文件，它接受一个参数：要打开的文件的名称，并返回一个表示文件的对象，将其存储在后面使用的变量file_object中，以便接下来对文件的各种操作. 关键字with在不再需要访问文件后会自动将其关闭． 示例 先创建一个test.txt文件，内容如下： 123To live is to change the world.Choice is very significant.I love you more than anything else in the world. 下面用python打开并读取这个文件，再将内容打印出来 在上述文件所在目录下，创建一个file.py文件，内容如下： 1234with open('test.txt') as file: # read()读取文件中的全部内容 contents = file.read() print(contents) 执行file.py，输出如下： 可以看到，输出多了一个空行．这是因为read()到达文件末尾时返回一个空字符串，而将空字符串显示出来就是一个空行．可以使用rstrip()删除多余的空白行 将file.py中的代码稍作修改 1234with open('test.txt') as file: # read()读取文件中的全部内容 contents = file.read() print(contents.rstrip()) 上面的方法read()从文件中读取全部内容，并将其存储在一个字符串中． 输出如下： 事实上，我们也可以不采用上述的语法格式 1234file = open('test.txt')contents = file.read()print(contents)file.close() 这里我们在使用完file后，手动调用了file对象的close()方法．虽然可以这样做，但我们并不推荐这种方式． 因为如果忘记调用close()方法，文件将不会自动关闭．或者如果过早地调用了close()方法，我们在使用文件时它已关闭，从而导致程序执行错误．因此，最好的方式就是使用关键字with，让python在合适的时候自动关闭文件. 逐行读取如果我们每次只想取一行，可对文件对象使用for 循环． 用下面的代码覆盖file.py中的代码 1234filename = 'test.txt'with open(filename) as file: for line in file: print(line) 输出结果： 每一行后面都多出了一个空行．这是因为文件中每行的末尾都有一个换行符，而print()语句也会加上一个换行符，因此每行末尾都有两个换行符：一个来自文件，一个来自print()语句.可以使用rstrip()去掉多余的换行． 创建一个包含文件各行内容的列表使用关键字with时，open()返回的文件对象只在with代码块中可用．如果要在with代码块外访问文件的内容，可在with代码块内将文件的各行存储在一个列表中，并在with代码块外使用该列表． 12345filename = 'test.txt'with open(filename) as file: lines = file.readlines()for line in lines: print(line.rstrip()) 上面的方法readlines()从文件中读取每一行，并将其存储在一个列表中． 写入文件open()函数在打开文件时可以设置打开模式. 1open(filename,mode) mode实参有以下几个可选的值： ‘w’：写入模式 ‘r’：读取模式 ‘a’：附加模式 ‘r+’：读取和写入模式 ‘ｗb’：二进制写入模式 ‘rb’：二进制读取模式 如果省略了模式实参，也就是之前我们采用的open(filename)这种方式，python将以默认的只读模式打开文件． 以’w’模式打开文件，如果要写入的文件不存在，open()将自动创建它．另外，如果指定的文件已经存在，python将在返回文件对象前清空该文件． 一个简单的例子 file_write.py 1234filename = 'websites.txt'with open(filename,'w') as file: file.write('https://www.baidu.com') file.write('https://www.aliyun.com') write()方法将其中的实参字符串写入到指定的文件中． 生成的websites.txt 1https://www.baidu.comhttps://www.aliyun.com 可以看到，写入的两行并没有自动换行，这是因为write()方法不会在写入的文本末尾自动添加换行符，如果需要换行，可以在末尾添加换行符． 改进版的例子 file_write.py 1234filename = 'websites.txt'with open(filename,'w') as file: file.write('https://www.baidu.com\n') file.write('https://www.aliyun.com\n') 生成的websites.txt 12https://www.baidu.comhttps://www.aliyun.com 附加到文件 如果要给文件添加内容，而不是覆盖原有的内容，可以使用附加模式打开文件．如果指定的文件不存在，python将创建一个空文件． 1234filename = 'websites.txt'with open(filename,'a') as file: file.write('https://www.chsi.com.cn\n') file.write('https://www.ccnu.edu.cn\n') 下面是附加模式生成的websites.txt 1234https://www.baidu.comhttps://www.aliyun.comhttps://www.chsi.com.cnhttps://www.ccnu.edu.cn 可以看到，前面写入的两个url还在，python并没有清空文件，重新写入，而是在文件的末尾附加了新增的两个url．]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程-第11章 类]]></title>
    <url>%2F2018%2F06%2F19%2Fpython3-tutorial-chapter11-class%2F</url>
    <content type="text"><![CDATA[创建和使用类语法： 123class 类名(): # 类中的所有方法都需要一个名为self的形参 类中的方法 示例： 12345678910class Book(): """书籍""" def __init__(self,name,price): """"初始化书名和价格""" self.name = name self.price = price def describe(self): """打印书的所有描述信息""" print("name:"+self.name+",price:"+str(self.price)) 上面的代码创建了一个Book类。类中的函数称为方法，前一节中关于函数的一切介绍都适用于方法。 第三行中的__init__()是一个特殊的方法（实例化方法，类似于Java中的构造器），开头和末尾各有两个下划线。每当我们根据Book类创建实例时，python都会自动运行它。 值得注意的是，__init__()中的形参self是必不可少的，且必须位于其他形参的前面，它代表的是某一次实例化所产生的实例。当我们通过实参向Book()传递名字和价格的时候，self会自动传递，不需要我们去传递它。 第五、六行中定义的两个变量都有前缀self。python中，以self为前缀的变量都可供类中的所有方法使用，也可以通过类的任意实例来访问这些变量。像这样可以通过实例访问的变量称为属性。 创建类的实例123# 使用上面定义的Book类创建实例 book = Book('Java8 in action',59.8)book.describe() 遇到第二行代码时，python使用实参’Java8 in action’和59.0调用Book类的__init__()，创建一个特定的书籍实例，并使用我们提供的值来设置name和price。方法__init__()并未显示地包含return语句，但python会自动返回一个书籍实例。 输出结果： 1name:Java8 in action,price:59.8 访问属性要访问实例的属性，可使用句点表示法( . )。 示例： 1print(book.name) 输出结果： 1Java8 in action 调用方法要调用类中的方法，也是用句点表示法( . )。 使用实例给属性指定默认值类中的每个属性都必须有初始值，哪怕这个值为0或者空字符串。在有些情况下，如设置默认值时，可以在方法__init__()内指定属性的初始值，从而无需包含为该属性提供初始值的形参。 示例： 12345678910111213141516class Book(): """书籍""" def __init__(self,name,price): """"初始化书名和价格""" self.name = name self.price = price self.publish_time = 2018 def describe(self): """打印书的所有描述信息""" print("name:"+self.name +",price:"+str(self.price) +",publish_time:"+str(self.publish_time)) book = Book('Java8 in action',59.8)book.describe() 输出结果： 1name:Java8 in action,price:59.8,publish_time:2018 修改属性的值 直接修改属性的值 通过类的实例直接修改属性的值。 示例： 123book = Book('Java8 in action',59.8)book.publish_time = 2020book.describe() 输出结果： 1name:Java8 in action,price:59.8,publish_time:2020 通过方法修改属性的值 通过类中定义的方法修改属性的值，从而隐藏实现细节。 示例： 12345678 # 在上面的Book类中新增一个update_price(self)方法 def update_price(self,price): """更改书的价格""" self.price = pricebook = Book('Java8 in action',59.8)book.update_price(66.6)book.describe() 输出结果： 1name:Java8 in action,price:66.6,publish_time:2018 继承编写类时，并非总是要从头开始。如果我们编写的类是另一个现成类的某种特殊情况，可以使用继承。一个类继承另一个类时，它将自动获得另一个类的所有属性和方法。原有的类称为父类，新的类称为子类。子类在继承父类所有属性和方法的同时，还可以定义自己特有的属性和方法。 基本语法： 123# 在定义子类时，必须在括号中指定父类的名称。class 类名(父类名): 类中的方法 子类的__init__()子类在实例化的时候，首先需要为父类的所有属性赋值。下面定义了一个Book类的子类CultureBook。 1234567class CultureBook(Book): def __init__(self,name,price): # 调用父类Book的__init__()方法 super().__init__(name,price) book2 = CultureBook('红楼梦',45.5)book2.describe() 创建子类时，父类必须包含在当前文件中，且位于子类的前面。 上面第三行中的函数super()，将父类Book和子类CultureBook关联起来，这行代码让python调用父类Book中的__init__()，从而使CultureBook的实例包含了父类的所有属性。 输出结果： 1name:红楼梦,price:45.5,publish_time:2018 定义子类独有的属性和方法1234567891011121314class CultureBook(Book): """文学书""" def __init__(self,name,price,author): super().__init__(name,price) self.author = author def get_book_info(self): """描述文学书的相关信息""" print("&#123;'name':'" + self.name + "','price':" + str(self.price) + ",'author':'"+self.author+"'&#125;") book2 = CultureBook('红楼梦',45.5,'曹雪芹')book2.get_book_info() 输出结果： 1&#123;'name':'红楼梦','price':45.5,'author':'曹雪芹'&#125; 需要注意的是，第四行中的super().__init__()并不一定要写在子类__init__()方法的第一行。事实上，第四、五行的顺序完全可以颠倒过来（这在Java中是不可以的）。 重写父类的方法如果父类的某个（些）方法不适合子类，完全可以在子类中重写父类的方法，只需要在子类中定义一个与父类方法同名的方法即可。这样，python将不会考虑这个父类方法，而只关注子类中定义的同名方法。 示例： 12345678910111213# 父类Book没有author属性，在CultureBook中重写父类的describe()方法class CultureBook(Book): # 省略之前的代码 def describe(self): print("name:"+self.name+ ",price:"+str(self.price)+ ",publish_time:"+str(self.publish_time)+ ",author:"+self.author)book2 = CultureBook('红楼梦',45.5,'曹雪芹')book2.describe() 输出结果： 1name:红楼梦,price:45.5,publish_time:2018,author:曹雪芹 可以看到，调用describe()后，确实将父类Book中没有的author属性也打印出来了。 导入类为了使程序尽可能整洁，我们可以将类存储在模块中，然后在需要使用的程序中导入该模块。这部分的内容与前面将的从模块中导入函数基本一致。 导入单（多）个类语法： 1from 模块名 import 类名,类名,... 将Book类存储在一个名为book.py的模块中 book.py 1234567891011121314151617181920212223242526272829303132333435class Book(): """书籍""" def __init__(self,name,price): """"初始化书名和价格""" self.name = name self.price = price self.publish_time = 2018 def describe(self): """打印书的所有描述信息""" print("name:"+self.name+ ",price:"+str(self.price)+ ",publish_time:"+str(self.publish_time)) def update_price(self,price): """更改书的价格""" self.price = priceclass CultureBook(Book): """文学书""" def __init__(self,name,price,author): self.author = author super().__init__(name,price) def get_book_info(self): """描述文学书的相关信息""" print("&#123;'name':'" + self.name + "','price':" + str(self.price) + ",'author':'"+self.author+"'&#125;") def describe(self): print("name:"+self.name+ ",price:"+str(self.price)+ ",publish_time:"+str(self.publish_time)+ ",author:"+self.author) 创建一个新的文件my_book.py，在其中导入Book类并创建实例 123456789from book import Book,CultureBookbook = Book('Java8 in action',59.8)book.update_price(66.6)book.describe()print(book.name)book2 = CultureBook('红楼梦',45.5,'曹雪芹')book2.describe() 输出结果： 123name:Java8 in action,price:66.6,publish_time:2018Java8 in actionname:红楼梦,price:45.5,publish_time:2018,author:曹雪芹 导入整个模块示例： my_books.py 123456789import bookbook = book.Book('Java8 in action',59.8)book.update_price(66.6)book.describe()print(book.name)book2 = book.CultureBook('红楼梦',45.5,'曹雪芹')book2.describe() 输出与之前一般无二。 导入模块中的所有类语法： 1from 模块名 import * 像之前讲的从模块中导入函数一样，不推荐使用该方式，理由类似。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程-第10章 函数(2)]]></title>
    <url>%2F2018%2F06%2F17%2Fpython3-tutorial-chapter10-function-2%2F</url>
    <content type="text"><![CDATA[上一小节中，我们学习了基础的函数使用，本节我们将学习更加高级的函数运用，以及函数编写的规范。 传递任意数量的参数有时候，我们预先不知道函数需要接受多少个参数，好在python允许函数从调用语句中获取任意数量的实参。 示例： 123456def test_any_arguments(*args): """测试任意数量的参数""" print(args)test_any_arguments("school of information management")test_any_arguments("hegongshan","https://www.hegongshan.com", "central china normal university") 输出结果： 12('school of information management',)('hegongshan', 'https://www.hegongshan.com', 'central china normal university') 在上面代码的第一行中，形参名*args中的星号，表示让python创建一个名为args的空元组，并将收到的所有值都封装到这个元组中。 结合使用位置实参和任意数量的实参如果函数要接收不同类型的参数，必须在函数定义中将接纳任意数量实参的形参放在最后。python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。 示例： 1234def test_any_arguments(tip,*args): print(tip+":") print(args)test_any_arguments("hello","import this","the zen of python") 输出结果： 12hello:('import this', 'the zen of python') 使用任意数量的关键字实参示例： 1234567891011def get_user_info(name,**user_info): """创建一个字典包含用户的所有信息""" profile = &#123;&#125; profile['name'] = name for key,value in user_info.items(): profile[key] = value return profileuser_info = get_user_info('hegongshan',email='hegongshan@qq.com', website="https://www.hegongshan.com", occupation="freelance/student")print(user_info) 输出结果： 1&#123;'name': 'hegongshan', 'email': 'hegongshan@qq.com', 'website': 'https://www.hegongshan.com', 'occupation': 'freelance/student'&#125; 上面代码第一行中，函数形参名**user_info，前面的两个星号表示让python创建一个名为user_info的空字典，并将收到的所有键-值对都封装到这个字典中。 将函数存储在模块中通过将函数存储在称为模块的独立文件中，可隐藏程序代码的实现细节，将重点放在程序的高层逻辑上。模块是扩展名为.py的文件。import语句允许在当前运行的程序文件中使用模块中的代码。 导入整个模块我们先创建一个包含函数get_user_info()的模块user.py 1234567def get_user_info(name,**user_info): """创建一个字典包含用户的所有信息""" profile = &#123;&#125; profile['name'] = name for key,value in user_info.items(): profile[key] = value return profile 接下来，在user.py所在目录中创建一个main.py的文件，用于调用get_user_info()函数。 main.py 123456import useruser_info = user.get_user_info('hegongshan',email='hegongshan@qq.com', website="https://www.hegongshan.com", occupation="freelance/student")print(user_info) 第一行中的import user让python打开文件user.py，并将其中的所有函数都复制到这个程序中。要调用被导入模块中的函数，需要制定模块名user和函数名get_user_info()，并用”.”（成员运算符）分隔它们。 上述代码的输出结果与之前一般无二 1&#123;'name': 'hegongshan', 'email': 'hegongshan@qq.com', 'website': 'https://www.hegongshan.com', 'occupation': 'freelance/student'&#125; 导入特定的函数如果我们不需要导入模块中的所有函数，只想导入某几个函数，也是可以的。 语法如下： 1from 模块名 import 函数名1,函数名2,... 现在我们可以改写上面main.py中的代码 123456from user import get_user_infouser_info = get_user_info('hegongshan',email='hegongshan@qq.com', website="https://www.hegongshan.com", occupation="freelance/student")print(user_info) 若使用这种语法，调用导入的函数时，不能加模块名和 ”.“。 使用这种方式后，如果我们还像之前那样，用 模块名 . 函数名来调用函数，则会报如下错误： 1234Traceback (most recent call last): File "main.py", line 3, in &lt;module&gt; user_info = user.get_user_info('hegongshan',email='hegongshan@qq.com',NameError: name 'user' is not defined 使用as给函数指定别名如果要导入的函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名（类似于人的外号）。 语法如下： 1from 模块名 import 函数名 as 函数的别名 修改main.py 123456from user import get_user_info as infouser_info = info('hegongshan',email='hegongshan@qq.com', website="https://www.hegongshan.com", occupation="freelance/student")print(user_info) 值得注意的是，指定了别名后，就不能再使用本来的函数名了。 使用as给模块指定别名我们还可以使用as给模块指定一个简短的别名。 语法如下： 1import 模块名 as 模块的别名 例如，修改main.py，为导入的模块user指定别名u 123456import user as uuser_info = u.get_user_info('hegongshan',email='hegongshan@qq.com', website="https://www.hegongshan.com", occupation="freelance/student")print(user_info) 导入模块中的所有函数使用星号（*）可以导入模块中的所有函数 语法如下： 1from 模块名 import * 示例： 123456from user import *user_info = get_user_info('hegongshan',email='hegongshan@qq.com', website="https://www.hegongshan.com", occupation="freelance/student")print(user_info) 不推荐使用这种用法。为了提高代码的可读性，要么导入我们需要使用的某个（些）函数，要么导入整个模块并使用句号（ . ）表示法。 函数编写规范 函数命名应该有意义，且只包含小写字母和下划线 每个函数都应包含简要地阐述其功能的注释，该注释应紧跟在函数定义后面，并采用文档字符串格式 给形参指定默认值，或者在函数调用中的关键字实参，等号两边不要有空格 一行的长度不要超过79个字符 如果程序或模块中包含多个函数，使用两个空行将相邻的函数分开 所有的import语句都应该放在文件开头，唯一例外的情形是，在文件开头使用了注释来描述整个程序。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程-第10章 函数(1)]]></title>
    <url>%2F2018%2F06%2F17%2Fpython3-tutorial-chapter10-function-1%2F</url>
    <content type="text"><![CDATA[从本章开始，我们将不再面对黑底白字的命令行，转而使用更加方便的编辑器编写python代码。你可以选择自己最喜欢的文本编辑器，如Notepad++、Sublime Text等，也可以使用eclipse、PyCharm等IDE。我使用的是eclipse+pydev。 函数是带名字的代码块，用于完成具体的工作。 定义函数 基本语法： 12def 函数名(参数1,参数2,...): 函数体 上面的括号中可以没有参数，也可以有任意个参数，但即使没有参数，括号也必不可少。 示例1.不带参数的函数 123def say_hello(): print("hello")say_hello() 输出结果： 1hello 示例2.带参数的函数 1234def say_hello_to(username): """显示问候""" print("hello "+username.title())say_hello_to('hegongshan') 输出结果： 1hello Hegongshan 上面第2行处的文本”””显示问候”””被称为文档字符串，用于描述函数的作用。文档字符串用三个引号括起来（单引号双引号都可以，但不能混用），python使用它们来生成有关程序中函数的文档。简单来说就是文档注释。 实参和形参 上面示例2，在say_hello_to()的定义中，变量username是一个形参（函数完成其工作所需要的一项信息）。 在代码say_hello_to(‘hegongshan’)中，值‘hegongshan’是一个实参（调用函数时传递给函数的信息）。 在say_hello_to(‘hegongshan’)中，将实参‘hegongshan’传递给了函数say_hello_to()，这个值被存储在形参username中。 传递实参python中传递实参，主要有以下三种方式: 位置实参在调用函数时，基于实参的顺序，将函数调用中的每个实参都关联到函数定义中的一个形参，这种关联方式称为位置实参（positional arguments）。 示例： 123456789def greater_than(i,j): '''判断第一个参数i是否大于第二个参数j''' if i&gt;j: print(str(i)+"大于"+str(j)) elif i==j: print(str(i)+"等于"+str(j)) else: print(str(i)+"小于"+str(j))greater_than(18,10) 输出结果： 118大于10 位置实参这种方式，需要确保函数调用时实参的顺序与函数定义中形参的顺序一致，否则，结果可能出乎意料。 例如下面这个例子 123def describe_user(first,last): print("用户\n姓："+first+",名："+last)describe_user("贺", "巩山") 输出结果： 12用户姓：贺,名：巩山 如果我在调用函数的时候，将两个参数的顺序弄错了 1describe_user("巩山", "贺") 输出结果： 12用户姓：巩山,名：贺 结果就是牛头不对马嘴。 关键字实参关键字实参是将键-值对传递给函数。通过这种方式，我们无需考虑函数调用中的实参顺序，清楚地指出了函数调用中各个值的用途。 示例： 123def describe_user(first,last): print("用户\n姓："+first+",名："+last)describe_user(last="巩山",first="贺") 输出结果： 12用户姓：贺,名：巩山 可以看到我并没有按照形参顺序传递实参，输出结果也是正确的。 默认值编写函数时，可给每个形参指定默认值。如果在调用函数时给形参提供了实参，python将使用指定的实参值；否则，将使用形参的默认值。因此，在形参指定默认值后，可在函数调用中省略相应的实参。 示例： 1234def describe_user(first,last,motto='没有伞的孩子更要努力奔跑'): print("用户\n姓："+first+"，名："+last+"，座右铭："+motto)describe_user(first="贺",last='巩山') describe_user(first="he",last='gongshan',motto='To live is to change the world') 输出结果： 1234用户姓：贺，名：巩山，座右铭：没有伞的孩子更要努力奔跑用户姓：he，名：gongshan，座右铭：To live is to change the world 使用默认值时，在形参列表中必须先列出没有默认值的形参，再列出有默认值的形参。 这是因为使用了默认值后，函数调用传参时，python依然会将传入的参数视为位置实参。 返回值大多数情况下，函数并非直接显示输出，相反，它可以处理一些数据，并返回一个或一组值。在函数中，可以使用return语句将值返回。另外，函数可返回任何类型的值，包括列表和字典等较复杂的数据结构。 返回简单值示例： 1234def multiply(i,j): return i*jresult = multiply(20, 55.5)print(result) 输出结果： 11110.0 返回字典123456def to_user(first,last,email,motto): """返回一个包含个人信息的字典""" user = &#123;'first':first,'last':last,'email':email,'motto':motto&#125; return useruser = to_user("he", "gongshan", "hegongshan@qq.com", "To live is to change the world.")print(user) 输出结果： 1&#123;'first': 'he', 'last': 'gongshan', 'email': 'hegongshan@qq.com', 'motto': 'To live is to change the world.'&#125;]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程-第9章 字典]]></title>
    <url>%2F2018%2F06%2F16%2Fpython3-tutorial-chapter9-dictionary%2F</url>
    <content type="text"><![CDATA[在python中，字典是一系列键-值对。每个键都与一个值相关联，该值可以是数字、字符串、列表乃至字典。 字典用放在花括号{ }中的一系列键-值对表示。键和值之间用冒号分隔开，而键-值对之间用逗号分隔开。 示例如下 1user=&#123;'name':'hegongshan','age':23,'gender','M'&#125; 访问字典中的值语法如下： 1字典名[键名] 示例： 123# 获取user中与‘name’相关联的值user=&#123;'name':'hegongshan','age':23,'gender':'M'&#125;print(user['name']) 输出结果： 添加/修改键-值对语法如下： 1字典名[键名] = 值 示例： 1234567user=&#123;'name':'hegongshan','age':23,'gender':'M'&#125;# 在user中添加'degree':'bachelor'user['degree']='bachelor'print(user)# 修改user中'gender'的值为‘F’user['gender']='F'print(user) 输出结果： 需要注意的是，字典在初始化的时候，键名是可以重复的。 示例： 1234# 相当于user=&#123;'name':'hegongshan','age':23&#125;# user['name']='M'user=&#123;'name':'hegongshan','age':23,'name':'M'&#125;print(user) 以上代码中的user={‘name’:’hegongshan’,’age’:23,’name’:’M’}，隐式地修改了‘name’的值，其等价于以下两条语句 12user=&#123;'name':'hegongshan','age':23&#125;user['name']='M' 推荐在初始化时，不要出现重复的键名，这样做可以提高代码的可读性。 删除键-值对在字典中删除键-值对，类似于在列表中删除元素，使用del语句将相应的键-值对彻底删除。 示例： 123user=&#123;'name':'hegongshan','age':23,'gender':'M'&#125;del user['age']print(user) 输出结果： 遍历字典遍历所有的键-值对使用字典的items()方法，可以返回一个包含字典中所有键-值对的列表 示例： 123user=&#123;'name':'hegongshan','age':23,'gender':'M'&#125;for key,value in user.items(): print(key.title()+":"+value.title()) 输出结果： 可以看到，for循环在执行第二遍时报错了，python解释器告诉我们：int对象没有title属性，这是因为在执行第二次时，age的值23是整型，不是字符串，没有title()，那怎么办呢？ 如果在for循环里面不用字符串的title()方法，还会报错吗？ 我们来尝试下: 可以看到，程序还是报错了，python解释器告诉我们：value必须是字符串，不能是整型，这是因为 key.title() + “:”是字符串，而字符串只能和字符串拼接。 我们可以使用python中的str()函数，将age的值23转换为字符串，然后就可以正常输出了。如果学过Java的话，可以发现str()函数和Java中的toString()很像。 改进后的示例： 123user=&#123;'name':'hegongshan','age':23,'gender':'M'&#125;for key,value in user.items(): print(key.title()+":"+str(value).title()) 输出结果： 如果我们在for循环中只定义了一个变量， 123user=&#123;'name':'hegongshan','age':23,'gender':'M'&#125;for key_value in user.items(): print(key_value) 那么会输出如下结果： 遍历字典中的所有键 简单遍历 某些时候，我们不需要使用字典中的值，只想获取所有的键，这时候可以使用字典的keys()方法。 示例： 123user=&#123;'name':'hegongshan','age':23,'gender':'M'&#125;for key in user.keys(): print(key.title()) 输出结果： 事实上，遍历字典时，会默认遍历所有的键，因此，上述代码中for key in user.keys():替换为 for key in user:，输出结果将不变。 推荐显式地使用keys()方法，使代码更容易理解。 按顺序遍历 在for循环中使用sorted()函数，对返回的键进行排序。 示例： 123user=&#123;'name':'hegongshan','age':23,'gender':'M'&#125;for key in sorted(user.keys()): print(key.title()) 输出结果： 可以看到，输出的键名确实按照字母顺序排序了。 遍历字典中的所有值如果我们只想要字典中的所有值，可以使用字典的values()方法，它将返回一个值列表。 示例： 123user=&#123;'name':'hegongshan','age':23,'gender':'M'&#125;for value in user.values(): print(value) 输出结果： 如果值列表中包含大量重复的值，为剔除重复项，可以使用集合set，集合类似于列表，但每个元素都必须是独一无二的。 示例： 123user=&#123;'name':'hegongshan','age':23,'gender':'M','full_name':"hegongshan"&#125;for value in set(user.values()): print(value) 输出结果： 可以看到重复的’hegongshan’，只输出了一次。 嵌套在列表中嵌套字典示例： 12345users=[&#123;'name':'hegongshan','age':23,'gender':'M'&#125;, &#123;'name':'hgs','age':24,'gender':'F'&#125;, &#123;'name':'gongshanhe','age':25,'gender':'M'&#125;]for user in users: print(user) 输出结果： 在字典中嵌套列表示例： 123user=&#123;'name':'hegongshan','age':23,'gender':'M','address':['hubei','wuhan']&#125;for key,value in user.items(): print(key.title()+":"+str(value)) 输出结果： 在字典中嵌套字典示例： 12345678910user=&#123;'name':&#123;'first':'he','last':'gongshan'&#125;, 'age':23, 'gender':'M', 'address':&#123; 'province':'hubei', 'city':'wuhan' &#125; &#125;for key,value in user.items(): print(key.capitalize()+":"+str(value)) 输出：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java位运算符]]></title>
    <url>%2F2018%2F06%2F16%2Fjava-bitwise-operation%2F</url>
    <content type="text"><![CDATA[在讲位运算符之前，我们先来回顾下本科时学过的一些计算机基础知识。 所谓原码就是二进制定点表示法，即最高位为符号位，正数为0，负数为1，其余位表示数值的大小。 反码：正数的反码与其原码相同，负数的反码是其原码逐位求反（符号位除外）。 补码：正数的补码与其原码相同，负数的补码为其反码加1。 整数在内存中是以补码的形式存储的。 一个简单的例子： 5的原码、补码、反码为$$原码：0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0101 \\反码：0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0101 \\补码：0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0101$$-4的原码、补码、反码为：$$原码：1000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0100 \\反码：1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1011 \\补码：1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1100$$ 反过来，已知补码如何求原码呢？ 已知补码如下，求其十进制表示？$$1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1000$$先通过补码求得反码，即补码减去1$$\ 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1000 \\\underline{- 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0001} \\= 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 0111$$除最高位（符号位）外，其他位按位求反，就得到了原码$$(1000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 1000)_2 = -8$$有了上面这些知识，位运算就很容易理解了。 按位与&amp;按位与运算的运算符是“&amp;”，是双目运算符。如果两个操作数对应位都是1，则结果位为1，否则为0。 示例：5 &amp; -4 = 4$$5的补码\\\overbrace {0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0101} \\\&amp; \\\underbrace{1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1100 } \\-4的补码 \\\Downarrow \\\underbrace{0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0100} \\5\&amp;-4的结果为十进制整数4$$ 按位或|按位与运算的运算符是“|”，是双目运算符。如果两个操作数对应位都是0，则结果才是0，否则为1。 示例：3 | 6 = 7$$3的补码 \\\overbrace {0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0011} \\| \\\underbrace{0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0110} \\6的补码 \\\Downarrow \\\underbrace{0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0111} \\3 | 6的结果为十进制整数7$$ 按位非~按位非运算，也称“按位取反”运算，运算符为“~”，是单目运算符。 运算法则：将操作数二进制中的1全部修改为0，0全部改为1 示例：~7 = -8$$7的补码\\\overbrace {0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0111} \\\Downarrow \\\underbrace{1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1000} \\\sim7的结果为十进制整数-8$$ 按位异或^按位异或运算的运算符是“^”，是双目运算符。 运算法则：当两个操作数的二进制表示相同（同为0或同为1）时，结果为0，否则为1。 示例：7^3 = 4$$7的补码 \\\overbrace{0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0111} \\ \wedge \\\underbrace{0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0011} \\3的补码 \\\Downarrow \\\underbrace{0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0100} \\7^{\wedge} 3的结果为十进制整数4$$ 移位运算符Java语言中的移位运算符有3种，其操作的数据类型只有byte、short、char、int和long5种类型。 左移运算符&lt;&lt;。左移空出的位置补0。 如12&lt;&lt;1 = 24： $$\quad \quad \quad \underline{0 \quad 0 \quad 0 \quad 0 \quad 1 \quad 1 \quad 0 \quad 0 }\\\quad 抛弃 \rightarrow 0 \quad \underline{0 \quad 0\quad 0\quad 1 \quad 1\quad 0\quad 0} \quad 0 \leftarrow 补零 \\结果为 2^{4}+2^{3} = 24$$ 右移运算符&gt;&gt;。如果最高位为0，则右移空出的位置补0；如果最高位为1，空出的位置补1。 如12&gt;&gt;1 = 6： $$\underline{0 \quad 0\quad 0\quad 0\quad 1\quad 1\quad 0 \quad 0 }\\\quad 补零\rightarrow 0 \quad \underline{0 \quad 0 \quad 0\quad 0\quad 1 \quad 1\quad 0} \quad 0 \leftarrow 抛弃\\结果为 2^{2}+2^{1} = 6$$ 无符号右移运算符&gt;&gt;&gt;。不管最高位是0还是1，右移空出的位置都补0。 简单来说，一个数左移n位，相当于这个数乘以2的n次方；右移n位，相当于除以2的n次方。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程-第8章 元组]]></title>
    <url>%2F2018%2F06%2F15%2Fpython3-tutorial-chapter8-tuple%2F</url>
    <content type="text"><![CDATA[列表非常适合用于存储在程序运行期间可能变化的数据集。列表是可以修改的。如果需要创建一系列不可修改的元素，可以使用python中的元组。简单来说，元组就是数据元素不可变的列表。 定义元组用圆括号定义元组。语法如下： 1(元素１,元素２,...) 访问元组中元素的方法，与访问列表中的元素类似。 示例： 123positions = (5,20)print(positions[0])print(positions[1]) 输出结果： 下面我们尝试修改下元组positions中的元素 12positions = (5,20)positions[1] = 21 输出结果： python解释器告诉我们，元组（tuple）不支持元素赋值。 修改元组变量虽然不能修改元组中的元素，但可以给存储元组的变量赋值。 1234positions = (5,20)print(positions)positions = (23,33)print(positions) 输出结果：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程-第7章 列表]]></title>
    <url>%2F2018%2F06%2F14%2Fpython3-tutorial-chapter7-list%2F</url>
    <content type="text"><![CDATA[列表由一系列按特定顺序排列的元素组成。 在python中，用方括号 []来表示列表，并用逗号来分隔其中的元素。 下面定义了一个关于学校的列表 12schools = ['ccnu','whu','hust','thu']print(schools) 输出结果： 可以看到python将方括号也打印出来了，但这肯定不是我们想要的结果，下面来看下如何访问列表中的元素 访问列表中的元素列表是有序集合，要访问列表中的任意元素，只需将该元素的索引告诉python即可。 下面我们打印下上面的列表schools中的第二个元素 12schools = ['ccnu','whu','hust','thu']print(schools[1]) 输出结果： 可以看到，python只返回了元素值，并没有打印方括号 需要注意的是，元素的索引号是从0开始的，而不是1。如果学习过其他编程语言的话，应该很容易理解。 另外，python为访问列表中的元素提供了一种特殊的语法：通过将索引号指定为负数，可以返回列表中倒数第几个元素。 下面指定索引号为-1，打印列表中的最后一个元素‘thu’ 12schools = ['ccnu','whu','hust','thu']print(schools[-1]) 输出结果： 可以看到，python确实打印了最后一个元素thu。如果指定索引号为-2，则打印倒数第二个元素，其他负数索引以此类推。 大部分情况下，我们是不知道列表的长度的，因此，这种语法可以使我们很方便的访问列表中的最后一个元素。 修改列表元素修改列表元素的语法与访问列表元素的语法类似。指定列表名和要修改的元素索引，通过“=”赋新值即可。 下面修改schools中的第三个元素 ’hust‘（索引为2）的值为 ‘pku‘ 123schools = ['ccnu','whu','hust','thu']schools[2] = 'pku'print(schools) 输出结果： 可以看到第三个元素的值确实改变了。通过这种方式，我们可以改变任何列表元素的值。 在列表中添加元素在列表中添加元素，可分为以下两种情况： 在列表末尾添加元素使用列表的append()方法，可以将新元素添加到列表末尾。 下面在schools末尾添加一个元素 ‘mit’ 123schools = ['ccnu','whu','hust','thu']schools.append('mit')print(schools) 输出结果： 事实上，下面的方式可能更常用：先创建一个空的列表，然后使用append()方法，动态添加元素。 我们也来尝试下： 123456# 创建空的列表schools = []schools.append('ccnu')schools.append('whu')schools.append('thu')print(schools) 输出结果： 在列表中插入元素使用列表的insert()方法，通过指定新元素的索引和值，我们可以在列表的任意位置添加新的元素。 12345# insert()方法的第一个参数为索引，第二个参数为新元素的值schools = ['ccnu','whu','hust','thu']schools.insert(0,'zju')schools.insert(4,'mit')print(schools) 第三行的schools.insert(0,’zju’) 表示将 ‘zju’ 插入到列表头部，插入后，列表为 1schools = ['zju','ccnu','whu','hust','thu'] 然后在执行第四行的 schools.insert(4,’mit’)，插入后，列表为 1schools = ['zju','ccnu','whu','hust','mit','thu'] 输出结果： 从列表中删除元素从列表中删除元素，可分为以下两种情况。 使用del语句删除元素如果知道要删除的元素在列表中的位置（索引），可以使用del语句。 下面用del语句删除schools中的第三个元素 ‘hust’ 123schools = ['ccnu','whu','hust','thu']del schools[2]print(schools) 输出结果： 可以看到第三个元素 ‘hust’ 确实被删除了 使用pop()删除元素 pop()方法可以删除列表末尾的元素，并返回该元素的值。 下面用pop()方法删除schools中的最后一个元素 ‘thu’ 1234schools = ['ccnu','whu','hust','thu']school = schools.pop()print(schools)print(school) 输出结果： 可以看到pop()方法确实删除了schools中的最后一个元素 ‘hut’，并把该元素的值存储到了变量school中 事实上，pop()方法也可以用来删除列表中任何位置的元素，只需在括号中指定要删除的元素的索引即可。 下面使用pop()方法删除schools的第二个元素 ‘whu’ 1234schools = ['ccnu','whu','hust','thu']school = schools.pop(1)print(schools)print(school) 输出结果： 根据值删除元素如果我们不知道要删除的元素在列表中的位置（索引），但是知道要删除元素的值，我们可以使用remove()。 下面使用remove()方法删除schools中值等于 ’whu‘ 的元素 1234# 为了演示remove方法，我在schools中添加了多个值为whu的元素schools = ['ccnu','whu','hust','whu','thu','whu']schools.remove('whu')print(schools) 输出结果： 可以看到，只有第一个值为 ‘whu’ 的元素被删除了，其他值为 ‘whu’ 的元素并没有被删除。 remove()方法只删除列表中满足条件的第一个元素。如果要删除的值在列表中出现多次，需要使用循环。 这里简单实现下，关于循环的具体内容，在后面的章节中会详细讲述 12345schools = ['ccnu','whu','hust','whu','thu','whu']while schools.count('whu') &gt; 0: schools.remove('whu')print(schools) 输出结果： 对列表中的元素进行排序使用sort()方法对列表进行永久性排序首先，我们假定列表中全为字符串 对字符串列表进行排序 123schools = ['ccnu','whu','hust','thu']schools.sort()print(schools) 输出结果： 可以看到sort()方法永久性地修改了列表中元素的排列顺序。 123schools = ['CCnu','whu','hust','Thu']schools.sort()print(schools) 输出结果： 123schools = [1,2,3,'CCnu','whu','hust','Thu']schools.sort()print(schools) 反序排序 123schools = ['ccnu','whu','hust','thu']schools.sort(reverse=True)print(schools) 输出结果： 使用函数sorted()对列表进行临时排序有时候我们只想以特定的顺序展示列表元素，但不想真的改变列表元素原来的排列顺序，这时候我们可以使用函数sorted()对列表进行临时排序。 1234schools = ['ccnu','whu','hust','thu']newSchools = sorted(schools)print(newSchools)print(schools) 输出结果： 可以看到执行完sorted(schools)后，schools中元素的排列顺序并没有被改变。 当然，如果想要按与字母顺序相反的顺序显示列表，也可以向sorted()传递参数reverse=True 反转列表使用reverse()方法，可以反转列表元素的排列顺序。 123schools = ['ccnu','whu','hust','thu']schools.reverse()print(schools) 输出结果： reverse()永久性地修改了列表元素的排列顺序，但我们可以随时恢复到原来的排列顺序，只需要再次调用reverse()即可。 确定列表的长度使用函数len()可以取得列表的长度。 123# len()函数返回一个整数schools = ['ccnu','whu','hust','thu']len(schools) 输出结果： 当然，我们也可以这样 123schools = ['ccnu','whu','hust','thu']length = len(schools)print(length) 输出结果： count() index() clear() copy() extend()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程-第6章 循环]]></title>
    <url>%2F2018%2F06%2F13%2Fpython3-tutorial-chapter6-loop%2F</url>
    <content type="text"><![CDATA[for循环语法如下： 12for 变量名 in 集合(字符串|列表|元组|字典): 循环体 示例： 123str = "I love you!"for c in str: print(c) 输出结果： while循环语法如下： 12while 条件表达式: 循环体 示例如下： 1234current_number = 1while current_number &lt; 5: print(current_number) current_number += 1 输出结果： 使用标志结束循环在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量称为标志，充当程序的交通信号灯，决定循环是否继续进行，还是结束。 示例： 1234567active = Truewhile active: message = input("\n请输入一个字符串，\n如果输入exit则退出循环：") if message == 'exit': active = False else: print(message) 输出结果： 使用break结束循环使用break语句，可以直接退出循环，不再继续执行循环中余下的代码 示例： 1234567# 循环输入一串字符串，如果输入的是exit，则退出循环while True: message = input("\n请输入一个字符串，\n如果输入exit则退出循环：") if message == 'exit': break else: print(message) 输出结果： 在循环中使用continue使用continue语句，继续执行下一次循环，不再执行当前循环中余下的代码。 示例： 1234567# 打印１-10中的所有奇数current_number = 0while current_number &lt; 10: current_number += 1 if current_number % 2 == 0: continue print(current_number) 输出结果：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程-第5章 条件判断]]></title>
    <url>%2F2018%2F06%2F13%2Fpython3-tutorial-chapter5-if-else%2F</url>
    <content type="text"><![CDATA[简单的if语句语法如下： 12if 判断条件: 执行语句 示例： 123message = 'python'if message.islower(): print(message.upper()) # print在if的基础上缩进了四个空格 注意第二行末尾的冒号，不要忘记了哦。 另外，需要注意的是，大多数编程语言使用{ }将条件判断中的执行语句包裹起来，而python并不如此，它以缩进作为条件判断中执行语句的标志。条件判后的执行语句在条件判断的基础上缩进四个空格。比如上面的例子，print()函数在if的基础上缩进了四个空格。后面要讲的循环也是一样，执行语句需要缩进四个空格。 if-else语句在大多数情况下，我们经常需要在条件判断通过时执行一个操作，在没有通过时执行另一个操作。这时候就需要使用到if-else语句。语法如下： 1234if 判断条件: 执行语句else: 执行语句 示例： 12345message = 'python'if message.islower(): print(message.upper())else: print(message.lower()) if-elif-else结构如果需要处理的条件判断不止两种，则可以使用if-elif-else结构。语法如下： 123456789if 判断条件: 执行语句elif 判断条件: 执行语句elif 判断条件: 执行语句...else: 执行语句 示例： 123456789101112age = 20if age &lt; 18: print('未成年') elif age &gt;= 18 &amp; age &lt;= 30: print('青年人') elif age &gt; 30 &amp; age &lt; 60: print('中年人') else: print('老年人') 需要注意的是，if-elif-else结构中，else并不是必须的。例如，下面的代码也是正确的 123456789age = 20if age &lt; 18: print('未成年') elif age &gt;= 18 and age &lt;= 30: print('青年人') elif age &gt; 30 and age &lt; 60: print('中年人')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程-第4章 字符串]]></title>
    <url>%2F2018%2F06%2F12%2Fpython3-tutorial-chapter4-string%2F</url>
    <content type="text"><![CDATA[字符串是一系列字符。在python中，用引号括起来的都是字符串，这里的引号可以是单引号，也可以是双引号。 修改字符串的大小写涉及的字符串方法有upper()、isupper()、lower()、islower() 示例： 1234567891011name = "hegongshan"# 判断是否为大写字符串print(name.isupper())# 将字符串中的字母均转为大写print(name.upper())name2 = "heGONGshan"# 判断字符串是否为小写print(name2.islower())# 将字符串中的字母均转为小写print(name2.lower()) 输出结果： 拼接字符串和大多数高级编程语言一样，python使用加号（+）来拼接字符串。 示例： 123message = "I " + "love "message = message + "you."print(message) 输出结果： 首字母大写涉及的方法有title()、capitalize() 示例： 1234567891011name = "he gong shan"print(name.title())print(name.capitalize())name2 = "123 hegongshan"print(name2.title())print(name2.capitalize())message = "123hgs520"print(message.title())print(message.capitalize()) 输出结果： 从上面的结果，我们可以很容易地看出title()和capitalize()的区别： title()方法会将字符串中所有单词的首字母都转为大写，而capitalize()方法只会将字符串的首字母转为大写 去掉字符串中的空白字符涉及的方法有strip()、rstrip()和lstrip() strip()：去掉字符串左右的空白字符 lstrip()：去掉字符串左边的空白字符 rstrip()：去掉字符串右边的空白字符 示例： 123456message = " I love you ! "print(message.lstrip())print(message.rstrip() + "hhh")print(message.strip() + "233") 输出结果：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程-第2章 标准输入和输出]]></title>
    <url>%2F2018%2F06%2F12%2Fpython3-tutorial-chapter2-input-and-print%2F</url>
    <content type="text"><![CDATA[标准输出print() 简单输出 函数print()接受一个参数：需要打印的信息，如字符串，整数，列表等。 示例： 1print("hello print") 输出结果： 标准输入input()函数input()让程序暂停运行，等待用户输入一些文本。获取输入后，python将其存储在一个变量中，以便后续使用。input()接受一个参数：要向用户显示的提示或说明信息。 示例： 1str = input("请输入一句话:") 输出结果： 需要注意的是，使用input()函数时，python将用户输入解读为字符串。 示例： 1age = input("请输入您的年龄:") 输出结果： 可以看到，输出的age是带引号的，也就是说它确实被python解读为字符串。 如果需要将输入的数字转换为数值型，可以使用int()函数，将字符串转换为整型某某某 示例： 12age = input("请输入您的年龄:")age = int(age) 输出结果： 可以看到，使用int()函数转换后，输出的age是不带引号的，age 确实变成了整型。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3教程-第1章 入门]]></title>
    <url>%2F2018%2F06%2F11%2Fpython3-tutorial-chapter1-helloworld%2F</url>
    <content type="text"><![CDATA[课题组要求每一个组员必须学会python，并能使用scrapy（python的一个爬虫框架）编写爬虫，故有了这个系列的教程。 教程使用教材：《python编程从入门到实践》 本文是python3教程系列的第一篇，主要讲下python环境的搭建，以及永恒的hello wolrd &gt;_&lt; 安装python3 Windows/Mac os python官网下载地址，按照官网的提示下载对应的版本，安装就行。安装完后，Windows用户双击安装目录下的python.exe，即可进入python命令行交互模式。 当然，最好在系统环境变量PATH中添加下python的安装路径，这样只要打开命令行界面，输入python就可以进入python命令行交互模式。 Mac用户自己解决问题咯，因为我没用过Mac os，哈哈哈。 Linux 如果你用的Linux操作系统，咱不需要下载python，为什么呢？因为大多数Linux系统已经自带了python环境。 我们可以在终端输入python，试探下系统是否已经安装python环境 下图是我在ubuntu下的测试结果 系统提示我没有找到python命令，并给我提供了python的安装方法，最后又提示我，系统已经安装了python3，我可以直接输入python3，出现&gt;&gt;&gt;，表示已经进入python命令行交互模式。 hello python进入python命令行交互模式后，输入 1print("hello python") 不出意外的话，下面会打印一行“hello python” 实际操作及结果如下： 输入exit()或者ctrl+D可以退出python命令行交互模式 刚才演示的是在python命令行交互模式直接写代码，我们能不能像其他语言一样，把代码写在一个文件里，然后编译执行呢？答案当然是可以的。 现在我在桌面新建一个hello.py文件，并把刚才写的代码在文件里重新写一遍 输入如下命令（Windows/Mac用python代替我的python3） 1python3 hello.py 输出如下]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的进制表示]]></title>
    <url>%2F2018%2F06%2F10%2Fjava-binary-octal-decimal-hexadecimal%2F</url>
    <content type="text"><![CDATA[平时做题也好，写程序或算法也罢，我们经常会见到诸如0Xfff、0b1000等数据，那么它们到底是什么意思呢？ 其实0x、0b等是不同进制的前缀，旨在告诉编译器后面的数字是几进制的数据，而非默认的十进制数据。 二进制（binary）：以0b或者0B为前缀，例如0b1000，等价于十进制的$1*2^3$=8 需要注意的是，0b（0B）这种写法是从jdk1.7才有的 八进制（octal）：以0为前缀，例如：070，等价于十进制的$7*8^1+0*8$=56 十进制（decimal）：没有前缀，默认情况下数字均为十进制表示 十六进制（hexadecimal）：以0x或者0X为前缀，例如算法中很常见的0xfff 上面的0是数字0，而不是字母o 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; int binary1 = 0b1000;//8 System.out.println(binary1); int binary2 = 0B111;//7 System.out.println(binary2); int octal = 070;//56 System.out.println(octal); int hexadecimal = 0xfff;//4095 System.out.println(hexadecimal); &#125;&#125; 输出结果： 123487564095]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构(C/C++版)之单链表的实现]]></title>
    <url>%2F2018%2F06%2F07%2Fdata-structure-singlelinkedlist-in-c-or-c%2F</url>
    <content type="text"><![CDATA[用C/C++实现的单链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/*以下所有方法中的index从1开始，而不是0. */typedef struct Node&#123; ElemType data; struct Node * next;&#125; LinkedList;//单链表//如果参数写为LinkedList * list，并不会改变实参的值，但可以改变实参指针变量所指向的变量的值//初始化单链表void init(LinkedList * &amp;list)&#123; list = (LinkedList *) malloc(sizeof(LinkedList)); list-&gt;next = NULL;&#125;//是否为空bool isEmpty(LinkedList * list)&#123; return list-&gt;next == NULL;&#125;//输出单链表void print(LinkedList * list)&#123; LinkedList * p = list-&gt;next; while(p!=NULL) &#123; printf("%d ",p-&gt;data); p=p-&gt;next; &#125; printf("\n");&#125;//计算单链表长度，头结点不算在内int length(LinkedList * list)&#123; int count = 0; LinkedList * p = list; while(p-&gt;next!=NULL) &#123; count++; p = p-&gt;next; &#125; return count;&#125;/*//判断index是否为正确的位置索引，索引号从1开始到length(list)static bool isPositionIndex(LinkedList * list,int index) &#123; if(index &gt; 0 &amp;&amp; index &lt;= length(list)) return true; else return false;&#125;//判断index是否为正确的可添加结点的位置索引，索引号从1开始到length(list)+1static bool isPositionIndexForAdd(LinkedList * list,int index) &#123; if(index &gt; 0 &amp;&amp; index &lt;= length(list) + 1) return true; else return false;&#125;*///在单链表尾部添加结点bool add(LinkedList * &amp;list,ElemType e)&#123; LinkedList * p,* last = list; while(last-&gt;next!=NULL) &#123; last = last-&gt;next; &#125; p = (LinkedList *)malloc(sizeof(LinkedList)); p-&gt;data = e; p-&gt;next = NULL; last-&gt;next = p; return true;&#125;//在索引位置为index处插入新的结点//下面的写法，只遍历了一次单链表bool add(LinkedList * &amp;list,int index,ElemType e)&#123; int count = 0; LinkedList * newNode,* p = list; while(p != NULL &amp;&amp; count &lt; index - 1)//找到index结点的前一个结点 &#123; count++; p = p-&gt;next; &#125; if(p == NULL)//不存在第index-1个结点 return false; else &#123; newNode = (LinkedList *)malloc(sizeof(LinkedList)); newNode-&gt;data = e; newNode-&gt;next = p-&gt;next; p-&gt;next = newNode; return true; &#125;&#125;/*//下面的写法， 遍历了两遍单链表bool add(LinkedList * &amp;list,int index,ElemType e)&#123; //判断给定的index是否合理 if(!isPositionIndexForAdd(list,index)) return false; int count = 0; LinkedList * newNode,* p = list; while(p != NULL &amp;&amp; count &lt; index - 1)//找到index结点的前一个结点 &#123; count++; p = p-&gt;next; &#125; newNode = (LinkedList *)malloc(sizeof(LinkedList)); newNode-&gt;data = e; newNode-&gt;next = p-&gt;next; p-&gt;next = newNode; return true;&#125;*///获取单链表中位置索引为index的元素，并将值赋给e//只遍历一次bool get(LinkedList * list,int index,ElemType &amp;e)&#123; LinkedList * p = list-&gt;next; int count = 1; while(p != NULL &amp;&amp; count &lt; index) &#123; count++; p = p-&gt;next; &#125; if(p == NULL)//不存在第index个结点 return false; else &#123; e = p-&gt;data; return true; &#125;&#125;/*//需要遍历两次单链表bool get(LinkedList * list,int index,ElemType &amp;e)&#123; if(!isPositionIndex(list,index)) return false; LinkedList * p = list-&gt;next; int count = 1; while(p != NULL &amp;&amp; count &lt; index) &#123; count++; p = p-&gt;next; &#125; e = p-&gt;data; return true;&#125;*//*//另一种更简洁的写法ElemType get(LinkedList * list,int index)&#123; LinkedList * p = list-&gt;next; int count = 1; while(p != NULL &amp;&amp; count &lt; index) &#123; count++; p = p-&gt;next; &#125; if(p == NULL)//不存在第index个结点 return NULL; else return p-&gt;data;&#125; *///删除最后一个结点bool remove(LinkedList * &amp;list,ElemType &amp;e)&#123; LinkedList * oldNode,* p = list; if(p-&gt;next == NULL) return false; while(p-&gt;next-&gt;next != NULL)//找最后一个结点的前驱结点 &#123; p = p-&gt;next; &#125; oldNode = p-&gt;next; e =oldNode-&gt;data; p-&gt;next = NULL; free(oldNode); return true;&#125;//删除第index个结点bool remove(LinkedList * &amp;list,int index,ElemType &amp;e)&#123; int count = 0; LinkedList * oldNode, * p = list; while(p != NULL &amp;&amp; count &lt; index - 1)//找到第index-1个结点 &#123; count++; p = p-&gt;next; &#125; if(p == NULL)//不存在第index-1个结点 return false; else &#123; oldNode = p-&gt;next; //这里需要特别注意，必须判断oldNode是否为NULL if(oldNode == NULL) return false; e = oldNode-&gt;data; p-&gt;next = oldNode-&gt;next; free(oldNode); return true; &#125;&#125;//在单链表中元素e首次出现的位置 ，若不存在，则返回-1int indexOf(LinkedList * list,ElemType e)&#123; int count = 1; LinkedList * p = list-&gt;next; while(p != NULL &amp;&amp; p-&gt;data != e) &#123; count++; p = p-&gt;next; &#125; if(p == NULL) return -1; else return count;&#125;//销毁单链表void destroy(LinkedList * &amp;list)&#123; LinkedList * pre = list,* p = list-&gt;next; while(p!=NULL) &#123; free(pre); pre = p; p = p-&gt;next; &#125; free(pre);&#125; 测试程序： 123456789101112131415161718192021222324252627typedef int ElemType;//声明LinkedList.h中的ElemType为int类型#include &lt;stdio.h&gt;#include "LinkedList.h"//包含头文件时，尖括号用于引入系统库，自己定义的头文件，需要使用引号引入int main() &#123; LinkedList * list; init(list); add(list,20); add(list,20); add(list,21); add(list,22); add(list,23); add(list,2,100); printf("长度：%d\n",length(list)); print(list); ElemType e; if(get(list,4,e)) printf("第4个结点的值为：%d\n",e); printf("100首次出现的位置为：%d\n",indexOf(list,100)); if(remove(list,3,e)) printf("第3个结点的值为：%d\n",e); if(remove(list,e)) printf("最后一个结点的值为：%d\n",e); print(list); destroy(list); return 0;&#125; 输出结果： 1234567长度：620 100 20 21 22 23 第4个结点的值为：21100首次出现的位置为：2第3个结点的值为：20最后一个结点的值为：2320 100 21 22]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP每日一练之201803-3 URL映射]]></title>
    <url>%2F2018%2F06%2F06%2Fccf-csp-daily-practice-20180303-urlmapping%2F</url>
    <content type="text"><![CDATA[问题描述 URL 映射是诸如 Django、Ruby on Rails 等网页框架 (web frameworks) 的一个重要组件。对于从浏览器发来的 HTTP 请求，URL 映射模块会解析请求中的 URL 地址，并将其分派给相应的处理代码。现在，请你来实现一个简单的 URL 映射功能。 本题中 URL 映射功能的配置由若干条 URL 映射规则组成。当一个请求到达时，URL 映射功能会将请求中的 URL 地址按照配置的先后顺序逐一与这些规则进行匹配。当遇到第一条完全匹配的规则时，匹配成功，得到匹配的规则以及匹配的参数。若不能匹配任何一条规则，则匹配失败。 本题输入的 URL 地址是以斜杠 / 作为分隔符的路径，保证以斜杠开头。其他合法字符还包括大小写英文字母、阿拉伯数字、减号 -、下划线 _ 和小数点 .。例如，/person/123/ 是一个合法的 URL 地址，而 /person/123? 则不合法（存在不合法的字符问号 ?）。另外，英文字母区分大小写，因此 /case/ 和 /CAse/ 是不同的 URL 地址。 对于 URL 映射规则，同样是以斜杠开始。除了可以是正常的 URL 地址外，还可以包含参数，有以下 3 种： 字符串 &lt;str&gt;：用于匹配一段字符串，注意字符串里不能包含斜杠。例如，abcde0123。 整数 &lt;int&gt;：用于匹配一个不带符号的整数，全部由阿拉伯数字组成。例如，01234。 路径 &lt;path&gt;：用于匹配一段字符串，字符串可以包含斜杠。例如，abcd/0123/。 以上 3 种参数都必须匹配非空的字符串。简便起见，题目规定规则中 &lt;str&gt; 和 &lt;int&gt; 前面一定是斜杠，后面要么是斜杠，要么是规则的结束（也就是该参数是规则的最后一部分）。而 &lt;path&gt; 的前面一定是斜杠，后面一定是规则的结束。无论是 URL 地址还是规则，都不会出现连续的斜杠。 输入格式 输入第一行是两个正整数 n 和 m，分别表示 URL 映射的规则条数和待处理的 URL 地址个数，中间用一个空格字符分隔。 第 2 行至第 n+1 行按匹配的先后顺序描述 URL 映射规则的配置信息。第 i+1 行包含两个字符串 pi 和 ri，其中 pi 表示 URL 匹配的规则，ri 表示这条 URL 匹配的名字。两个字符串都非空，且不包含空格字符，两者中间用一个空格字符分隔。 第 n+2 行至第 n+m+1 行描述待处理的 URL 地址。第 n+1+i 行包含一个字符串 qi，表示待处理的 URL 地址，字符串中不包含空格字符。 输出格式 输入共 m 行，第 i 行表示 qi 的匹配结果。如果匹配成功，设匹配了规则 pj ，则输出对应的 rj。同时，如果规则中有参数，则在同一行内依次输出匹配后的参数。注意整数参数输出时要把前导零去掉。相邻两项之间用一个空格字符分隔。如果匹配失败，则输出 404。 样例输入 5 4/articles/2003/ special_case_2003/articles/&lt;int&gt;/ year_archive/articles/&lt;int&gt;/&lt;int&gt;/ month_archive/articles/&lt;int&gt;/&lt;int&gt;/&lt;str&gt;/ article_detail/static/&lt;path&gt; static_serve/articles/2004//articles/1985/09/aloha//articles/hello//static/js/jquery.js 样例输出 year_archive 2004article_detail 1985 9 aloha404static_serve js/jquery.js 样例说明 对于第 1 个地址 /articles/2004/，无法匹配第 1 条规则，可以匹配第 2 条规则，参数为 2004。 对于第 2 个地址 /articles/1985/09/aloha/，只能匹配第 4 条规则，参数依次为 1985、9（已经去掉前导零）和 aloha。 对于第 3 个地址 /articles/hello/，无法匹配任何一条规则。 对于第 4 个地址 /static/js/jquery.js，可以匹配最后一条规则，参数为 js/jquery.js。 数据规模和约定 1 ≤ n ≤ 100，1 ≤ m ≤ 100。 所有输入行的长度不超过 100 个字符（不包含换行符）。 保证输入的规则都是合法的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); Integer[] data = toIntegerArray(scan.nextLine().split(" ")); UrlMapping[] mappings = new UrlMapping[data[0]]; String[] url = new String[data[1]]; for (int i = 0; i &lt; data[0]; i++) &#123; String[] sArr = scan.nextLine().split(" "); UrlMapping urlMapping = new UrlMapping(); urlMapping.setExpression(sArr[0]); urlMapping.setName(sArr[1]); mappings[i] = urlMapping; &#125; for (int i = 0; i &lt; url.length; i++) &#123; url[i] = scan.nextLine(); &#125; for (int i = 0; i &lt; url.length; i++) &#123; boolean flag = false; if (url[i].matches("(/[\\w-\\.]+)+/?")) &#123;// 判断url是否合法 for (UrlMapping urlMapping : mappings) &#123; if (matches(urlMapping, url[i])) &#123; flag = true; break; &#125; &#125; &#125; if (!flag) &#123; System.out.println(404); &#125; &#125; scan.close(); &#125; private static boolean matches(UrlMapping urlMapping, String url) &#123; String expression = urlMapping.getExpression(); String[] mappingArr = expression.split("/"); String[] urlArr = url.split("/"); /*如果映射规则分割后的长度小于url的长度，但是映射规则不包含&lt;path&gt;， 或者映射规则分割后的长度大于url的长度，则不匹配*/ if ((mappingArr.length &lt; urlArr.length &amp;&amp; !expression.endsWith("&lt;path&gt;")) || mappingArr.length &gt; urlArr.length) &#123; return false; &#125; if (expression.endsWith("/") &amp;&amp; !url.endsWith("/")) &#123; return false; &#125; if ((!expression.endsWith("&lt;path&gt;") &amp;&amp; !expression.endsWith("/")) &amp; url.endsWith("/")) &#123; return false; &#125; String[] args = new String[urlArr.length]; int count = 0; for (int i = 0; i &lt; mappingArr.length; i++) &#123; if (mappingArr[i].equals("&lt;str&gt;")) &#123; //&lt;str&gt;不能匹配纯数字 if (!urlArr[i].matches("[\\w-\\.]+") || urlArr[i].matches("[0-9]+")) &#123; return false; &#125; args[count++] = urlArr[i]; &#125; else if (mappingArr[i].equals("&lt;int&gt;")) &#123; if (!urlArr[i].matches("[0-9]+")) &#123; return false; &#125; args[count++] = deleteStartsZero(urlArr[i]); &#125; else if (mappingArr[i].equals("&lt;path&gt;")) &#123; StringBuilder sb = new StringBuilder(urlArr[i]); for (int j = i + 1; j &lt; urlArr.length; j++) &#123; sb.append("/" + urlArr[j]); &#125; if (url.endsWith("/")) &#123;// 加上url结尾的/ sb.append("/"); &#125; args[count++] = sb.toString(); &#125; else if (!mappingArr[i].equals(urlArr[i])) &#123; return false; &#125; &#125; StringBuilder sb = new StringBuilder(urlMapping.getName() + " "); for (int k = 0; k &lt; count; k++) &#123; sb.append(args[k] + " "); &#125; System.out.println(sb); return true; &#125; //更简洁的做法：String.valueOf(Integer.parseInt(str)); private static String deleteStartsZero(String str) &#123; int i; for(i = 0 ; i &lt; str.length();i++) &#123; if(str.charAt(i) != '0') &#123; break; &#125; &#125; return str.substring(i); &#125; private static Integer[] toIntegerArray(String[] sArr) &#123; Integer[] intArr = new Integer[sArr.length]; for (int i = 0; i &lt; sArr.length; i++) &#123; intArr[i] = Integer.valueOf(sArr[i]); &#125; return intArr; &#125; private static class UrlMapping &#123; String expression; String name; public String getExpression() &#123; return expression; &#125; public void setExpression(String expression) &#123; this.expression = expression; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125;&#125; 测试结果（提交了n次，还是90分..） 2018/06/09 更新 偶然发现，上次写的代码，之所以一直不能通过，显示得分90，原因在于我在上面第23行做了一个URL正则过滤，过滤不合法的URL，估计可能是我正则表达式写的不对，导致有些测试用例没运行matches方法，直接输出了404. 其实题目已经写明了保证所有输入都合法，我们没必要再去处理不合法输入的情况=_= 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); Integer[] data = toIntegerArray(scan.nextLine().split(" ")); UrlMapping[] mappings = new UrlMapping[data[0]]; String[] url = new String[data[1]]; for (int i = 0; i &lt; data[0]; i++) &#123; String[] sArr = scan.nextLine().split(" "); UrlMapping urlMapping = new UrlMapping(); urlMapping.setExpression(sArr[0]); urlMapping.setName(sArr[1]); mappings[i] = urlMapping; &#125; for (int i = 0; i &lt; url.length; i++) &#123; url[i] = scan.nextLine(); &#125; for (int i = 0; i &lt; url.length; i++) &#123; boolean flag = false; for (UrlMapping urlMapping : mappings) &#123; if (matches(urlMapping, url[i])) &#123; flag = true; break; &#125; &#125; if (!flag) &#123; System.out.println(404); &#125; &#125; scan.close(); &#125; private static boolean matches(UrlMapping urlMapping, String url) &#123; String expression = urlMapping.getExpression(); String[] mappingArr = expression.split("/"); String[] urlArr = url.split("/"); /*如果映射规则分割后的长度小于url的长度，但是映射规则不包含&lt;path&gt;， 或者映射规则分割后的长度大于url的长度，则不匹配*/ if ((mappingArr.length &lt; urlArr.length &amp;&amp; !expression.endsWith("&lt;path&gt;")) || mappingArr.length &gt; urlArr.length) &#123; return false; &#125; if (expression.endsWith("/") &amp;&amp; !url.endsWith("/")) &#123; return false; &#125; if ((!expression.endsWith("&lt;path&gt;") &amp;&amp; !expression.endsWith("/")) &amp; url.endsWith("/")) &#123; return false; &#125; String[] args = new String[urlArr.length]; int count = 0; for (int i = 0; i &lt; mappingArr.length; i++) &#123; if (mappingArr[i].equals("&lt;str&gt;")) &#123; //&lt;str&gt;不能匹配纯数字 if (!urlArr[i].matches("[\\w-\\.]+") || urlArr[i].matches("[0-9]+")) &#123; return false; &#125; args[count++] = urlArr[i]; &#125; else if (mappingArr[i].equals("&lt;int&gt;")) &#123; if (!urlArr[i].matches("[0-9]+")) &#123; return false; &#125; args[count++] = deleteStartsZero(urlArr[i]); &#125; else if (mappingArr[i].equals("&lt;path&gt;")) &#123; StringBuilder sb = new StringBuilder(urlArr[i]); for (int j = i + 1; j &lt; urlArr.length; j++) &#123; sb.append("/" + urlArr[j]); &#125; if (url.endsWith("/")) &#123;// 加上url结尾的/ sb.append("/"); &#125; args[count++] = sb.toString(); &#125; else if (!mappingArr[i].equals(urlArr[i])) &#123; return false; &#125; &#125; StringBuilder sb = new StringBuilder(urlMapping.getName() + " "); for (int k = 0; k &lt; count; k++) &#123; sb.append(args[k] + " "); &#125; System.out.println(sb); return true; &#125; //更简洁的做法：String.valueOf(Integer.parseInt(str)); private static String deleteStartsZero(String str) &#123; int i; for(i = 0 ; i &lt; str.length();i++) &#123; if(str.charAt(i) != '0') &#123; break; &#125; &#125; return str.substring(i); &#125; private static Integer[] toIntegerArray(String[] sArr) &#123; Integer[] intArr = new Integer[sArr.length]; for (int i = 0; i &lt; sArr.length; i++) &#123; intArr[i] = Integer.valueOf(sArr[i]); &#125; return intArr; &#125; private static class UrlMapping &#123; String expression; String name; public String getExpression() &#123; return expression; &#125; public void setExpression(String expression) &#123; this.expression = expression; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125;&#125; 新的测试结果：]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP每日一练之201803-2 碰撞的小球]]></title>
    <url>%2F2018%2F06%2F06%2Fccf-csp-daily-practice-20180302-crash%2F</url>
    <content type="text"><![CDATA[问题描述 数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。 当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。 当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。 现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。 提示 因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。 同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。 输入格式 输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。 第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。 输出格式 输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。 样例输入 3 10 54 6 8 样例输出 7 9 9 样例说明 初始时，三个小球的位置分别为4, 6, 8。 一秒后，三个小球的位置分别为5, 7, 9。 两秒后，第三个小球碰到墙壁，速度反向，三个小球位置分别为6, 8, 10。 三秒后，第二个小球与第三个小球在位置9发生碰撞，速度反向（注意碰撞位置不一定为偶数），三个小球位置分别为7, 9, 9。 四秒后，第一个小球与第二个小球在位置8发生碰撞，速度反向，第三个小球碰到墙壁，速度反向，三个小球位置分别为8, 8, 10。 五秒后，三个小球的位置分别为7, 9, 9。 样例输入 10 22 3014 12 16 6 10 2 8 20 18 4 样例输出 6 6 8 2 4 0 4 12 10 2 数据规模和约定 对于所有评测用例，1 ≤ n ≤ 100，1 ≤ t ≤ 100，2 ≤ L ≤ 1000，0 &lt; ai &lt; L。L为偶数。 保证所有小球的初始位置互不相同且均为偶数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int[] condition = toIntArray(scan.nextLine().split(" ")); int[] data = toIntArray(scan.nextLine().split(" ")); int[] lastPosition = new int[data.length]; int line = condition[1]; int t = condition[2]; int[] directions = new int[data.length]; for (int i = 0; i &lt; directions.length; i++) &#123; directions[i] = 1;//默认向右移动 &#125; // 执行t次 for (int i = 0; i &lt; t; i++) &#123; // 上一次小球的位置 for (int j = 0; j &lt; lastPosition.length; j++) &#123; lastPosition[j] = data[j]; &#125; for (int j = 0; j &lt; lastPosition.length; j++) &#123; if (lastPosition[j] == line || lastPosition[j] == 0) &#123; //若为线段两端点 directions[j] = -directions[j]; &#125; else &#123; //如果存在位置相同的小球，则发生了碰撞 for (int k = 0; k &lt; lastPosition.length; k++) &#123; if(j != k &amp;&amp; lastPosition[j] == lastPosition[k]) &#123; directions[j] = -directions[j]; break; &#125; &#125; &#125; data[j] += directions[j]; &#125; &#125; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; data.length; i++) &#123; sb.append(data[i] + " "); &#125; System.out.println(sb.toString()); scan.close(); &#125; private static int[] toIntArray(String[] sArr) &#123; int[] intArr = new int[sArr.length]; for (int i = 0; i &lt; sArr.length; i++) &#123; intArr[i] = Integer.valueOf(sArr[i]); &#125; return intArr; &#125;&#125; 测试结果 之前全写的包装类型Integer，一直不能通过测试，总显示得分：30，全改为int就正确了，看来以后做题还是得用基本数据类型。 这题目其实不难，但是刚开始没思路，后来又想复杂了，困扰了我好几天，也是够了&gt;_&lt;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP每日一练之201803-1跳一跳]]></title>
    <url>%2F2018%2F06%2F05%2Fccf-csp-daily-practice-20180301-jump%2F</url>
    <content type="text"><![CDATA[为了准备九月的CCF CSP第十四次认证，从今天起，尽量保证每天刷一道CCF CSP的题。 问题描述 近来，跳一跳这款小游戏风靡全国，受到不少玩家的喜爱。 简化后的跳一跳规则如下：玩家每次从当前方块跳到下一个方块，如果没有跳到下一个方块上则游戏结束。 如果跳到了方块上，但没有跳到方块的中心则获得1分；跳到方块中心时，若上一次的得分为1分或这是本局游戏的第一次跳跃则此次得分为2分，否则此次得分比上一次得分多两分（即连续跳到方块中心时，总得分将+2，+4，+6，+8…）。 现在给出一个人跳一跳的全过程，请你求出他本局游戏的得分（按照题目描述的规则）。 输入格式 输入包含多个数字，用空格分隔，每个数字都是1，2，0之一，1表示此次跳跃跳到了方块上但是没有跳到中心，2表示此次跳跃跳到了方块上并且跳到了方块中心，0表示此次跳跃没有跳到方块上（此时游戏结束）。 输出格式 输出一个整数，为本局游戏的得分（在本题的规则下）。 样例输入 1 1 2 2 2 1 1 2 2 0 样例输出 22 数据规模和约定 对于所有评测用例，输入的数字不超过30个，保证0正好出现一次且为最后一个数字。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); String str = scan.nextLine(); Integer[] arr = toIntegerArray(str.split("\\s+")); int sum = 0; int count = 0; for(int i = 0 ; i &lt; arr.length ; i++) &#123; if(arr[i] == 1) &#123; sum += 1; &#125; else if(arr[i] == 2) &#123; if(i == 0 || arr[i-1] == 1) &#123; sum += 2; &#125; else &#123; count = count(arr,i); sum += 2 * count; &#125; &#125; &#125; System.out.println(sum); scan.close(); &#125; //根据索引号数连续2的个数 private static int count(Integer[] arr,int i) &#123; int count = 0; for(int j = i ; j &gt;= 0 ; j--) &#123; if(arr[j]==1) &#123; break; &#125; count++; &#125; return count; &#125; private static Integer[] toIntegerArray(String[] sArr) &#123; Integer[] intArr = new Integer[sArr.length]; for(int i = 0 ; i &lt; sArr.length ;i++) &#123; intArr[i] = Integer.valueOf(sArr[i]); &#125; return intArr; &#125;&#125; 测试结果]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构(C/C++版)之动态顺序表的实现]]></title>
    <url>%2F2018%2F06%2F03%2Fdata-structure-sqlist-in-c-or-c%2B%2B%2F</url>
    <content type="text"><![CDATA[写在前面的话：类似如下函数：bool add(SqList &amp;list, int i, ElemType e)c语言没有bool关键字，c++才有，若需要在c语言中使用，需要引入&lt;stdbool.h&gt;（或者自己定义）.另外，函数参数中&amp;符号，表示引用，c语言也没有（c语言中的&amp;表示取地址符），这是c++才有的语法，若需要在c语言中实现类似功能，即改变实参的值，只能采用指针实现 用C/C++实现的动态顺序表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;stdlib.h&gt;#define DEFAULT_CAPACITY 10 //默认容量#define DEFAULT_INCREMENT_SIZE 1 //默认扩容大小typedef struct &#123; ElemType * data;//存储元素的一维数组 int length; //顺序表当前的长度 int size; //顺序表的容量 int incrementSize; //增补空间大小&#125; SqList;//初始化，需要注意的是：给参数设置默认值，c语言没有这种语法void init(SqList &amp;list, int capacity = DEFAULT_CAPACITY, int incrementSize = DEFAULT_INCREMENT_SIZE) &#123; list.data = (ElemType *) malloc(capacity * sizeof(ElemType)); if (!list.data) &#123; exit(1); &#125; list.length = 0; list.size = capacity; list.incrementSize = incrementSize;&#125;bool isEmpty(SqList list) &#123; return list.length == 0;&#125;//求顺序表的长度int length(SqList list) &#123; return list.length;&#125;//元素首次出现的位置int indexOf(SqList list, ElemType e) &#123; for (int i = 0; i &lt; list.length; i++) &#123; if (list.data[i] == e) &#123; return i; &#125; &#125; return -1;&#125;//元素最后一次出现的位置int lastIndexOf(SqList list, ElemType e) &#123; for (int i = list.length - 1; i &gt;= 0; i--) &#123; if (list.data[i] == e) &#123; return i; &#125; &#125; return -1;&#125;/* * static关键字的作用类似于Java中private，声明为内部函数，只能在本文件中使用 * 另外需要注意的是，该函数必须放在引用之前，否则，编译时会报错 */static bool isElementIndex(SqList list, int i) &#123; return (i &gt;= 0 &amp;&amp; i &lt; list.length) ? true : false;&#125;static bool isPositionIndex(SqList list, int i) &#123; return (i &gt;= 0 &amp;&amp; i &lt;= list.length) ? true : false;&#125;static void ensureCapacity(SqList &amp;list) &#123; //扩容 if (list.length &gt;= list.size) &#123; list.data = (ElemType *) realloc(list.data, (list.size + list.incrementSize) * sizeof(ElemType)); //判断存储空间是否分配成功 if (!list.data) &#123; exit(1); &#125; list.size += list.incrementSize; //增加当前存储容量 &#125;&#125;//在顺序表中指定索引处插入元素bool add(SqList &amp;list, int i, ElemType e) &#123; if (!isPositionIndex(list, i)) &#123; return false; &#125; ensureCapacity(list); for (int j = list.length; j &gt; i; j--) &#123; list.data[j] = list.data[j - 1]; &#125; list.data[i] = e; //??? list.length++; return true;&#125;//在顺序表的最后面添加元素bool add(SqList &amp;list, ElemType e) &#123; //扩容 ensureCapacity(list); list.data[list.length] = e; list.length++; return true;&#125;//删除最后一个元素bool remove(SqList &amp;list, ElemType &amp;e) &#123; if (isEmpty(list)) &#123; return false; &#125; e = list.data[list.length - 1]; list.length--; return true;&#125;//删除指定索引处的元素bool remove(SqList &amp;list, int i, ElemType &amp;e) &#123; if (!isElementIndex(list, i) || isEmpty(list)) &#123; return false; &#125; e = list.data[i]; for (int j = i + 1; j &lt;= list.length - 1; j++) &#123; list.data[j - 1] = list.data[j]; &#125; list.length--; return true;&#125;//取元素bool get(SqList list, int i, ElemType &amp;e) &#123; if (!isElementIndex(list, i)) &#123; return false; &#125; e = list.data[i]; return true;&#125;//遍历输出void print(SqList list) &#123; for (int i = 0; i &lt; list.length; i++) &#123; printf("%d\n", list.data[i]); &#125;&#125;//销毁void destroy(SqList &amp;list) &#123; free(list.data); list.length = 0; list.incrementSize = 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言中的动态内存分配]]></title>
    <url>%2F2018%2F06%2F01%2Fc-dynamic-memory-allocation%2F</url>
    <content type="text"><![CDATA[简介全局变量是分配在内存中的静态存储区的，非静态的局部变量是分配在内存中的动态存储区的，这个存储区是一个称为栈（stack）的区域。 除此以外，C语言还允许建立内存动态分配区域，以存放一些临时用的数据，这些数据不必在程序的声明部分定义，也不必等到函数结束时才释放，而是需要时随时开辟，不需要时随时释放。这些数据是临时存放在一个特别的自由存储区，称为堆（heap）区。由于未在声明部分定义它们为变量或数组，因此不能通过变量名或数组名去引用这些数据，只能通过指针来引用。 动态分配内存C语言中，对内存的动态分配，主要是通过malloc、calloc、free和realloc这四个函数实现。 1.malloc函数 函数原型为 1void * malloc(unsigned int size); 作用：在内存的动态存储区中分配一个长度为size的连续空间。 函数的返回值是所分配区域的第一个字节的地址。指针的基类型为void，即不能指向任何类型的数据，只提供一个地址。如果函数未能成功地执行，则返回空指针（NULL）。 示例 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; extern void check(int * p);//函数声明 int * p = (int *)malloc(5*sizeof(int));//开辟动态内存区，并将地址转换为int * 型 for(int i = 0; i &lt; 5;i++) &#123; scanf("%d",p+i); &#125; check(p); return 0;&#125;extern void check(int * p) &#123; printf("fail\n"); for(int i = 0 ; i &lt; 5;i++ ) &#123; if(p[i] &lt; 60) printf("%d",p[i]); &#125;&#125; 事实上，第5行中的代码也可以写成如下形式： 1int * p = malloc(5*sizeof(int));//由系统进行隐式的类型转换 推荐采用第一种写法，显式的强制转换，更加清楚直观。 另外，因为在不同系统中存放一个指定类型的字节数是不同的，为了使程序具有通用性，我在第5行中使用了sizeof运算符测定在本系统中整数的字节数。 (未完待续)]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法的时间复杂度和空间复杂度]]></title>
    <url>%2F2018%2F05%2F31%2Ftime-and-space-complexity%2F</url>
    <content type="text"><![CDATA[算法效率的度量是对算法所需要的时间和空间进行估算，分别称为时间复杂度和空间复杂度。 时间复杂度算法的时间效率称为算法的时间复杂度，它是问题规模n的某个函数，记作：T(n) = O(f(n))。 其中问题规模n是指输入量的多少，一般可以从问题描述中得到。如，数组元素的个数、矩阵的阶数等。f(n) 是问题规模n的某个函数。这里的O是Order的简写，意指数量级，表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同。 一个没有循环的算法基本运算次数与问题规模无关，记作O(1)，也称为常数阶。 常见的算法时间复杂度由小到大排列如下： O(1) &lt; O($\log_{2}n$) &lt; O(n) &lt; O($n\log_{2}n$) &lt; O($n^2$) &lt; O($n^3$) &lt; … &lt; O($c^n$) &lt; O(n!) 时间复杂度的计算 不带循环 1x++;//基本语句的执行次数为1，因此时间复杂度为O(1) 简单循环 1234int x = 0;//语句1，执行1次for( int i = 0 ; i &lt; n ; i++ ) &#123;//语句2，i从0开始到n，执行了n+1次 x+=i;//语句3，执行n次&#125; 因此，该算法的执行次数为T(n)=1+(n+1)+n=2n+2=O(n)，这种计算方式相对麻烦。 该算法的基本运算为循环中的语句3，它的执行次数为T(n)=n=O(n)。显然，这种计算方式比上面的简单得多，以后均采用这种方式分析算法的时间复杂度。 12345for(int i = 0 ; i &lt; n ; i++) &#123;//该循环执行n次 for(int j = 0; j &lt; n ;j++) &#123;//该循环执行n次 x++; &#125;&#125; 显然，该算法的基本运算为x++，其执行了$n^2$次，因此该算法的时间复杂度为O($n^2$)。 12345678void fun(int n) &#123; int x=0; for(int i = 1 ; i &lt; n ; i++) &#123;//该循环执行n-1次 for(int j = i + 1; j &lt;= n ;j++) &#123;//该循环执行n-(i+1)+1=n-i次 x++; &#125; &#125;&#125; 如何计算该算法的时间复杂度呢？ 显然，该算法的基本运算仍为x++，设x++语句执行次数为T(n)，则 $$T(n)=\sum_{i=1}^{n-1}\sum_{j=i+1}^n1=\sum_{i=1}^{n-1}(n-i)=\frac{n(n-1)}{2}=O(n^2)$$ 复杂循环 12345678void fun(int n) &#123; int m = 0; for(int i = 1 ; i &lt;= n ; i++) &#123; for(int j = 2*i ; j &lt;= n ;j++) &#123; m++; &#125; &#125;&#125; 该算法的基本运算为m++，设其执行次数为T(n)，如果按照上面的方法，则 $$T(n)=\sum_{i=1}^n\sum_{j=2i}^{n}1=\sum_{i=1}^{n}(n-2i+1)=(n+1)n-2\frac{n(n+1)}{2}=0$$ 显然，这种做法是错误的，因为内循环从2i到n，即 i 必须满足: 2i ≤ n =&gt; $i&lt;\frac{n}{2}$，因此正确的做法是： $$T(n) = \sum_{i=1}^{\frac{n}{2}}\sum_{j=2i}^{n}1=\sum_{i=1}^{\frac{n}{2}}(n-2i+1)=(n+1)\frac{n}{2}-2\sum_{i=1}^{\frac{n}{2}}i$$ $$=(n+1)\frac{n}{2}-2\frac{(\frac{n}{2}+1)\frac{n}{2}}{2}=\frac{n^2}{4}=O(n^2)$$ 需要递归 12345678910111213void fun(int a[],int n,int k) &#123; int i; if(k==n-1) &#123; for(i = 0 ; i &lt; n ; i++) &#123; printf("%d\n",a[i]); &#125; &#125; else &#123; for(i = k ; i &lt; n ; i++) &#123; a[i] = a[i] + i * i; &#125; fun(a,n,k+1); &#125;&#125; 如何求fun(a,n,0)的时间复杂度呢？ 设fun(a,n,k)的执行时间为T(n,k)，从而，fun(a,n,0)的执行时间为T(n)=T(n,0)。 $$T(n,k)=\begin{cases} n, &amp; \text {k=n-1} \\ (n-k)+T(n,k+1), &amp; \text{其他} \end{cases}$$ 则， T(n)=T(n,0)=n+T(n,1)=n+(n-1)+T(n,2)=…=n+(n-1)+…+2+T(n,n-1) =$\frac{(n+2)(n-1)}{2}+n=\frac{n^2}{2}+\frac{3n}{2}-1=O(n^2)$ 最好、最坏及平均时间复杂度实际上，算法效率不仅仅依赖于问题的规模n，还与问题的初始输入有关。例如: 12345678int fun(int a[],int n,int k) &#123;//该算法用于在给定的数组a[]中查找k for(int i = 0 ; i &lt; n ; i++) &#123; if(a[i] == k) &#123; return i; &#125; &#125; return -1;&#125; 循环体的执行次数，不仅与问题规模n有关，还与输入实例中a的各元素取值以及k的取值有关。在最坏的情况下，a中没有与k相等的元素，则循环体执行n次；在最好的情况下，a中的第一个元素a[0]等于K，则循环体执行1次。 故，该算法的最好时间复杂度为O(1)，最坏时间复杂度为O(n)。在这种情况下，可用最坏情况下的时间复杂度作为算法的时间复杂度，因为最坏情况下的时间复杂度是在任何输入实例上运行时间的上界。 当然，也可用平均时间复杂度来衡量算法，下面给出平均时间复杂度的定义： 设一个算法的输入规模为n，$D_n$是所有输入的集合，任一输入I∈$D_n$，p(I)是I出现的频率，有$\sum_{I∈D_n}P(I)=1$，T(I)是算法在输入I下所执行的基本运算次数，则该算法的平均时间复杂度为： $$T(n)=\sum_{I∈D_n}{P(I)·T(I)}$$ 显然，最坏时间复杂度为$$T(n)=\max_{I∈D_n}{T(I)}$$ 空间复杂度空间复杂度是对一个算法在运行过程中临时占用的存储空间大小的度量。 一个算法在执行过程中所需要的存储空间包括以下3个部分： 1.算法本身占用的空间，取决于算法的长度； 2.输入输出数据占用的空间，取决于问题规模，与算法无关； 3.辅助存储空间，即算法临时开辟的存储空间，与算法有关。 算法的空间复杂度是对算法的执行过程需要的辅助空间进行度量。通常记作 S(n) = O(f(n))，其中n为问题规模，f(n)为问题规模n的一个函数。 下面也举几个例子 12345678910111213141516void sort(int x[],int n) &#123;//该算法将一个数组按从大到小的顺序排序 int i,j,k,t; for(i = 0 ; i &lt; n-1 ; i++) &#123; k = i; for(j = i + 1 ; j &lt; n ; j++) &#123; if(x[j] &gt; x[k]) &#123; k=j; &#125; if(k != i) &#123; t = x[i]; x[i] = x[k]; x[k] = t; &#125; &#125; &#125;&#125; 这里定义了四个辅助变量，临时存储空间与问题规模n无关，故其空间复杂度为O(1)，时间复杂度为O($n^2$) 一般而言，如果不包含递归调用，则算法的空间复杂度为O(1) 123456789void mergesort(int a[],int i,int j) &#123; int m; if(i != j) &#123; m = (i+j)/2; mergesort(a,i,m); mergesort(a,m+1,j); merge(a,i,j,m);//假定merge是一个非递归函数，其内部只定义了一个辅助变量 &#125;&#125; 如何求mergesort(a，0，n-1)的空间复杂度呢？ 对于该算法，设mergesort(a，0，n-1)的临时空间大小为S(n)，其中定义了一个辅助变量m， $$S(n)=\begin{cases} O(1) , &amp; \text{n=1} \ 2·S(\frac{n}{2})+1 , &amp; \text{n&gt;1} \end{cases}$$ 当n &gt; 1 时，S(n) = 2·S($\frac{n}{2}$) + 1 = 2 ( 2·S($\frac{n}{2^2}$) + 1) + 1=$2^2S(\frac{n}{4})$ + 1 + 2=$2^3S(\frac{n}{8})+1+2+2^2$ =…=$2^kS(\frac{n}{2^k})+\sum_{i=1}^{k}2^{i-1}$=$2^kO(1)+2^k-1$ 由于$\frac{n}{2^k}$ -&gt; 1，则k=$\log_{2}n$ 故S(n) = n + n - 1=2n-1，故该算法的空间复杂度为O(n)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言结构体]]></title>
    <url>%2F2018%2F05%2F31%2Fc-struct%2F</url>
    <content type="text"><![CDATA[C语言允许用户自己建立由不同类型数据组成的组合型的数据结构，它称为结构体。（类似于Java中的类） 定义结构体类型声明一个结构体类型的一般形式： 123struct 结构体名 &#123; 成员列表 &#125;; 对结构体中各成员都应进行类型声明，即 1类型名 成员名; 示例 12345struct Book &#123; char author[10]; char name[20]; double price;&#125;;//注意最后有一个分号 结构体的成员可以属于另一个结构体类型。例如： 1234567891011struct Date &#123; int year; int month; int day;&#125;;struct Book &#123; char author[10]; char name[20]; double price; struct Date publishTime;//成员publishTime属于struct Date类型&#125; 值得注意的是，结构体类型的名字是由关键字struct和结构体名组合而成的，即结构体类型 = struct 结构体名。 定义结构体类型变量C语言中定义结构体类型变量有三种方式。 1.先声明结构体类型，再定义该类型的变量（常用） 上面说到结构体内可以定义结构体类型的成员变量时，我的做法是先声明了一个结构体类型Struct Date，然后在声明Struct Book类型时，将成员变量publishTime指定为struct Date类型。下面再举一个例子说明 12345678910struct Date &#123; int year; int month; int day;&#125;;//声明struct Date类型int main() &#123; struct Date today;//定义struct Date类型的变量 ... return 0;&#125; 2.在声明类型的同时定义变量 这种定义的一般形式如下： 123struct 结构体名 &#123; 成员列表&#125; 变量名列表; 例如： 12345struct Book &#123; char author[10]; char name[20]; double price; &#125; book1,book2;//声明struct Book类型的同时定义了两个struct Book类型的变量book1,book2 个人觉得，把上面的申明类型同时定义变量，变成如下形式来看，可能更易于理解： 1struct Book&#123;char author[10];char name[20];double price;&#125; book1,book2; 这样看，是不是特别类似于普通变量的定义，前面是类型，后面是变量列表。当然你也可以通过其他的方式来记住结构体类型，不管黑猫白猫能抓到老鼠就是好猫&gt;_&lt;。 3.不指定类型名而直接定义结构体类型变量 其一般形式如下： 123struct &#123; 成员列表&#125; 变量名列表; 例如： 12345struct &#123; char author[10]; char name[20]; double price; &#125; book1,book2; 可以看到，这种方法指定了一个匿名的结构体类型，它没有名字，因此不能再以此结构体类型去定义其他变量。这种方式用的不多。 结构体变量的初始化和引用初始化结构体变量在定义结构体变量时，可以对它初始化，即赋予初始值。 先看一个例子 12345678910#include &lt;stdio.h&gt;int main() &#123; struct Book &#123; char author[10]; char name[20]; double price; &#125; book = &#123;"谭浩强","C程序设计",33.00&#125;; printf("作者：%s，书名：%s，价格：%f\n",book.author,book.name,book.price); return 0;&#125; 输出结果: 1作者：谭浩强，书名：C程序设计，价格：33.000000 从上例可以看出，初始化列表是用花括号括起来的一些常量，这些常量依次赋给结构体变量中的各成员。 如果我只想对某一成员初始化怎么办呢？ C99标准允许对某一成员初始化，如： 1234567891011#include &lt;stdio.h&gt;int main() &#123; struct Book &#123; char author[10]; char name[20]; double price; &#125; book = &#123;.price = 33.00&#125;; //在成员名前有成员运算符".",".price"隐含代表结构体变量book的成员book.price printf("作者：%s，书名：%s，价格：%f\n",book.author,book.name,book.price); return 0;&#125; 输出结果： 1作者：，书名：，价格：33.000000 其他未被初始化的成员由系统赋默认值，数值型为0，字符型为’\0’，指针型成员为NULL 引用结构体变量中的成员引用方式为 1结构体变量名.成员名 其中，“.”是成员运算符，它在所有的运算符中优先级最高 结构体数组定义结构体数组的一般形式： ①直接定义 123struct 结构体名 &#123; 成员列表&#125; 数组名[数组长度]; ②先声明结构体类型，再用此类型定义结构体数组 1结构体类型 数组名[数组长度]; 示例： 12345678910111213#include &lt;stdio.h&gt;int main() &#123; struct Book&#123; char author[16]; char name[25]; double price; &#125; book[2] = &#123;&#123;"谭浩强","C程序设计",33.00&#125;,&#123;"明日科技","Java从入门到精通",55.51&#125;&#125;; const int n = 2;//定义常变量,const 类似于Java中的 final for(int i = 0 ; i &lt; n ;i++) &#123; printf("作者：%s，书名：%s，价格：%f\n",book[i].author,book[i].name,book[i].price); &#125; return 0;&#125; 输出结果： 12作者：谭浩强，书名：C程序设计，价格：33.000000作者：明日科技，书名：Java从入门到精通，价格：55.510000 需要注意的是，在上面代码的第7行，给数组初始化的时候，每本书的信息，我用一对花括号包起来了，这样做的目的是方便阅读和检查。事实上，下面的代码也是可行的，但不推荐 12345struct Book&#123; char author[16]; char name[25]; double price;&#125; book[2] = &#123;"谭浩强","C程序设计",33.00,"明日科技","Java从入门到精通",55.51&#125;; 结构体指针结构体指针变量的定义和引用，与普通的指针变量一样。 示例: 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Book&#123; char author[16]; char name[25]; double price;&#125;;int main() &#123; struct Book book; struct Book * p = &amp;book;//定义结构体指针变量p并让其指向book strcpy(book.author,"谭浩强"); //这里不能直接写book.name = "C程序设计";，会报错，必须通过c语言提供的字符串赋值函数赋值 strcpy(book.name,"C程序设计"); book.price = 33.00; printf("作者：%s，书名：%s，价格：%f\n",book.author,book.name,book.price); printf("作者：%s，书名：%s，价格：%f\n",(*p).author,(*p).name,(*p).price); return 0;&#125; 输出结果： 12作者：谭浩强，书名：C程序设计，价格：33.000000作者：谭浩强，书名：C程序设计，价格：33.000000 需要注意的是,”.”的优先级高于“*”，所以必须用括号将*p括起来，即使用(*p).author这种形式。 为了使用方便和直观，C语言允许把(*p).author用p-&gt;author来代替，“-&gt;”称为指向运算符，p-&gt;author表示p所指向的结构体变量中的author成员。(这里很重要，C语言中最常见的就是”-&gt;”) 用-&gt;改写上面的代码： 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Book&#123; char author[16]; char name[25]; double price;&#125;;int main() &#123; struct Book book; struct Book * p = &amp;book; strcpy(book.author,"谭浩强"); strcpy(book.name,"C程序设计"); book.price = 33.00; printf("作者：%s，书名：%s，价格：%f\n",book.author,book.name,book.price); printf("作者：%s，书名：%s，价格：%f\n",p-&gt;author,p-&gt;name,p-&gt;price); return 0;&#125; 输出结果： 12作者：谭浩强，书名：C程序设计，价格：33.000000作者：谭浩强，书名：C程序设计，价格：33.000000]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析作业之自己实现Java双链表]]></title>
    <url>%2F2018%2F05%2F27%2Fdata-structure-and-algorithm-analysis-homework-doublelinkedlist-in-java%2F</url>
    <content type="text"><![CDATA[自己实现的Java双链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245package com.hegongshan.collections;import java.util.NoSuchElementException;/** * 双链表 * @author hegongshan https://www.hegongshan.com * @param &lt;E&gt; */public class DoubleLinkedList&lt;E&gt; &#123; private int size = 0; private Node&lt;E&gt; first; private Node&lt;E&gt; last; private static class Node&lt;E&gt; &#123; Node&lt;E&gt; prev; E data; Node&lt;E&gt; next; Node(Node&lt;E&gt; prev, E data, Node&lt;E&gt; next) &#123; super(); this.prev = prev; this.data = data; this.next = next; &#125; &#125; public DoubleLinkedList()&#123; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return first == null; &#125; public boolean add(E e) &#123; linkLast(e); return true; &#125; public void add(int index,E e) &#123; checkPositionIndex(index); if(index == size) &#123; linkLast(e); &#125; else &#123; linkBefore(e,node(index)); &#125; &#125; public E get(int index) &#123; checkElementIndex(index); return node(index).data; &#125; public E getFirst() &#123; if(first == null) &#123; throw new NoSuchElementException(); &#125; return first.data; &#125; public E getLast() &#123; if(last == null) &#123; throw new NoSuchElementException(); &#125; return last.data; &#125; public E set(int index,E e) &#123; checkElementIndex(index); Node&lt;E&gt; node = node(index); E oldValue = node.data; node.data = e; return oldValue; &#125; public E remove(int index) &#123; checkElementIndex(index); Node&lt;E&gt; node = node(index); node.prev.next = node.next; node.next.prev = node.prev; E e = node.data; node.prev = null; node.next = null; node.data = null; size--; return e; &#125; public E removeFirst() &#123; if(first == null) &#123; throw new NoSuchElementException(); &#125; Node&lt;E&gt; node = first; E e = node.data; first = node.next; node.next = null; node.data = null; if(first == null) &#123; last = null; &#125; else &#123; first.prev = null; &#125; size--; return e; &#125; public E removeLast() &#123; if(last == null) &#123; throw new NoSuchElementException(); &#125; Node&lt;E&gt; node = last; E e = node.data; last = node.prev; node.prev = null; node.data = null; if(last == null) &#123; first = null; &#125; else &#123; last.next = null; &#125; size--; return e; &#125; public void clear() &#123; for(Node&lt;E&gt; node = first;node != null;) &#123; Node&lt;E&gt; next = node.next; node.prev = null; node.data = null; node.next = null; node = next; &#125; first = last = null; size = 0; &#125; public void reverse() &#123; Node&lt;E&gt; temp = first; first = last; last = temp; &#125; public boolean contains(Object obj) &#123; return indexOf(obj) != -1; &#125; public int indexOf(Object obj) &#123; int index = 0; if(obj == null) &#123; for(Node&lt;E&gt; node = first;node != null;node = node.next) &#123; if(node.data == null) &#123; return index; &#125; index++; &#125; &#125; else &#123; for(Node&lt;E&gt; node = first;node != null;node = node.next) &#123; if(obj.equals(node.data)) &#123; return index; &#125; index++; &#125; &#125; return -1; &#125; public int lastIndexOf(Object obj) &#123; int index = size - 1; if(obj == null) &#123; for(Node&lt;E&gt; node = last;node != null;node = node.prev) &#123; if(node.data == null) &#123; return index; &#125; index--; &#125; &#125; else &#123; for(Node&lt;E&gt; node = last;node != null;node = node.prev) &#123; if(obj.equals(node.data)) &#123; return index; &#125; index--; &#125; &#125; return -1; &#125; public void linkFirst(E e) &#123; Node&lt;E&gt; node = new Node&lt;&gt;(null,e,first); first.prev = node; first = node; size++; &#125; private void linkBefore(E e,Node&lt;E&gt; node) &#123; Node&lt;E&gt; newNode = new Node&lt;&gt;(node.prev,e,node); node.prev.next = newNode; node.prev = newNode; size++; &#125; public void linkLast(E e) &#123; if(size == 0) &#123; first = new Node&lt;&gt;(null,e,null); last = first; size++; return ; &#125; Node&lt;E&gt; node = new Node&lt;E&gt;(last,e,null); last.next = node; last = node; size++; &#125; private Node&lt;E&gt; node(int index) &#123; checkElementIndex(index); if(index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; node = first; for(int i = 0 ; i &lt; index ; i++) &#123; node = node.next; &#125; return node; &#125; else &#123; Node&lt;E&gt; node = last; for(int i = size - 1 ; i &gt; index ; i--) &#123; node = node.prev; &#125; return node; &#125; &#125; private void checkElementIndex(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IndexOutOfBoundsException("index:" + index + ",size:" + size); &#125; &#125; // 可以添加结点的位置，索引从0开始到size private void checkPositionIndex(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IndexOutOfBoundsException("index:" + index + ",size:" + size); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法分析:Java语言描述</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析作业之自己实现Java单链表]]></title>
    <url>%2F2018%2F05%2F26%2Fdata-structure-and-algorithm-analysis-homework-singlelinkedlist-in-java%2F</url>
    <content type="text"><![CDATA[自己实现的Java单链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270package com.hegongshan.collections;import java.util.NoSuchElementException;/** * 单链表 * @author hegongshan https://www.hegongshan.com * @param &lt;E&gt; */public class SingleLinkedList&lt;E&gt; &#123; private int size = 0; private Node&lt;E&gt; first; public SingleLinkedList() &#123; &#125; // 单链表中元素个数 public int size() &#123; return size; &#125; // 判断单链表是否为空 public boolean isEmpty() &#123; return first == null; &#125; public boolean contains(Object obj) &#123; return indexOf(obj) != -1; &#125; public Object[] toArray() &#123; if (isEmpty()) &#123; return null; &#125; Object[] array = new Object[size]; Node&lt;E&gt; node = first; for (int i = 0; i &lt; size; i++) &#123; array[i] = node.data; node = node.next; &#125; return array; &#125; @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; return (T[]) toArray(); &#125; public boolean add(E e) &#123; linkLast(e); return true; &#125; // 在单链表尾部插入新的结点 public void linkLast(E e) &#123; if (!isEmpty()) &#123; Node&lt;E&gt; newNode = new Node&lt;&gt;(e, null); Node&lt;E&gt; last = first; while (last.next != null) &#123; last = last.next; &#125; last.next = newNode; &#125; else &#123; first = new Node&lt;&gt;(e, null); &#125; size++; &#125; // 在单链表头部插入新的数据 public void linkFirst(E e) &#123; Node&lt;E&gt; newNode = new Node&lt;&gt;(e, first); first = newNode; size++; &#125; // 清空单链表 public void clear() &#123; for (Node&lt;E&gt; node = first; node != null;) &#123; Node&lt;E&gt; next = node.next; node.data = null; node.next = null; node = next; &#125; first = null; size = 0; &#125; public E get(int index) &#123; checkElementIndex(index); return node(index).data; &#125; public E getFirst() &#123; if(first == null) &#123; throw new NoSuchElementException(); &#125; return first.data; &#125; // 把索引号为index的结点的数据改为element，并返回原来的结点数据 public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; node = node(index); E oldElement = node.data; node.data = element; return oldElement; &#125; // 在指定索引处插入元素 public void add(int index, E element) &#123; checkPositionIndex(index); if (index == 0) &#123; linkFirst(element); return; &#125; Node&lt;E&gt; newNode = new Node&lt;&gt;(element, null); Node&lt;E&gt; node = first; for (int i = 0; i &lt; index - 1; i++) &#123; node = node.next; &#125; newNode.next = node.next; node.next = newNode; size++; &#125; // 删除指定索引的结点，并返回该结点的数据值 public E remove(int index) &#123; checkElementIndex(index); Node&lt;E&gt; node = first; for (int i = 0; i &lt; index - 1; i++) &#123; node = node.next; &#125; Node&lt;E&gt; removeNode = node.next; node.next = removeNode.next; E e = removeNode.data; removeNode.data = null; removeNode.next = null; return e; &#125; //反转单链表pre-&gt;p-&gt;next public void reverse() &#123; Node&lt;E&gt; pre = first; Node&lt;E&gt; p = first.next; Node&lt;E&gt; next = null; pre.next = null; while(p != null) &#123; next = p.next; p.next = pre; pre = p; p = next; &#125; first = pre; &#125; // 给定数据在单链表中首次出现的位置 public int indexOf(Object obj) &#123; int index = 0; if (obj == null) &#123; for (Node&lt;E&gt; node = first; node != null; node = node.next) &#123; if (node.data == null) &#123; return index; &#125; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; node = first; node != null; node = node.next) &#123; if (obj.equals(node.data)) &#123; return index; &#125; index++; &#125; &#125; return -1; &#125; // 给定数据在单链表中最后一次出现的位置 public int lastIndexOf(Object obj) &#123; int index = 0; int i = 0; int[] array = new int[size]; if (obj == null) &#123; for (Node&lt;E&gt; node = first; node != null; node = node.next) &#123; if (node.data == null) &#123; array[i++] = index; &#125; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; node = first; node != null; node = node.next) &#123; if (obj.equals(node.data)) &#123; array[i++] = index; &#125; index++; &#125; &#125; if (array.length != 0) &#123; return array[i - 1]; &#125; return -1; &#125; /*public int lastIndexOf(Object obj) &#123; Object[] array = toArray(); if(obj == null) &#123; for(int i = array.length -1;i&gt;=0;i--) &#123; if(array[i] == null) &#123; return i; &#125; &#125; &#125; else &#123; for(int i = array.length -1;i&gt;=0;i--) &#123; if(obj.equals(array[i])) &#123; return i; &#125; &#125; &#125; return -1; &#125;*/ @Override public String toString() &#123; StringBuilder list = new StringBuilder("["); Node&lt;E&gt; node = first; int index = 0; while (node != null) &#123; index++; if (index == size) &#123; list.append(node.data); &#125; else &#123; list.append(node.data).append(","); &#125; node = node.next; &#125; list.append("]"); return list.toString(); &#125; private Node&lt;E&gt; node(int index) &#123; checkElementIndex(index); Node&lt;E&gt; node = first; for(int i = 0 ; i &lt; index ;i++) &#123; node = node.next; &#125; return node; &#125; private static class Node&lt;E&gt; &#123; private E data; private Node&lt;E&gt; next; Node(E data, Node&lt;E&gt; next) &#123; this.data = data; this.next = next; &#125; &#125; // 单链表中的结点索引从0开始到size-1 private void checkElementIndex(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IndexOutOfBoundsException("index:" + index + ",size:" + size); &#125; &#125; // 可以添加结点的位置，索引从0开始到size private void checkPositionIndex(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IndexOutOfBoundsException("index:" + index + ",size:" + size); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法分析:Java语言描述</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析C语言指针]]></title>
    <url>%2F2018%2F05%2F26%2Fc-pointer%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;指针是一个地址，而指针变量是存放地址的变量。 定义指针变量定义指针变量的一般形式： 类型名 * 指针变量名; 如： 1int * p1,* p2; 引用指针变量相关运算符 &amp;&nbsp;&nbsp;&nbsp;取地址运算符，&amp;a是变量a的地址 *&nbsp;&nbsp;&nbsp;&nbsp;指针运算符，*p代表指针变量p指向的对象 给指针变量赋值（指针变量的值只能是地址） 1p = &amp;a;//把a的地址赋给指针变量p，p指向a 引用指针变量指向的变量 123int * p,a = 10;p = &amp;a;printf("%d",*p);//其中*p等价于a 这里*p出现了两次，但是二者的含义完全不同。第一行中的*p表示定义了一个指针变量*p，其前面的*只是表示该变量是一个指针变量。而第三行中的*p则代表指针变量p所指向的变量a。 引用指针变量的值。如： 1printf("%d",p);//以八进制数的形式输出指针变量p的值，如果p指向了a，就是输出a的地址，即&amp;a。 示例： 1234567891011#include &lt;stdio.h&gt;int main()&#123; int a = 100,b = 90; int * p1, * p2; p1 = &amp;a; p2 = &amp;b; printf("a = %d,b = %d\n",a,b); printf("* p1 = %d,* p2 = %d",*p1,*p2); return 0;&#125; 输出： 12a = 100,b = 90* p1 = 100,* p2 = 90 这里指针变量p1指向a，指针变量p2指向b，因此*p1等价于a，*p2等价于b 指针变量的好处C语言中，实参变量和形参变量之间的数据传递是单向的“值传递”方式。函数的调用可以（且只可以）得到一个返回值，而使用指针变量作参数，可以得到多个变化了的值。虽然不能改变实参指针变量的值，但是可以改变实参指针变量所指向的变量的值。]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析作业之自己实现Java顺序表]]></title>
    <url>%2F2018%2F05%2F25%2Fdata-structure-and-algorithm-analysis-homework-arraylist%2F</url>
    <content type="text"><![CDATA[自己实现的Java顺序表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195package com.hegongshan.collections;/** * 顺序表 * @author hegongshan https://www.hegongshan.com * @param &lt;E&gt; */public class ArrayList&lt;E&gt; &#123; private static final int DEFAULT_CAPACITY = 10; private Object[] elementData; private int size = 0; public ArrayList() &#123; this(DEFAULT_CAPACITY); &#125; public ArrayList(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException("Illegal Capacity: " + capacity); &#125; elementData = new Object[capacity]; &#125; // 返回顺序表中的元素个数 public int size() &#123; return size; &#125; // 是否为空 public boolean isEmpty() &#123; return size == 0; &#125; // 添加元素 public boolean add(E e) &#123; ensureCapacity(); elementData[size] = e; size++; return true; &#125; // 根据索引号添加元素 public void add(int index, E e) &#123; checkPositionIndex(index); ensureCapacity(); for (int i = size - 1; i &gt;= index; i--) &#123; elementData[i + 1] = elementData[i]; &#125; elementData[index] = e; size++; &#125; // 删除指定索引处的元素 @SuppressWarnings("unchecked") public E remove(int index) &#123; checkElementIndex(index); E oldValue = (E) elementData[index]; for (int i = size - 1; i &gt; index; i--) &#123; elementData[i - 1] = elementData[i]; &#125; elementData[--size] = null;// 最后一个元素变为null return oldValue; &#125; // 删除指定元素值首次出现的那个元素 public boolean remove(Object obj) &#123; int index = indexOf(obj); if (index != -1) &#123; remove(index); return true; &#125; return false; &#125; // 根据索引号获取元素 @SuppressWarnings("unchecked") public E get(int index) &#123; checkElementIndex(index); return (E) elementData[index]; &#125; // 改变指定索引号的元素值 public void set(int index, E e) &#123; checkElementIndex(index); elementData[index] = e; &#125; public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = 0; &#125; // 去掉多余的容量 public void trimToSize() &#123; if (size &lt; elementData.length) &#123; if (size == 0) &#123; return; &#125; Object[] newElementData = new Object[size]; for (int i = 0; i &lt; size; i++) &#123; newElementData[i] = elementData[i]; &#125; elementData = newElementData; &#125; &#125; // 是否包含某一元素 public boolean contains(Object obj) &#123; return indexOf(obj) != -1; &#125; // 某一元素首次出现的位置 public int indexOf(Object obj) &#123; if (obj == null) &#123; for (int i = 0; i &lt; size; i++) &#123; if (elementData[i] == null) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; size; i++) &#123; if (obj.equals(elementData[i])) &#123; return i; &#125; &#125; &#125; return -1; &#125; // 某一元素最后一次出现的位置 public int lastIndexOf(Object obj) &#123; if (obj == null) &#123; for (int i = size - 1; i &gt;= 0; i--) &#123; if (elementData[i] == null) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = size - 1; i &gt;= 0; i--) &#123; if (obj.equals(elementData[i])) &#123; return i; &#125; &#125; &#125; return -1; &#125; // 确保容量，如果实际的元素个数大于等于容量，则扩容 private void ensureCapacity() &#123; if (size &gt;= elementData.length) &#123; grow(); &#125; &#125; // 扩容，每次增加原来一半的容量 private void grow() &#123; // 右移的时候一定要加括号，&gt;&gt;的优先级低于+， // 为了避免size为0，取扩容后的size和默认容量两者的最大值为新的容量 int newCapacity = Math.max(size + (size &gt;&gt; 1), DEFAULT_CAPACITY); Object[] newElementData = new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newElementData[i] = elementData[i]; &#125; elementData = newElementData; &#125; // 判断索引值是否为正确的元素索引 private void checkElementIndex(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IndexOutOfBoundsException("index:" + index + ",size:" + size); &#125; &#125; // 可以添加元素的位置，索引从0开始到size private void checkPositionIndex(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IndexOutOfBoundsException("index:" + index + ",size:" + size); &#125; &#125; @Override public String toString() &#123; StringBuilder list = new StringBuilder(); list.append("ArrayList ["); for (int i = 0; i &lt; size; i++) &#123; list.append(elementData[i]); if (i &lt; size - 1) &#123; list.append(','); &#125; &#125; list.append("]"); return list.toString(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法分析:Java语言描述</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java网络爬虫之HttpURLConnection实战]]></title>
    <url>%2F2018%2F05%2F21%2Fjava-spider-httpurlconnection-in-action%2F</url>
    <content type="text"><![CDATA[在开始写爬虫之前，我们先来总结一下用HttpURLConnection写爬虫的操作步骤： 1.实例化一个URL，调用URL类的openConnection()方法获得URLConnection对象，并强转为HttpURLConnection对象 12URL url = new URL("http://host/path");HttpURLConnection connection = (HttpURLConnection) url.openConnection(); 2.设置连接的请求属性，诸如，setRequestProperty、setConnectionTimeout、setReadTimeout等 3.调用connect()方法连接远程资源 1connection.connect(); 4.访问资源数据。使用getInputStream方法获取一个输入流用以读取信息。如果服务器端出现错误，调用getErrorStream()方法获取错误信息。 12345try&#123; connection.getInputStream();&#125; catch(Exception e) &#123; connection.getErrorStream();&#125; 5.调用disconnect()关闭连接 1connection.disconnect(); 6.解析需要的数据。 这里以爬取百度首页为例， GET请求爬取百度首页源码1234567891011121314151617181920URL url = new URL("https://www.baidu.com");HttpURLConnection connection = (HttpURLConnection) url.openConnection();connection.setConnectTimeout(10000);connection.setRequestMethod("GET");connection.connect();InputStream is = connection.getInputStream();BufferedReader br = new BufferedReader(new InputStreamReader(is,"utf-8"));String temp;StringBuilder html = new StringBuilder();while((temp = br.readLine()) != null) &#123; if(temp.trim().isEmpty()) &#123; continue; &#125; //格式化html html.append(temp.replaceAll("\\s+&lt;", "&lt;").replace("&gt;", "&gt;\n"));&#125;br.close();is.close();connection.disconnect();System.out.println(html); 控制台输出如下信息： 设置用户代理，再爬百度首页上面的程序，我们稍微改一下，在setRequestProperty方法中设置下User-Agent，看下会出现什么神奇的变化？因为输出的内容有点多，我把它写入到一个html文件中了，而不是直接打印在控制台。 1234567891011121314151617181920212223242526272829303132URL url = new URL("https://www.baidu.com");HttpURLConnection connection = (HttpURLConnection) url.openConnection();connection.setConnectTimeout(10000);connection.setRequestMethod("GET");connection.setDoInput(true);connection.setDoOutput(false);connection.setRequestProperty("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36");connection.connect();InputStream is = connection.getInputStream();BufferedReader br = new BufferedReader(new InputStreamReader(is,"utf-8"));String temp;BufferedWriter bw = new BufferedWriter(new FileWriter(new File("c:/Users/hgs/Desktop/baidu_index.html"),true));while((temp = br.readLine()) != null) &#123; temp = temp.trim(); if(temp.isEmpty()) &#123; continue; &#125; //格式化输出，便于在浏览器中查看 temp = temp.replaceAll("\\s+&lt;", "&lt;") .replace("&lt;", "&amp;lt;") .replace("&gt;", "&amp;gt;&lt;br&gt;") .replace("&amp;lt;/","&lt;br&gt;&amp;lt;/") .replace("&#123;", "&#123;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;") .replace("&#125;", "&lt;br&gt;&#125;&lt;br&gt;") .replaceAll("[^\\&amp;(nbsp|gt|lt)];[^\"']", ";&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"); bw.write(temp);&#125;bw.flush();bw.close();br.close();is.close();connection.disconnect(); 响应结果： 响应结果似乎与刚才不一样了，多出了很多内容。这是因为，默认情况下，Java程序会发送包含单词Java的通用用户代理字符串，而有些服务器可能存在反爬虫机制，不想为程序自动产生的请求服务。这时候，我们可在请求头中设置User-Agent，以达到伪装浏览器的目的。 带参数的get请求到这里我们已经能爬到完整的百度首页了，但这似乎没有什么用处。 现在我们试试通过程序自动查询百度，并获取第一页的查询结果。。。（未完待续）]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网络爬虫之详解HttpURLConnection]]></title>
    <url>%2F2018%2F05%2F21%2Fjava-spider-httpurlconnection%2F</url>
    <content type="text"><![CDATA[在Java.net包下有一个类HttpURLConnection，其继承结构如下： 1public abstract class HttpURLConnection extends URLConnection 它的父类URLConnection也是一个抽象类。要想取得URLConnection对象，只能通过java.net.URL下的如下方法： 12public URLConnection openConnection() throws java.io.IOException;public URLConnection openConnection(Proxy proxy) throws java.io.IOException; URLConnection主要的成员方法： 12345678910111213141516171819202122232425//设置建立连接后，产生从服务器读取信息的输入流，默认为truepublic void setDoInput(boolean doinput);//默认情况下，建立连接后不会产生执行写操作的输出流，如果想要获得输出流，//则将dooutput设置为true，主要用于post请求public void setDoOutput(boolean dooutput);public void setIfModifiedSince(long ifmodifiedsince);public void setUseCaches(boolean usecaches);public void setAllowUserInteraction(boolean allowuserinteraction);public void setRequestProperty(String key, String value);public void setConnectTimeout(int timeout);public void setReadTimeout(int timeout);public String getHeaderField(String name);public String getHeaderField(int n);public String getHeaderFieldKey(int n);public int getContentLength();public String getContentType();public String getContentEncoding();public long getExpiration()public long getLastModified();public URL getURL();public abstract void connect() throws IOException; 12 在setRequestProperty()方法中可以设置请求头信息。请求头信息将和请求命令一起被发送到服务器，例如： 12345678910Accept:image/webp,image/apng,image/*,*/*;q=0.8Accept-Encoding:gzip, deflate, brAccept-Language:zh-CN,zh;q=0.8Cache-Control:no-cacheConnection:keep-aliveCookie:Host:sp1.baidu.comPragma:no-cacheReferer:https://www.baidu.comUser-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36 如何查看有哪些头信息可以设置呢？这里以百度首页为例，我用的chrome浏览器（其他浏览器大同小异），按F12打开开发者工具，选择网络（network），然后刷新一下正在浏览的页面，可以看到很多的图片、css、js等，随便点开一个，右侧的Request Headers下的信息，就是请求头信息。 HttpURLConnection主要的扩展方法： 12345678910//method必须写大写字母public void setRequestMethod(String method) throws ProtocolException;public int getResponseCode() throws IOException;public String getResponseMessage() throws IOException;public InputStream getErrorStream();public static void setFollowRedirects(boolean set);public void setInstanceFollowRedirects(boolean followRedirects);public abstract void disconnect(); 值得注意的是，setRequestMethod方法的参数必须写大写，以GET请求为例，如果写小写，会报如下错误： 123Exception in thread "main" java.net.ProtocolException: Invalid HTTP method: getat java.net.HttpURLConnection.setRequestMethod(Unknown Source)at sun.net.www.protocol.http.HttpURLConnection.setRequestMethod(Unknown Source) 支持的HTTP请求为GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE，默认为GET请求。 若为POST请求，则需要设置setDoOutput(boolean dooutput)为true，否则会报如下错误： 1234Exception in thread "main" java.net.ProtocolException: cannot write to a URLConnection if doOutput=false - call setDoOutput(true) at sun.net.www.protocol.http.HttpURLConnection.getOutputStream0(Unknown Source) at sun.net.www.protocol.http.HttpURLConnection.getOutputStream(Unknown Source) at sun.net.www.protocol.https.HttpsURLConnectionImpl.getOutputStream(Unknown Source) （未完待续）]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下搭建nginx和tomcat整合开发环境]]></title>
    <url>%2F2018%2F05%2F19%2Fwindows-nginx-tomcat-development-environment%2F</url>
    <content type="text"><![CDATA[遇到的问题越多，人成长的越快。算下日子，接手课题组的项目，已经一月有余。期间碰到了很多问题，也一直在积极面对。 问题引出接手课题组的项目后，遇到过一个很严重的问题：项目在本地tomcat上能完美运行，但是到了服务器上，就出问题了——JSP文件中el表达式${pageContext.request.contextPath}取到的上下文路径始终为空，即***“”。由于之前深受项目必须使用绝对路径这一思想的影响，我在JSP文件中定义了如下变量，用来表示外部js文件中的ajax请求地址的前缀。 123&lt;script src="text/javascript"&gt; var contextPath = "$&#123;pageContext.request.contextPath&#125;";&lt;/script&gt; 对于一个常规的java web项目，我们在部署到服务器tomcat中的时候，一般会先配置server.xml文件 12345678910111213141516171819&lt;!--端口号改为80--&gt;&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;&lt;!--defaultHost和主机的name均改为项目的域名--&gt;&lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase"/&gt; &lt;/Realm&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;!--如果项目名不为ROOT，还要配置Context--&gt; &lt;!--&lt;Context docBase="" path=""/&gt;--&gt; &lt;/Host&gt;&lt;/Engine&gt; 但是，最开始不知道的是，服务器上使用了nginx作为反向代理服务器，所有的http请求，都由nginx转发给tomcat，tomcat的server.xml根本就没有配置（或者说是使用了默认配置），这就很好的解释了为什么${pageContext.request.contextPath}为空了，因为项目名为ROOT的项目，默认的path就是空。 当时的解决办法是，把上面jsp中定义的js变量contextPath直接改为项目域名。这样一改，域名是写死的，不带www前缀的时候，出现了ajax跨域。 后来想想，干脆直接改为“.”，也就是用相对路径。这样一改，似乎解决了原来的问题。但这只是假象，一旦原来的路径多起来，”.”表示与当前页面同级，ajax请求的地址可能就不对了。 最后干脆弃用${pageContext.request.contextPath}，所有的请求以”/“开头，并且为了防止再出现本机运行效果和服务器上运行效果不一致的情况，我在我的电脑上搭建了nginx和tomcat整合开发环境。 废话不多说了，赶紧进入正题。 安装nginx首先，从nginx官网下载最新的稳定版nginx，下载地址 当前最新的稳定版本是1.14.0，根据自己的操作系统选择对应的版本，我这里选择nginx/Windows-1.14.0 下载下来后，直接解压缩就可以了，下面是解压后的目录结构 启动nginx 启动nginx有两种方式，一是点击nginx.exe直接启动，二是在命令行模式下切换到nginx解压目录（当然，也可以将nginx路径添加到系统环境变量path中，以后就不需要切换到解压目录那么麻烦了），使用命令 start nginx来启动nginx（推荐使用这种方法）。 进入命令行模式，切换到nginx解压目录，我直接解压在桌面上了，输入start nginx，屏幕一闪，然后出现下一个命令行，这就表示nginx已经启动啦。 现在我们来测试下nginx是不是真的成功启动了，在浏览器里输入localhost，不出意外的话应该会出现nginx的欢迎页面。 关闭nginx 使用命令nginx.exe -s stop来关闭nginx 重启nginx 使用命令nginx.exe -s reload来重启nginx 配置nginx 在conf目录下有一个叫做nginx.conf文件，这是nginx的配置文件。 这里我不会详细讲nginx.conf中的各种配置（因为我现在也不会啊^_^），以后会专门开一个系列来讲nginx以及Linux上nginx和tomcat实现反向代理和负载均衡。 主要来看下与开发环境搭建相关的server的配置 1234567891011121314151617181920212223#配置虚拟主机server &#123; listen 80; #指定需要nginx监听的端口 server_name localhost; #需要访问的域名 #charset koi8-r; #access_log logs/host.access.log main; #转发 location / &#123; root html; #指定根目录 index index.html index.htm; #指定首页及优先顺序 &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 主要需要改下location /里面的配置 1234location / &#123; proxy_pass http://localhost:8080; # proxy_pass 指定被代理服务器的URL proxy_set_header Host $host; # 将nginx接收到的请求头信息中的host转发给被代理服务器&#125; 到这里，nginx就基本配置好了。 配置eclipse（可选）在eclipse中运行我们的项目，然后修改eclipse引入的tomcat配置文件server.xml 1234&lt;!--eclipse默认情况下会用项目名作为上下文路径，这里我们改为空或者/，不改的话，访问的时候需要加上项目名--&gt;&lt;Context docBase="demo" path="" reloadable="true" source="org.eclipse.jst.jee.server:course"/&gt; 我们在浏览器中直接访问localhost，看能否访问到我们的项目 出现了Hello World! 这表明nginx确实把我们的请求转发给了tomcat。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL模糊查询并高亮显示查询结果]]></title>
    <url>%2F2018%2F05%2F14%2Fsql-fuzzy-query-and-highlight-keyword%2F</url>
    <content type="text"><![CDATA[最近在完善课题组的项目时，遇到了一个问题：项目有个论坛模块，需要实现根据用户输入的关键字检索论坛文章，然后高亮显示检索结果。 本来遇到这个需求，第一反应是用lucene来做全文检索。但是，lucene只是一个全文检索工具包，要用它实现全文检索，需要写一大堆的代码，加之虽然之前用过几次lucene，但是对lucene的API还是不太熟。想想还是算了，等以后专门研究一下lucene再说吧。 有朋友可能要问了：为什么不用solr或者elasticsearch？还不是因为不熟，再说了，一个solr一百多兆，我这就是个小项目，没必要啊。思来想去，最后还是决定就用sql的模糊查询like实现。 表结构是这样的 123456789create table article( id bigint unsigned not null auto_increment, title varchar(255) not null, summary varchar(255) not null, is_public tinyint(1) unsigned not null default 1 comment "是否公开，1表示公开，0表示私密", gmt_create datetime not null, ..., primary key(id)) 这里以检索“作业“为例，只查询公开的文章，并且按照发表时间降序排列，SQL是这样写的 12345select id,title,summary,gmt_create,... from articlewhere is_public = 1 and (title like "%作业%" or summary like "%作业%")order by gmt_create desclimit 0,10; 这样做确实能实现模糊查询了，但是又一个问题来了：如何实现检索结果高亮显示呢？ 寻思了很久，也没想到解决办法。后来灵机一动，想到干嘛不在返回字段的时候在关键字的前后插入一些html标签，或者直接替换返回字段中的关键字，这不就实现高亮显示了吗？于是SQL就成了下面这样。 12345678select id,replace(title,"作业",concat("&lt;font color='red'&gt;&lt;b&gt;","作业","&lt;/b&gt;&lt;/font&gt;")) as title,replace(summary,"作业",concat("&lt;font color='red'&gt;&lt;b&gt;","作业","&lt;/b&gt;&lt;/font&gt;")) as summary,gmt_create,...from articlewhere is_public = 1 and (title like "%作业%" or summary like "%作业%")order by gmt_create desclimit 0,10; 当然，使用全模糊查询，然后通过替换关键字的方式实现检索结果高亮显示，从而实现全文检索，这种方法效率肯定不高。《阿里巴巴Java开发手册》中也明确禁止使用全模糊或左模糊查询，因为全模糊或者左模糊查询无法使用索引。]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux中存活下来之tar压缩和解压缩文件]]></title>
    <url>%2F2018%2F05%2F14%2Flinux-command-tar%2F</url>
    <content type="text"><![CDATA[最近需要在Linux服务器上解压tar.gz文件，于是乎学习了下tar命令的使用。 tar命令参数很多，暂时就只用到以下几个参数，其他的以后用到再补上。 参数说明： -c：全称create，用于创建文件 -v：全称verbose，用于显示详细的命令执行信息 -f：全称file，用于指定需要压缩或者解压缩的文件名 -x：用于解压文件 -C：切换到指定目录 -z：通过gzip命令处理文件。简单来说，如果需要压缩为*.gz文件，或者解压缩*.gz文件，就要带上-z 示例1.解压缩tar.gz文件 1tar -zxvf apache-tomcat-8.5.31.tar.gz 2.解压缩tar.gz文件到指定目录，这里以/usr/local目录为例 1tar -zxvf apache-tomcat-8.5.31.tar.gz -C /usr/local 3.将某个（些）目录或文件压缩为tar.gz文件 1tar -zcvf archive.tar.gz file1 file2 ... archive.tar.gz是生成的压缩文件名，file1、file2等是要压缩的文件和目录列表。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>压缩</tag>
        <tag>解压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux中存活下来之vi编辑器的使用]]></title>
    <url>%2F2018%2F05%2F11%2Flinux-vi%2F</url>
    <content type="text"><![CDATA[前话：学习vi编辑器，是一个循序渐进的过程，本篇是博主自己的学习总结，会持续更新。 简介vi编辑器有三种模式： 命令行模式：顾名思义，在这个模式下，所有的键盘操作都会被认为是命令。启动vi编辑器，就会进入命令行模式。 输入模式：除了按下“Esc”外，其他的键盘输入都不会被认为是命令。处于这个模式下，和我们在Windows中用Notepad等编辑文件，几乎没有区别。按下“Esc”，会退出输入模式，进入命令行模式。 末行模式：在命令模式下，输入“:”就会进入末行模式。 这里，博主总结下最近学习到的且经常使用的一些命令。 启动vivi fileName：进入编辑环境并打开或新建文件 命令行模式dd：删除光标所在行，并将当前行内容复制到剪贴板 p：全称paste，表示将剪贴板中的数据粘贴到光标当前位置 yy：复制光标所在行 进入输入模式 i：在命令模式下，在当前光标处进入输入模式 输入模式输入模式，类似于我们在Windows中编辑文件 方向键进行上下左右方向的光标移动 Backspace键：删除光标左侧的字符 delete键：删除光标右侧的字符 退出输入模式按下Esc键：从输入模式回到命令行模式 进入末行模式在命令行模式下，按下”:“就会进入末行模式。 退出viq：退出vi q!：不保存文件并退出vi w：保存文件 wq：保存文件并退出vi wq!：强制保存文件并退出vi（忽略只读）]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux中存活下来之文件与目录管理]]></title>
    <url>%2F2018%2F05%2F10%2Flinux-file-directory-manage%2F</url>
    <content type="text"><![CDATA[前话：最近接手了导师的一个项目，项目部署在Linux服务器上后，出了点小问题，需要修改一些文件。因为不是自己部署的，加之对linux命令不熟，怎么办？在本地修改完后，重新让别人帮忙部署？还是自己在服务器上手动修改？天生不喜欢求人，哈哈 总结一下最近常用的一些Linux基础命令，主要和文件、目录的操作相关 lsls，全称list，用于列出某个目录下的所有文件和目录。 cdcd，全称change directory，用于切换路径。估计大伙对cd这个命令都很熟，因为Windows上的命令行界面也是用的cd命令来切换路径。值得一提的是，”~”表示home目录，”..”表示回到当前目录的上一级目录 语法：cd [dirName] pwdpwd，全称print working directory，用于输出当前的工作目录名。 rmrm，全称remove，用于删除文件或目录。 语法：rm [options] name… 参数说明： -i 删除前逐一询问确认 -f 全称force，删除文件不需要询问 -r 全称recurse，递归删除目录下的所有文件 如果嫌上面的麻烦，那么我们简单粗暴点，删除文件用 rm [fileName]，删除目录用 rm -rf [dirName]，哈哈 cpcp，全称copy，用于复制文件或目录。 语法：cp [options] source… dest cp的参数比较多，这里只讲-r，其他的用到再现学。cp中的-r和rm中的-r意思差不多，都表示递归。主要用于目录复制。 简单粗暴版：复制单个文件用 cp source … dest，复制目录用 cp -r [dirName]&nbsp;[dirName] mvmv，具有rename和move两种功能，用于重命名文件或目录，或者将文件或目录移入另一个目录。 语法：mv source dest 简单来说，如果source和dest同为目录或者文件，且dest不存在，则将source重命名为dest，如果source文件，而dest为目录，则将source移到dest中 重命名文件 重命名目录 将文件移动另一个目录中 将目录移动到指定目录中 touchtouch，用于创建文件。如果文件已经存在，则更新文件的时间戳。 mkdirmkdir，全称make directory，用于创建目录。 语法：mkdir [options] dirName mkdir的参数暂时没用过，等用到了再补上。 rmdirrmdir，全称remove directory，用于删除空目录。 语法：rmdir [options] dirName 参数： -p：全称parents，删除指定的空目录后，若此时该目录的父目录已变成空目录，则将父目录一并删除。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式及Java对其的支持]]></title>
    <url>%2F2018%2F04%2F11%2Fjava-regular-expression%2F</url>
    <content type="text"><![CDATA[简述正则表达式​ 今天我们来讲下正则表达式，先来看下正则表达式中的数量表示 字符 说明 举例 ? 零次或一次匹配？前的字符或子表达式，等价于{0,1} gong(shan)?匹配gong或gongshan * 零次或多次匹配*前的字符或子表达式，等价于{0,} sm*匹配sm或者s + 一次或多次匹配*前的字符或子表达式，等价于{1,} zoo+匹配zoo或者zooo等 {n} n为非负整数，正好匹配n次 zo{2}匹配zoo {n,} n为非负整数，至少匹配n次 zo{1,}可匹配zo，zoo，zooo等 {n,m} n和m均为非负整数，表示至少匹配n次，至多匹配m次 zo{1,2}则只匹配zo或者zoo 常用特殊字符 字符 说明 举例 [xyz] 字符集。匹配包含的任一字符 [abc] 匹配 java 中的a [^xyz] 反字符集。匹配未被包含的任一字符 [^abc] 匹配 java 中的 j和v [x-y] 字符范围。匹配从x到y（指定范围内）的所有字符 [a-z]匹配从a到z的所有小写字母 \d 匹配一个数字，等价于[0-9] he\d{2} 匹配 he33 \D 匹配一个非数字，等价于[^0-9] he\D{4} 匹配 heyang \s 匹配任何空白字符 \S 匹配任何非空白字符 \w 匹配任何字类字符，包括下划线，等价于[a-zA-Z0-9_] \W 匹配任何非字类字符，等价于[^a-zA-Z0-9_] 常用逻辑操作 字符 说明 举例 xy x并y [xy] x&#124;y x或y [x&#124;y] (X) 将X定义为一个组 [xy(bc)]，(x&#124;y) 其他预定义字符以及不是特别常用的字符，详见 java正则表达式 java对正则表达式的支持在java中要想使用正则表达式，有三种方式： String类对正则表达式的支持 1public boolean matches(String regex) 单独使用java.util.regex.Pattern 1public static boolean matches(String regex, CharSequence input) java.util.regex包下的Pattern类配合Matcher类使用（推荐采用此方式） 下面我们依次来使用这三种方式： 第一种：String类对正则表达式的支持 matches(String regex) 123456public void testString() &#123; String str = "Java"; boolean flag = str.matches("(J|x)ava"); System.out.println(flag);&#125;输出结果：true 这种方式虽然也能实现正则匹配，但是功能单一，只能返回是否匹配，而且字符串必须整体匹配才能返回true，以下面的代码来说明这个问题 123456public void testString2() &#123; String str = "Java is a programming language."; boolean flag = str.matches("Java"); System.out.println(flag);&#125;输出结果：false 查看String类的源码可以发现，String类的matches方法实际上就是调用的下面要讲的第二种方式Pattern.matches(String regex,CharSequence input) 123public boolean matches(String regex) &#123; return Pattern.matches(regex, this);&#125; 第二种：单独使用Pattern进行正则匹配 1234567public void testPattern() &#123; String str = "Java is a programming language."; String regex = "Java"; boolean flag = Pattern.matches(regex, str); System.out.println(flag);&#125;输出结果：false 这里为什么也返回了false？原因和第一种方式一样，因为Pattern的静态方法matches(String regex,CharSequence input)也是整体匹配。实际上，如果我们去查看Pattern的源码的话，可以发现：12345public static boolean matches(String regex, CharSequence input) &#123; Pattern p = Pattern.compile(regex); Matcher m = p.matcher(input); return m.matches();&#125; 这种方式实际上使用的是下面的第三种方式 第三种：Pattern和Matcher的结合使用 1234567891011121314public void testPatternAndMatcher() &#123; String str = "I love Java and xava."; String regex = "(J|x)ava"; Pattern p = Pattern.compile(regex); Matcher m = p.matcher(str); System.out.println(m.matches()); while(m.find()) &#123; System.out.println(m.group()); &#125;&#125;输出结果：falseJavaxava 通过以上分析，我们可以发现，第一种方式是对第二种方式的调用，而第二种方式的实现又是采用的第三种方式。 因此，在以后的使用中，推荐直接使用第三种方式，其功能远强于第一种和第二种方式。 详解Pattern和MatcherPattern的常用方法如下： 12public static Pattern compile(String regex)public Matcher matcher(CharSequence input) 由于Pattern只有私有构造方法，我们不能直接实例化它，故每次必须通过其compile方法取得Pattern对象，继而通过matcher方法获取Matcher对象。 Matcher的常用方法 ①索引方法： 1234public int start()//返回之前匹配的起始索引public int start(int group)public int end()//返回最后匹配字符之后的偏移量，例如用\d&#123;4&#125;匹配he2018，则end()返回6public int end(int group) 实例如下： 12345678910111213141516import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String regex = "\\d&#123;4&#125;"; String str = "he2018shan0423yang11gong456shan"; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(str); while(matcher.find()) &#123; System.out.println("匹配字段："+matcher.group()); System.out.println("开始索引："+matcher.start()); System.out.println("结束索引："+matcher.end()); &#125; &#125;&#125; 输出结果： 123456匹配字段：2018开始索引：2结束索引：6匹配字段：0423开始索引：10结束索引：14 ②研究方法 1234public boolean find()public boolean find(int start)public boolean lookingAt()public boolean matches() ③替换方法 12345public static String quoteReplacement(String s)public Matcher appendReplacement(StringBuffer sb, String replacement)public StringBuffer appendTail(StringBuffer sb)public String replaceAll(String replacement)public String replaceFirst(String replacement) 附录常用的正则表达式 规则 正则表达式语法 电子邮箱 [\w!#$%^&amp;`+=/(&#124;)’?,~*-]+@([a-z0-9]+\.)+[a-z]+ 中文字符 [\u4e00-\u9fa5] QQ号 [1-9][0-9]{4,} 身份证号 \d{6}(19&#124;20)\d{2}((0[1-9])&#124;(1[0-2]))(([0-2]\d)&#124;(3[0-1]))\d{3}(\d&#124;x&#124;X){1}]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架源码阅读之栈Stack]]></title>
    <url>%2F2018%2F04%2F02%2Fjava-collections-api-stack%2F</url>
    <content type="text"><![CDATA[什么是栈？栈是限制插入和删除只能在一个位置上进行的表，它是一个后进先出(last-in-first-out，LIFO)表 本文是《Java集合框架源码阅读》系列的第三篇，我们来说说Java中的栈在Java Collections API中有一个类叫做java.util.Stack，它的继承结构如下：1public class Stack&lt;E&gt; extends Vector&lt;E&gt; 它是在java.util.Vector类的基础上扩展了5个方法而来的12345public E push(E item)//进栈public synchronized E pop()//出栈，返回栈顶元素并将其删除public synchronized E peek()//取得栈顶元素（不删除）public boolean empty()//判断是否为空栈public synchronized int search(Object o)//详见问题四 Stack本身是扩展Vector而来的，而Vector是一个可增长的对象数组（The Vector class implements a growable array of objects），那么这个数组的哪部分成为了Stack的栈顶和栈底呢？ 问题一：Stack的栈顶和栈底在哪里？我们先来观察peek()方法的源码：1234567public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1);&#125; 这里调用了父类Vector的elementAt(int index)方法1234567891011public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; return elementData(index);&#125;@SuppressWarnings("unchecked")E elementData(int index) &#123; return (E) elementData[index];&#125; 通过观察以上源码，我们可以发现：调用peek()方法时，实际返回的是数组elementData的最后一位，也就是说，Stack的栈顶为Vector中数组的末端，相应的，数组起始端即为栈底事实上，在peek()方法的注释中也说明了这一点：return the object at the top of this stack (the last item of the Vector object). 问题二：Stack如何实现进栈操作？源码如下：12345public E push(E item) &#123; addElement(item); return item;&#125; 此处调用了其父类Vector的addElement(E item)，源码如下：123456789101112131415161718192021222324252627282930protected Object[] elementData;//默认初始化容量为10protected int elementCount;protected int capacityIncrement;public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125;private void ensureCapacityHelper(int minCapacity) &#123; if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; //默认的capacityIncrement为0，即默认扩容后新的容量为原来的两倍 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 问题三：Stack如何实现出栈操作？源码如下：123456789public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj;&#125; 问题四：Stack中的search(Object o)方法返回的值表示什么意思？search(Object o)的源码（下面的注释是我从原方法注释中截取下来的）如下：1234567891011//The equals method is used to compare o to the items in this stack.//return the 1-based position from the top of the stack where the object is located; //the return value -1 indicates that the object is not on the stack.public synchronized int search(Object o) &#123; int i = lastIndexOf(o); if (i &gt;= 0) &#123; return size() - i; &#125; return -1;&#125; 这里调用了父类Vector的lastIndexOf(Object o)方法，从数组的最后往前找（也即从栈顶往下依次查找），查找第一次出现的位置（因为栈中元素是可以重复的），若没找到该对象，返回-1，否则返回该对象和栈顶元素之间的距离，返回值从1（表示所要查找的对象就是栈顶元素）开始下面的示例让我们很容易明白search(Object o)到底要返回的是什么？1234567Stack&lt;String&gt; s = new Stack&lt;&gt;();for(int i = 0 ;i &lt; 10;i++) s.push(String.valueOf(i));System.out.println("栈顶元素："+s.peek());System.out.println("9到栈顶的距离："+s.search("9"));System.out.println("0到栈顶的距离："+s.search("0"));System.out.println("10到栈顶的距离："+s.search("10")); 输出：1234栈顶元素：99到栈顶的距离：10到栈顶的距离：1010到栈顶的距离：-1 值得注意的是，search(Object o)方法的查找是基于对象的equals方法进行，若泛型申明为自定义的类型，需要重写equals方法 栈的应用之配对问题问题：输入一串字符串，判断其中的括号是否配对（可以引申为判断字符串是否为json串，是否为算数表达式等等），例如，[( )]是配对的，而[( ])]就不配对算法思想：先判断输入的字符串是否为空串（null或者” “等均认为是空串），若为空串则直接返回false。否则，实例化一个空栈。如果字符为(，[，{等开放符号，则让其进栈。如果字符为)，]，}等封闭符号，则当栈空时返回false。若栈不空，则判断栈顶字符是否为对应的开放字符，若不是，则返回false，否则继续判断下一个字符代码示例如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Stack;public class Main &#123; public static boolean isMatch(String json) &#123; if(isEmpty(json)) return false; char[] charArray = json.toCharArray(); Stack&lt;Character&gt; s = new Stack&lt;Character&gt;(); for(char c : charArray) &#123; if(c == '&#123;' || c == '[' || c == '(') s.push(c); else if(c == '&#125;') &#123; if(isMatch0(s,'&#123;')) s.pop(); else return false; &#125; else if(c == ']') &#123; if(isMatch0(s,'[')) s.pop(); else return false; &#125; else if(c == ')') &#123; if(isMatch0(s,'(')) s.pop(); else return false; &#125; &#125; return true; &#125; //当栈空时返回false。 //若栈不空，则判断栈顶字符是否为对应的开放字符，若不是，则返回false private static boolean isMatch0(Stack&lt;?&gt; s,char openChar) &#123; if(s.empty() || (char)s.peek() != openChar) return false; return true; &#125; public static boolean isEmpty(String str) &#123; return str == null || str.trim().isEmpty(); &#125; public static void main(String[] args) &#123; System.out.println(isMatch("&#123;[([asdfffffffffff])]&#125;")); System.out.println(isMatch("&#123;][])99(&#125;")); &#125;&#125; 输出结果12truefalse 结语java.util.Stack的注释中写道：A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class. For example: Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();言下之意是相比Stack类，双端队列Deque和它的实现类具有更好的完整性和一致性，应该被优先使用 下回预告：数据结构与算法分析之Java中的队列Queue]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java collections api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架源码阅读之双链表LinkedList]]></title>
    <url>%2F2018%2F04%2F01%2Fjava-collections-api-linkedlist%2F</url>
    <content type="text"><![CDATA[本文只分析LinkedList的增(add) 删(remove) 改(set) 查(get)的实现，剩余的部分留给读者自己去浏览吧 本文是《Java集合框架源码阅读》系列的第二篇，我们的主角是java.util.LinkedList老规矩，先看LinkedList继承结构123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 构造方法：12public LinkedList()public LinkedList(Collection&lt;? extends E&gt; c) 成员属性：123transient int size = 0;transient Node&lt;E&gt; first;//头结点transient Node&lt;E&gt; last;//尾结点 问题一：LinkedList如何存储结点信息？查看源码可以发现，LinkedList内部有一个静态内部类Node&lt;E&gt;，其保存了当前结点的数据信息，以及指向其前驱和后继结点的链（或称指针）12345678910private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 问题二：LinkedList是如何实现尾部添加add(E e)方法的？源码如下：123456789101112131415public boolean add(E e) &#123; linkLast(e); return true;&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 解析：每当调用add(E e)方法时，首先调用linkLast(E e)，linkLast顾名思义，链接到尾结点，新建一个Node，让当前尾结点l成为其前驱结点，后继结点设为null，继而，新建的Node成为了新的尾结点，若原尾结点l尚未初始化，则让头结点指向新建的Node结点，否则，原来的尾节点L已经初始化了，则让新增结点成为原来的尾节点L的后继结点 我们都知道Java中的表List都是可以通过索引号（下标）获取结点值的，即 T get(int index)，ArrayList本身是数组，当然很好实现，而LinkedList却是双链表，它又是如何实现的呢？ 问题三：LinkedList是如何实现随机添加add(int index,E e)方法的？先来看下原理图： 第一步：newNode.prev = succ.prev; newNode.next = succ;第二步：succ.prev = newNode;第三步：if(pred != null) pred.next = newNode; else first = newNode;源码如下：123456789101112131415161718192021222324252627public void add(int index, E element) &#123; checkPositionIndex(index);//判断index是否为可以插入的位置 if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size;&#125;//在给定结点succ的前面插入一个新的结点，结点的值为evoid linkBefore(E e, Node&lt;E&gt; succ) &#123; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 问题四：LinkedList是如何实现get(int index)方法的？源码如下：12345678910111213141516171819202122232425public E get(int index) &#123; //检查是否满足0 &lt;= index &lt; size，不满足则抛出下标越界异常 checkElementIndex(index); return node(index).item;&#125;private void checkElementIndex(int index) &#123; if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size;&#125;Node&lt;E&gt; node(int index) &#123; if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 可以发现，get(int index)中使用了一个node(int index)来获取指定下标的Node，而node(int index)又采用了二分法——首先判断指定索引位于LinkedList的前半部分，还是后半部分，这么做主要是为了提高效率，减少需要遍历的结点个数，然后依次遍历结点，直至找到指定下标的Node。从源码也可以看出来，LinkedList并不适合随机取数据，因为每次按照索引号随机取数据时，都需要依次遍历表 问题五：LinkedList是如何实现remove(int index)方法的？先看原理图：源码如下：123456789101112131415161718192021222324252627282930313233343536public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125;E unlink(Node&lt;E&gt; x) &#123; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; /* [===] ——&gt; [===] ——&gt; [===] * || || * null × first */ if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; /* [===] ——&gt; [===] ——&gt; [===] * || || * last × null */ if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 问题六：LinkedList是如何实现set(int index,E element)方法的？set方法的实现相对简单，源码如下：12345678//把element设为新的item，返回原来的itempublic E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; 作业：自己实现简单的单链表SingleLinkedList以及循环单/双链表CircularSingleLinkedList/CircularDoubleLinkedList下回预告：数据结构与算法分析之Java中的栈]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java collections api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架源码阅读之顺序表ArrayList]]></title>
    <url>%2F2018%2F03%2F30%2Fjava-collections-api-arraylist%2F</url>
    <content type="text"><![CDATA[今天是《Java集合框架源码阅读》的第一篇，我们来讲讲Java中的顺序表ArrayList首先来看下ArrayList的继承结构12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 构造方法：123public ArrayList(int initialCapacity)public ArrayList()public ArrayList(Collection&lt;? extends E&gt; c) 成员属性：123456private static final int DEFAULT_CAPACITY = 10;//ArrayList的默认容量private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//空数组private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//默认容量的空数组transient Object[] elementData;private int size;//ArrayList中实际存储的元素个数private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 问题一：ArrayList的底层是采用什么实现的？查看ArrayList的源码可以发现如下代码:1transient Object[] elementData; 不难看出，ArrayList是采用数组实现的，事实上，ArrayList就是一个动态数组。 问题二：ArrayList是带泛型的，为什么不直接申明泛型数组T[]，而要采用Object型数组存储数据？java中不能直接实例化泛型数组，即不能new T[capacity];如果硬要申明泛型数组T[]，需创建一个泛型类型限界的数组，然后使用一个数组进行类型转换。这将产生一个编译器警告，但在泛型集合的实现中这是不可避免的。123T[] elementData;...elementData = (T[]) Object[capacity]; 我们都知道数组的长度是不变的，那么ArrayList是如何实现动态扩容的呢？ 问题三：ArrayList采用什么方式实现动态扩容？下面举个很简单的例子，大家就能明白了1234567891011static final DEFAULT_CAPACITY = 10;...int arr = new int[DEFAULT_CAPACITY];...//下面扩大arr容量int newCapacity = arr.length + arr.length / 2;int[] newArr = new int[newCapacity];for(int i = 0; i&lt; arr.length;i++) &#123; newArr[i] = arr[i];&#125;arr = newArr; 事实上，ArrayList内部也是采用的复制数组的方式实现动态扩容。至于其到底是如何做到的，请看下一个问题。 问题四：ArrayList的扩容机制？要回答这个问题，我们先得弄明白：当我们使用add(E e)时，ArrayList都干了什么123456//在尾部添加public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 可以看到，当我们调用add(E e)方法时，先执行的ensureCapacityInternal(size+1),然后将e加入elementData，size加1。ensureCapacityInternal直译为“确保内部容量”，它又是怎么实现的呢？​123456789//@param minCapacity 需要的最小容量private void ensureCapacityInternal(int minCapacity) &#123; //判断elementData是否为默认长度的空数组， //若是，则minCapacity取默认容量和原minCapacity的最大值 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125; 看到这里，又出现了一个新的方法ensureExplicitCapacity(int minCapacity)，ensureExplicitCapacity直译为“确保明确的容量”，接着往下挖​12345678private void ensureExplicitCapacity(int minCapacity) &#123; //modCount是ArrayList的父类AbstractList中定义的局部变量， //用于表示List的结构修改次数 modCount++; // 如果minCapacity超过了ArrayList的容量，则对其扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 这里出现了一个新的方法grow(int minCapacity)，grow意为“成长”，这就是ArrayList动态扩容的秘密吗？我们接着往下看 ​1234567891011private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; //每次扩容后，新的容量为原来容量的1.5倍，oldCapacity &gt;&gt; 1等价于 oldCapacity / 2 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //通过复制数组的方式，将数组扩容 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 其中出现了一个新的变量MAX_ARRAY_SIZE，ArrayList中对它的定义如下：1private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 为什么这么定义？ 源代码中的注释如下：The maximum size of array to allocate. Some VMs reserve some header words in an array.Attempts to allocate larger arrays may result in OutOfMemoryError: Requested array size exceeds VM limit翻译：可分配的最大的数组大小。一些虚拟机在数组中保留了一些头部信息。试图给数组分配更大的空间可能导致内存溢出错误：请求的数组大小超过了虚拟机的限制 12345678910//给定需要的最小容量，如果所给最小容量小于0，抛出内存溢出错误，//如果最小容量大于ArrayList定义的最大数组长度，则返回Integer的最大值，//否则，返回ArrayList定义的最大数组长度private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 作业：自己动手实现简单的ArrayList下回预告：数据结构与算法分析之Java中的双链表LinkedList]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java collections api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从阿里云服务器到使用github pages的变迁]]></title>
    <url>%2F2018%2F03%2F24%2Fblog%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;从2016年5月20号晚上注册了域名 http://www.hegongshan.com ，一直到2017年9月，我在阿里云上租用了一年多的云服务器。由于那时候是新手，所以保守的选择了windows server，而且是最低档的配置——1核1G内存20G磁盘，每个月80多，没办法，谁叫咱穷。&nbsp;&nbsp;&nbsp;&nbsp;一年多的时间，我的个人博客也经历了数次重构，从最开始采用最原始的JSP+Servlet+JDBC，到后来痴迷SSM，沉迷freemarker，再到后来觉得SSM项目jar包太多太大，占用内存过多，经常发生OOM，又想到将MyBatis砍掉，就采用Spring JdbcTemplate来处理dao层，直到现在选择了hexo和github pages。个人博客的搭建和维系，真是让人心累。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
