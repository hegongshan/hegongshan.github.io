<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在Linux中存活下来之history]]></title>
    <url>%2F2020%2F02%2F13%2Flinux-command-history%2F</url>
    <content type="text"><![CDATA[history命令用于显示历史执行过的命令。 选项 -c：清空当前历史命令 -d offset：删除历史记录中第offset个命令 -w: 将当前历史命令写入历史命令文件中 参数 n：查看最近的n条命令 执行历史命令 1.使用!number执行第number条命令 2.使用!!执行上一条命令]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》5.替换空格]]></title>
    <url>%2F2020%2F02%2F13%2Fcoding-interview-5-replace-space%2F</url>
    <content type="text"><![CDATA[请实现一个函数，将一个字符串中的每个空格替换成“%20”。 例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 方法一：使用自带方法12345class Solution &#123; public String replaceSpace(StringBuffer str) &#123; return str.toString().replace(" ", "%20"); &#125;&#125; 方法二：创建新字符串新建StringBuilder，然后逐一append。 1234567891011121314class Solution &#123; public String replaceSpace(StringBuffer str) &#123; StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); if(c == ' ') &#123; sb.append("%20"); &#125; else &#123; sb.append(c); &#125; &#125; return sb.toString(); &#125;&#125; 时间复杂度为O(n)，空间复杂度为O(n)。 方法三：原地替换1.统计字符串中空格的个数space； 2.对原字符串进行扩容，长度增加2 * space； 3.从后往前替换空格。 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public String replaceSpace(StringBuffer str) &#123; // 1.判断是否为空 if(str == null || str.length() == 0) &#123; return str.toString(); &#125; // 2.统计空格的个数 int space = 0; for(int i = 0; i &lt; str.length(); i++) &#123; if(str.charAt(i) == ' ') &#123; space ++; &#125; &#125; // 3.扩容，长度增加 2*space int left = str.length() - 1; int right = left + 2 * space; str.setLength(right + 1); // 4.原地替换空格 while(0 &lt;= left &amp;&amp; left &lt;= right) &#123; if(str.charAt(left) != ' ') &#123; str.setCharAt(right--, str.charAt(left)); &#125; else &#123; str.setCharAt(right--, '0'); str.setCharAt(right--, '2'); str.setCharAt(right--, '%'); &#125; left --; &#125; return str.toString(); &#125;&#125; 时间复杂度为O(n)，空间复杂度为O(n)。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 240.搜索二维矩阵 II/《剑指offer》4.二维数组中的查找]]></title>
    <url>%2F2020%2F02%2F12%2Fleetcode-240-search-a-2d-matrix-ii%2F</url>
    <content type="text"><![CDATA[编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例: 现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 方法一：暴力法123456class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: for row in matrix: if target in row: return True return False 时间复杂度为$O(m \times n)$，空间复杂度为O(1)。 方法二：二分查找（行）由于每行的元素从左到右升序排列，因此，在遍历每行时，可以使用二分法进行查找。 123456789101112131415161718class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: for row in matrix: if self.binary_search(row, target): return True return False def binary_search(self, nums: List[int], target: int) -&gt; bool: low, high = 0, len(nums) - 1 while low &lt;= high: mid = (low + high) // 2 if target &lt; nums[mid]: high = mid - 1 elif target &gt; nums[mid]: low = mid + 1 else: return True return False 时间复杂度为$O(m \log_2 n)$，空间复杂度为O(1)。 方法三：二分查找（行和列）12345678910111213141516171819202122232425262728293031class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: if not matrix: return False for i in range(min(len(matrix), len(matrix[0]))): row_found = self.binary_search(matrix, target, i, True) column_found = self.binary_search(matrix, target, i, False) if row_found or column_found: return True return False def binary_search(self, matrix: List[List[int]], target: int, start: int, row: bool) -&gt; bool: low= start high = len(matrix[0]) - 1 if row else len(matrix) - 1 while low &lt;= high: mid = (low + high) // 2 if row: if target == matrix[start][mid]: return True if target &lt; matrix[start][mid]: high = mid - 1 else: low = mid + 1 else: if target == matrix[mid][start]: return True if target &lt; matrix[mid][start]: high = mid - 1 else: low = mid + 1 return False 时间复杂度为$O(\log_2 (n!))$，空间复杂度为O(1)。 方法四：1234567891011121314class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: if not matrix: return False m, n = len(matrix), len(matrix[0]) i, j = m-1, 0 while i &gt;= 0 and j &lt; n: if target == matrix[i][j]: return True if target &gt; matrix[i][j]: j += 1 else: i -= 1 return False 时间复杂度为O(m+n)，空间复杂度为O(1)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 287.寻找重复数/《剑指offer》3.数组中重复的数字]]></title>
    <url>%2F2020%2F02%2F10%2Fleetcode-287-find-the-duplicate-number%2F</url>
    <content type="text"><![CDATA[给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1: 12输入: [1,3,4,2,2]输出: 2 示例 2: 12输入: [3,1,3,4,2]输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n^2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 方法一：排序123456class Solution: def findDuplicate(self, nums: List[int]) -&gt; int: nums.sort() for i in range(1, len(nums)): if nums[i - 1] == nums[i]: return nums[i] 时间复杂度为O(n log n)，空间复杂度为O(1)。 该方法改变了数组，违反了说明1。 方法二：哈希表字典 1234567class Solution: def findDuplicate(self, nums: List[int]) -&gt; int: lookup = &#123;&#125; for x in nums: if x in lookup.keys(): return x lookup[x] = 1 集合 1234567class Solution: def findDuplicate(self, nums: List[int]) -&gt; int: num_set = set() for x in nums: if x in num_set: return x num_set.add(x) 时间复杂度为O(n)，空间复杂度为O(n)。该方法违反了说明2。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 206./《剑指offer》15.反转链表]]></title>
    <url>%2F2020%2F02%2F03%2Fleetcode-206-reverse-linked-list%2F</url>
    <content type="text"><![CDATA[反转一个单链表。 示例: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 方法一：迭代思路：头插法。 12345678910111213141516171819# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if head is None or head.next is None: return head cur = head pre = None while cur: temp = cur.next cur.next = pre pre = cur cur = temp return pre 复杂度分析：时间复杂度为O(n)，空间复杂度为O(1)。其中，n为链表中结点的个数。 方法二：递归12345678910111213# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head: ListNode) -&gt; ListNode: if head is None or head.next is None: return head pre = self.reverseList(head.next) head.next.next = head head.next = None return pre 复杂度分析：时间复杂度为O(n)，空间复杂度为O(n)。其中，n为链表中结点的个数。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》14.链表中倒数第k个结点]]></title>
    <url>%2F2020%2F02%2F03%2Fcoding-interview-14-find-kth-to-tail%2F</url>
    <content type="text"><![CDATA[输入一个链表，输出该链表中倒数第k个结点。 方法一：使用数组思路：设n为链表中结点的个数。 遍历链表，将当前结点存入数组ls中。遍历结束后，若数组ls不为空，且给定的k值合法（1&lt;=k&lt;=n），则返回数组ls的第n-k-1个元素；否则，返回空。 123456789101112131415# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def FindKthToTail(self, head, k): ls = [] node = head while node: ls.append(node) node = node.next if ls and 1 &lt;= k &lt;= len(ls): return ls[-k] return None 复杂度分析：时间复杂度为O(n)，空间复杂度为O(n)。 方法二：快慢指针思路：设n为链表中结点的个数。 首先，设置两个指针slow和fast，均指向链表的第一个结点。 然后，让fast先走k步，指向链表中第k+1个结点。 若fast无法走完k步，则表示链表为空或者k不合法（k &lt; 1或者k &gt; n）。此时，直接返回空。 最后，同时遍历slow和fast，当fast为空时，slow指向的结点即为倒数第k个结点。 12345678910111213141516# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def FindKthToTail(self, head, k): slow = fast = head for i in range(k): if fast is None: return None fast = fast.next while fast: slow = slow.next fast = fast.next return slow 复杂度分析：时间复杂度为O(n)，空间复杂度为O(1)。]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指offer》6.从尾到头打印链表]]></title>
    <url>%2F2020%2F02%2F03%2Fcoding-interview-6-print-list-from-tail-to-head%2F</url>
    <content type="text"><![CDATA[输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 方法一：迭代思路：遍历链表，将当前节点的值加入到列表中。遍历结束后，翻转该列表。 1234567891011121314# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): result = [] node = listNode while node: result.append(node.val) node = node.next return result[::-1] 方法二：递归1234567891011121314151617# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): result = [] self.__printList(listNode, result) return result def __printList(self, listNode, result): if listNode is None: return self.__printList(listNode.next, result) result.append(listNode.val)]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 993.二叉树的堂兄弟节点]]></title>
    <url>%2F2020%2F01%2F31%2Fleetcode-993-cousins-in-binary-tree%2F</url>
    <content type="text"><![CDATA[在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。 如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。 我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。 只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。 示例 1： 1234567 1 / \ 2 3 / 4输入：root = [1,2,3,4], x = 4, y = 3输出：false 示例 2： 1234567 1 / \ 2 3 \ \ 4 5输入：root = [1,2,3,null,4,null,5], x = 5, y = 4输出：true 示例 3： 1234567 1 / \ 2 3 \ 4输入：root = [1,2,3,null,4], x = 2, y = 3输出：false 提示： 二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。 方法一：递归12345678910111213141516171819202122232425262728293031323334353637# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isCousins(self, root: TreeNode, x: int, y: int) -&gt; bool: if self.getDepth(root,x) == self.getDepth(root,y) and not self.isBrother(root,x,y): return True return False def getDepth(self, root: TreeNode, x: int) -&gt; int: if root is None: return None if root.val == x: return 0 # 若位于左子树中 left = self.getDepth(root.left, x) if left is not None: return left + 1 # 若位于右子树中 right = self.getDepth(root.right, x) if right is not None: return right + 1 return None def isBrother(self, root: TreeNode, x: int, y: int) -&gt; bool: if root is None: return False if root.left and root.right: if root.left.val == x and root.right.val == y: return True if root.left.val == y and root.right.val == x: return True return self.isBrother(root.left, x, y) or self.isBrother(root.right, x, y) 时间复杂度：O(n)，n为二叉树中节点的个数。 空间复杂度：O(n)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 725.分隔链表]]></title>
    <url>%2F2020%2F01%2F26%2Fleetcode-725-split-linked-list-in-parts%2F</url>
    <content type="text"><![CDATA[给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。 每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。 这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。 返回一个符合上述规则的链表的列表。 举例： 1-&gt;2-&gt;3-&gt;4, k = 5, 结果 [ [1], [2], [3], [4], null ] 示例 1： 12345678输入: root = [1, 2, 3], k = 5输出: [[1],[2],[3],[],[]]解释:输入输出各部分都应该是链表，而不是数组。例如, 输入的结点 root 的 val= 1, root.next.val = 2, root.next.next.val = 3, 且 root.next.next.next = null。第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。 示例 2： 12345输入: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]解释:输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。 提示: root 的长度范围： [0, 1000]. 输入的每个节点的大小范围：[0, 999]. k 的取值范围： [1, 50]. 方法步骤： 1.统计原链表的长度n； 2.计算分隔后每个部分的长度$\mathrm{length_i}（0 \le i &lt; k）$，令$r = n\ \%\ k$$$\mathrm{length_i = \begin{cases} \frac{n}{k} + 1, &amp; 0 \le i &lt; r \\ \frac{n}{k}, &amp; r \le i &lt; k \end{cases}}$$3.分隔链表。 分隔链表可以采用以下两种方式： 遍历链表，将链表分隔为k个部分。如果k&gt;n，则在返回的列表末尾补k-n个空链表； 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def splitListToParts(self, root: ListNode, k: int) -&gt; List[ListNode]: if k == 1: return [root] # 1.统计原链表的长度 n = 0 node = root while node: node = node.next n += 1 # 2.计算分隔后每个部分的长度 length = n // k r = n % k # 3.分隔链表 parts = [] count = 0 # 第几部分 part_length = 0 node = head = root while node: part_length += 1 temp = node.next if part_length == length + (count &lt; r): node.next = None parts.append(head) head = temp count += 1 part_length = 0 node = temp # 4.若n &lt; k，则在末尾补k - n个空链表 if n &lt; k: parts.extend([None] * (k - n)) return parts 循环K次，每次分隔出一部分。 123456789101112131415161718192021222324252627282930313233343536# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def splitListToParts(self, root: ListNode, k: int) -&gt; List[ListNode]: if k == 1: return [root] # 1.统计原链表的长度 n = 0 node = root while node: node = node.next n += 1 # 2.计算分隔后每个部分的长度 length = n // k r = n % k # 3.分隔链表 parts = [] node = root for i in range(k): head = node for j in range(length + (i &lt; r) - 1): if node: node = node.next if node: temp = node.next node.next = None node = temp parts.append(head) return parts 时间复杂度：O(n + k) 空间复杂度：O(k)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 430.扁平化多级双向链表]]></title>
    <url>%2F2020%2F01%2F25%2Fleetcode-430-flatten-a-multilevel-doubly-linked-list%2F</url>
    <content type="text"><![CDATA[您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。 扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。 示例: 123456789输入: 1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL输出:1-2-3-7-8-11-12-9-10-4-5-6-NULL 以上示例的说明: 给出以下多级双向链表: 我们应该返回如下所示的扁平双向链表: 方法一：递归123456789101112131415161718192021222324252627282930"""# Definition for a Node.class Node: def __init__(self, val, prev, next, child): self.val = val self.prev = prev self.next = next self.child = child"""class Solution: def flatten(self, head: 'Node') -&gt; 'Node': node = head while node: temp = node.next if node.child: child_head = self.flatten(node.child) # 寻找子链表的尾节点 child_tail = child_head while child_tail and child_tail.next: child_tail = child_tail.next node.next = child_head child_head.prev = node child_tail.next = temp if temp: temp.prev = child_tail node.child = None node = temp return head 为了寻找子链表的尾节点，上述方法需要重复遍历子链表。为了解决该问题，递归时可以直接返回尾节点： 12345678910111213141516171819202122232425262728293031323334353637"""# Definition for a Node.class Node: def __init__(self, val, prev, next, child): self.val = val self.prev = prev self.next = next self.child = child"""class Solution: def flatten(self, head: 'Node') -&gt; 'Node': self.flatten_dfs(head) return head def flatten_dfs(self, head: 'Node') -&gt; 'Node': ''' 将双链表拉平，并返回新链表的尾节点 ''' pre = node = head while node: temp = node.next if node.child: child_head = node.child child_tail = self.flatten_dfs(child_head) node.next = child_head child_head.prev = node child_tail.next = temp if temp: temp.prev = child_tail node.child = None pre = child_tail else: pre = node node = temp return pre 该方法的时间复杂度：O(n)，空间复杂度：O(n)。 方法二：迭代1234567891011121314151617181920212223242526272829"""# Definition for a Node.class Node: def __init__(self, val, prev, next, child): self.val = val self.prev = prev self.next = next self.child = child"""class Solution: def flatten(self, head: 'Node') -&gt; 'Node': if head is None: return head stack = [head] pre = None while stack: node = stack.pop() if node.next: stack.append(node.next) if node.child: stack.append(node.child) node.child = None if pre: node.prev = pre pre.next = node pre = node return head 该方法的时间复杂度：O(n)，空间复杂度：O(n)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 138.复制带随机指针的链表]]></title>
    <url>%2F2020%2F01%2F24%2Fleetcode-138-copy-list-with-random-pointer%2F</url>
    <content type="text"><![CDATA[给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的 深拷贝。 我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示： val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 示例 1： 12输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2： 12输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]] 示例 3： 12输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]] 示例 4： 123输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。 方法一：哈希表时间复杂度：O(n) 空间复杂度：O(n) 12345678910111213141516171819202122232425262728"""# Definition for a Node.class Node: def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None): self.val = int(x) self.next = next self.random = random"""class Solution: def copyRandomList(self, head: 'Node') -&gt; 'Node': if head is None: return None hash_table = &#123;&#125; node = head # 1.新建节点，并存储哈希表中 while node: new_node = Node(node.val, None, None) hash_table[node] = new_node node = node.next # 2.复制链表 node = head while node: hash_table[node].next = hash_table.get(node.next) hash_table[node].random = hash_table.get(node.random) node = node.next return hash_table[head] 方法二：原地复制步骤： 1.遍历原链表，依次复制每个节点，并将复制得到的新节点插入到原节点后面。 假如原链表为$A \rightarrow B \rightarrow C$，遍历结束后，得到的新链表为$A \rightarrow A^\prime \rightarrow B \rightarrow B^\prime \rightarrow C \rightarrow C^\prime$ 2.复制random指针，例如$\mathrm{A^\prime.random = A.random.next}$； 3.遍历新链表，分离出原链表的深拷贝。 时间复杂度：O(n) 空间复杂度：O(1) 12345678910111213141516171819202122232425262728293031323334353637"""# Definition for a Node.class Node: def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None): self.val = int(x) self.next = next self.random = random"""class Solution: def copyRandomList(self, head: 'Node') -&gt; 'Node': if head is None: return None # 1.复制节点 cur = head while cur: node = Node(cur.val, None, None) node.next = cur.next cur.next = node cur = cur.next.next # 2.复制random指针 cur = head while cur: if cur.random: cur.next.random = cur.random.next cur = cur.next.next # 3.分离链表 cur = head root = tail = head.next while cur: cur.next = cur.next.next tail.next = tail.next.next if tail.next else None cur = cur.next tail = tail.next return root]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 143.重排链表]]></title>
    <url>%2F2020%2F01%2F19%2Fleetcode-143-reorder-list%2F</url>
    <content type="text"><![CDATA[给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例 1: 1给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3. 示例 2: 1给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3. 思路 首先，将单链表分割为前后两个部分； 然后，使用头插法反转后半部分； 最后，将后半部分节点依次插入到前半部分中。 方法一：快慢指针1234567891011121314151617181920212223242526272829303132333435363738394041424344# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reorderList(self, head: ListNode) -&gt; None: """ Do not return anything, modify head in-place instead. """ # 若单链表为空，或者仅有一个节点，或者仅有两个节点 if not head or not head.next or not head.next.next: return # 将单链表分割为前后两个部分 slow = fast = head while fast.next and fast.next.next: slow = slow.next fast = fast.next.next mid = slow.next slow.next = None # 采用头插法，反转后半部分 fast = None while mid: temp = mid.next mid.next = fast fast = mid mid = temp # 重排链表 slow = head while slow and fast: temp1 = slow.next temp2 = fast.next fast.next = slow.next slow.next = fast slow = temp1 fast = temp2]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Outer Product-based Neural Collaborative Filtering]]></title>
    <url>%2F2020%2F01%2F18%2Frecommender-system-oncf%2F</url>
    <content type="text"><![CDATA[Outer Product-based Neural Collaborative Filtering（ONCF）一文发表在IJCAI 2018上，作者使用外积对嵌入空间中各个维度之间的相互关系进行显式建模。 模型结构 目标函数作者使用了BPR损失函数：$$L = \sum_{(u,i,j) \in \mathcal{D}} - \ln \sigma(\hat y_{ui} - \hat y_{uj}) + \lambda_{\Delta} \left \Vert \Delta \right \Vert^2$$ 论文地址：https://www.ijcai.org/Proceedings/2018/0308.pdf 代码地址：https://github.com/duxy-me/ConvNCF]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 114.二叉树展开为链表]]></title>
    <url>%2F2020%2F01%2F17%2Fleetcode-114-flatten-binary-tree-to-linked-list%2F</url>
    <content type="text"><![CDATA[给定一个二叉树，原地将它展开为链表。 例如，给定二叉树 1 / \ 2 5 / \ \ 3 4 6 将其展开为： 12345678910111 \ 2 \ 3 \ 4 \ 5 \ 6 题意按照先序遍历的顺序，将给定的二叉树转变为“链表”，即除叶子节点外，其他所有节点均只有右孩子的二叉树。 方法一：栈12345678910111213141516171819202122232425262728293031# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def flatten(self, root: TreeNode) -&gt; None: """ Do not return anything, modify root in-place instead. """ if not root: return stack = [root] # 链表中的尾节点 tail = None while stack: node = stack.pop() if node.right: stack.append(node.right) if node.left: stack.append(node.left) node.left = None if not tail: root = tail = node else: tail.right = node tail = node 方法二：递归12345678910111213141516171819202122232425# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def flatten(self, root: TreeNode) -&gt; None: """ Do not return anything, modify root in-place instead. """ if not root: return self.flatten(root.left) self.flatten(root.right) pre = root.left if pre: # 寻找左子树中最右边的节点 while pre.right: pre = pre.right pre.right = root.right root.right = root.left root.left = None 方法三：迭代12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def flatten(self, root: TreeNode) -&gt; None: """ Do not return anything, modify root in-place instead. """ while root: pre = root.left if pre: # 寻找左子树中最右边的节点 while pre.right: pre = pre.right pre.right = root.right root.right = root.left root.left = None root = root.right]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 160.相交链表]]></title>
    <url>%2F2020%2F01%2F15%2Fleetcode-160-intersection-of-two-linked-lists%2F</url>
    <content type="text"><![CDATA[编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表： $$\begin{align}A: \qquad a1 \rightarrow a2 &amp;\\ &amp;\searrow \\ &amp; \quad c1 \rightarrow c2 \rightarrow c3 \\ &amp;\nearrow \\B: b1 \rightarrow b2 \rightarrow b3\end{align}$$在节点 c1 开始相交。 示例 1： $$\begin{align}A: \qquad 4 \rightarrow 1 &amp; \\ &amp; \searrow \\ &amp; \quad 8 \rightarrow 4 \rightarrow 5 \\ &amp; \nearrow \\B:5 \rightarrow 0 \rightarrow 1\end{align}$$ 123输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： $$\begin{align}A: 0 \rightarrow 9 \rightarrow 1 &amp; \\ &amp; \searrow \\ &amp; \quad 2 \rightarrow 4 \\ &amp; \nearrow \\B: \qquad \qquad 3\end{align}$$ 123输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3：$$A: 2 \rightarrow 6 \rightarrow 4 \\B: \qquad 1 \rightarrow 5$$ 1234输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null。 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 方法一：跳过多余节点$$\begin{align}A: \overset{x}{\overbrace{a_1 \rightarrow a_2 \rightarrow \cdots \rightarrow a_x}} &amp;\\ &amp;\searrow \\ &amp; \quad \underset{z}{\underbrace{c_1 \rightarrow \cdots \rightarrow c_z}} \\ &amp;\nearrow \\B: \underset{y}{\underbrace{b_1 \rightarrow b_2 \rightarrow \cdots \rightarrow b_y}}\end{align}$$ 假设链表A的长度大于B（即x &gt; y），那么，只需要跳过链表A的前x - y个节点，然后再同时遍历链表A和B。当两个链表的当前节点相同时，该节点即为链表A和B相交的起始节点$c_1$。 时间复杂度：O(n) 空间复杂度：O(1) 1234567891011121314151617181920212223242526272829303132333435363738394041# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: if not headA or not headB: return None length1 = 0 length2 = 0 node1 = headA node2 = headB # 获取链表的长度 while node1: node1 = node1.next length1 += 1 while node2: node2 = node2.next length2 += 1 # 跳过多余的节点 node1 = headA node2 = headB for i in range(abs(length1-length2)): if length1 &gt; length2: node1 = node1.next else: node2 = node2.next while node1: if node1 == node2: return node1 node1 = node1.next node2 = node2.next return None 方法二：双指针法$$\begin{align}A: \overset{x}{\overbrace{a_1 \rightarrow a_2 \rightarrow \cdots \rightarrow a_x}} &amp;\\ &amp;\searrow \\ &amp; \quad \underset{z}{\underbrace{c_1 \rightarrow \cdots \rightarrow c_z}} \\ &amp;\nearrow \\B: \underset{y}{\underbrace{b_1 \rightarrow b_2 \rightarrow \cdots \rightarrow b_y}}\end{align}$$ 由于x + z + y = y + z + x，因此，如果同时遍历链表A和B，到达链表的末尾$c_2$时，再从另一个链表的起始位置$b_1$（$a_1$）开始遍历。当两个指针都走完x + y + z的距离时，下一个节点就是链表A和B相交的起始节点$c_1$。 时间复杂度：O(m + n) 空间复杂度：O(1) 123456789101112131415161718192021222324# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: if not headA or not headB: return None node1 = headA node2 = headB while node1 != node2: if node1: node1 = node1.next else: node1 = headB if node2: node2 = node2.next else: node2 = headA return node1 使用Python的三元运算符： 1234567891011121314151617# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode: if not headA or not headB: return None node1 = headA node2 = headB while node1 != node2: node1 = node1.next if node1 else headB node2 = node2.next if node2 else headA return node1]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向量乘法]]></title>
    <url>%2F2020%2F01%2F14%2Fvector-product%2F</url>
    <content type="text"><![CDATA[向量乘法 假设$\mathbf{a} \in \mathbb{R}^n, \mathbf{b} \in \mathbb{R}^n$ 内积内积（inner product或者dot product）$$\mathbf{a} \cdot \mathbf{b} = \mathbf{a}^T \mathbf{b} = \sum_{i=1}^n a_i \times b_i \tag{1}$$ 逐元素相乘逐元素相乘（element-wise product）$$\mathbf{a} \odot \mathbf{b} =\begin{bmatrix}a_1 \times b_1 \\a_2 \times b_2 \\\cdots \\a_n \times b_n\end{bmatrix} \tag{2}$$ 外积外积（outer product）$$\mathbf{a} \otimes \mathbf{b}= \mathbf{a} \mathbf{b}^T= \begin{bmatrix}a_1 \times b_1 &amp; a_1 \times b_2 &amp; \cdots &amp; a_1 \times b_n \\a_2 \times b_1 &amp; a_2 \times b_2 &amp; \cdots &amp; a_2 \times b_n \\\vdots &amp; \vdots &amp; \vdots &amp; \vdots \\a_n \times b_1 &amp; a_n \times b_2 &amp; \cdots &amp; a_n \times b_n\end{bmatrix} \tag{3}$$]]></content>
      <categories>
        <category>mathematics</category>
      </categories>
      <tags>
        <tag>mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 CFM&#58 Convolutional Factorization Machines for Context-Aware Recommendation]]></title>
    <url>%2F2020%2F01%2F14%2Frecommender-system-cfm%2F</url>
    <content type="text"><![CDATA[Convolutional Factorization Machine（CFM）一文发表在IJCAI 2019上，作者使用叉积对二阶交互进行建模，利用3D CNN来学习高阶交互。 研究动机 分解机无法对高阶和非线性的特征交互进行充分建模 现有的使用神经网络增强分解机的方法，均假定嵌入的维度彼此独立，并以相对隐式的方式对高阶交互进行建模 模型结构 损失函数作者使用BPR损失函数$$L = \sum - \ln \sigma(\hat y_{CFM} (\mathbf{x}^+) - \hat y_{CFM} (\mathbf{x}^-))$$]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Interaction-Aware Factorization Machines for Recommender Systems]]></title>
    <url>%2F2020%2F01%2F12%2Frecommender-system-ifm%2F</url>
    <content type="text"><![CDATA[Interaction-Aware Factorization Machine（IFM）一文发表在AAAI 2019上。 未完待续…]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 147.对链表进行插入排序]]></title>
    <url>%2F2020%2F01%2F11%2Fleetcode-147-insertion-sort-list%2F</url>
    <content type="text"><![CDATA[对链表进行插入排序。 插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 插入排序算法： 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 重复直到所有输入数据插入完为止。 示例 1： 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2： 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解法一：带头结点12345678910111213141516171819202122232425262728293031# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def insertionSortList(self, head: ListNode) -&gt; ListNode: # 若链表为空或只有一个结点 if not head or not head.next: return head cur = head.next root = ListNode(-1) root.next = head head.next = None while cur: pre = root node = root.next # 存储下一个结点 temp = cur.next # 寻找插入的位置 while node and node.val &lt; cur.val: pre = node node = node.next cur.next = node pre.next = cur cur = temp return root.next 解法二：带头结点和尾结点解法一可能会遇到：当前结点的值大于有序区中的最大值。 此时，为了寻找该结点的插入位置，解法一将遍历有序区中的所有结点。 针对这种情况，可以考虑为有序区添加尾结点。 1234567891011121314151617181920212223242526272829303132333435363738# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def insertionSortList(self, head: ListNode) -&gt; ListNode: # 若链表为空或只有一个结点 if not head or not head.next: return head cur = head.next root = ListNode(-1) root.next = tail = head tail.next = None while cur: pre = root node = root.next # 存储下一个结点 temp = cur.next # 若当前结点的值大于有序区最后一个结点的值 if tail.val &lt; cur.val: cur.next = None tail.next = cur tail = cur else: # 寻找插入的位置 while node and node.val &lt; cur.val: pre= node node = node.next cur.next = node pre.next = cur cur = temp return root.next]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 DeepFM&#58 A Factorization-Machine based Neural Network for CTR Prediction]]></title>
    <url>%2F2020%2F01%2F08%2Frecommender-system-deepfm%2F</url>
    <content type="text"><![CDATA[DeepFM一文发表在IJCAI 2017上，作者在wide &amp; deep的基础上，使用分解机代替线性回归，从而避免了特征工程。 问题陈述点击率（Click Through Rate，简称CTR）预测： 构建一个预测模型$\hat y = model(x)$，估计某个用户在给定的背景下点击特定应用的概率。 研究动机现有的点击率预测方法 要么只学习低阶特征交互，如FM 要么只学习高阶特征交互，如FNN和PNN 要么依赖于特征工程，如wide &amp; deep DeepFM能同时学习各种层次的特征交互，且不需要特征工程。 模型结构 FM和deep模块使用相同的embedding向量。 预测模型：$$\hat y = \mathrm{sigmoid}(y_{FM} + y_{DNN}) \tag{1}$$其中，$\hat y \in (0,1)$是预测的点击率，$y_{FM}$是分解机模块的输出，$y_{DNN}$是深度模块的输出。 分解机模块 表达式：$$y_{FM} = &lt;w,x&gt; + \sum_{i=1}^d \sum_{j=i+1}^d &lt;V_i, V_j&gt; x_i \cdot x_j \tag{2}$$其中，$w \in R^d$，$V_i \in R^k$。 深度模块 论文地址：https://www.ijcai.org/proceedings/2017/0239.pdf]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1290.二进制链表转整数]]></title>
    <url>%2F2020%2F01%2F07%2Fleetcode-1290-convert-binary-number-in-a-linked-list-to-integer%2F</url>
    <content type="text"><![CDATA[给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。请你返回该链表所表示数字的十进制值 。 示例 1： 12341-&gt;0-&gt;1输入：head = [1,0,1]输出：5解释：二进制数 (101) 转化为十进制数 (5) 示例 2： 12输入：head = [0]输出：0 示例 3： 12输入：head = [1]输出：1 示例 4： 12输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]输出：18880 示例 5： 12输入：head = [0,0]输出：0 提示： 链表不为空。 链表的结点总数不超过 30。 每个结点的值不是 0 就是 1。 方法：一次迭代假定单链表中存储的二进制数字为$x_1 x_2 \cdots x_n$，其十进制值为$$\begin{align}\mathrm{data}&amp;= x_1 \times 2^{n-1} + x_2 \times 2^{n-2} + \cdots + x_{n-1} \times 2 + x_n \\&amp;= 2 \times (x_1 \times 2 ^{n-2} + x_2 \times 2^{n-3} + \cdots + x_{n-1}) + x_n\\&amp;\cdots \\&amp;= 2 \times ( \cdots 2 \times (2 \times x_1 + x_2) + x_3 \cdots ) + x_n\end{align}$$因此： 12345678910111213# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def getDecimalValue(self, head: ListNode) -&gt; int: data = 0 while head: data = 2 * data + head.val head = head.next return data]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 A Neural Collaborative Filtering Model with Interaction-based Neighborhood]]></title>
    <url>%2F2020%2F01%2F06%2Frecommender-system-nncf%2F</url>
    <content type="text"><![CDATA[Neighborhood-based Neural Collaborative Filtering（NNCF）一文发表在CIKM 2017上，作者在Neural Collaborative Filtering的基础上，加入了邻域信息。 模型结构 目标函数给定训练集$\tau = { &lt; u, i, y_{ui}&gt; }$，作者采用二元交叉熵作为损失函数：$$\mathcal{L} = - \sum_{&lt; u, i, y_{u, i}&gt; \in \tau} \left( y_{ui} \log \hat p_{ui} + (1 - y_{ui}) \log (1 - \hat p_{ui}) \right)$$]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年终总结]]></title>
    <url>%2F2019%2F12%2F31%2F2019-year-end-summary%2F</url>
    <content type="text"><![CDATA[元旦将至，恍惚之间便是一年。 科研3月初，我选定了自己的研究方向——推荐系统。 此后的一个月里，我阅读了项亮博士撰写的《推荐系统实践》一书，对推荐系统这个领域有了粗略的了解。 入门以后，我开始阅读推荐系统领域的经典论文，比如ItemCF等，科研一途算是入门了。 9月初，拜读了Keras之父著作的《Python深度学习》一书，终于掌握了一种深度学习框架。 随后，我和班上的同学一起组队，参加了2019 CCF大数据与计算智能大赛——互联网新闻情感分析，成绩还不错，排在前20%。 9月底，我认真研读了何向南教授的《Neural Collaborative Filtering》一文，对推荐系统以及深度学习在该领域的应用有了更多的了解，科研一道总算是走上了正轨（至今还没有想到靠谱的idea=_=）。 生活年初的时候，跟着导师去了一趟广州，也算是进行了一次国内游。 号称“小蛮腰”的广州塔 暑假的时候，在学校游泳馆自学了蛙泳，终于不是旱鸭子了&gt;_&lt;（虽然还不太熟练）。 阅读今年看了很多闲书，也读了很多技术书（虽然基本都没读完）。 科普类 《从一到无穷大》（读了3/4）、《浪潮之巅》（读了三四章） 励志类 《见识》和《态度》（均已读完） 文学类 历史：《万历十五年》（已读完） 小说：《红玫瑰与白玫瑰》 科幻：《流浪地球》（已读完）、《球状闪电》（已读完）、《超新星纪元》（读了1/2） 思想政治类 《周恩来邓颖超通信选集》、《共产党宣言》 技术类 计算机组成原理：《编码：隐匿在计算机软硬件背后的语言》（读了7章左右，内容非常好） Linux：《Linux命令行大全》 推荐系统：《推荐系统实践》（已读完）、《推荐系统：技术、评估及高效算法》 深度学习：《Python深度学习》 Python：《Effective Python：编写高质量Python代码的59个有效方法》、《流畅的Python》 计算机相关：《软技能》、《人月神话》、《黑客与画家》 收获 GitHub 2019年，我在GitHub上共提交了222次，获得了7个star和2次fork。 博客 在过去的一年中，我总共写了211篇博文，内容集中在PAT、CCF CSP、LeetCode、推荐系统以及Python等方面。 社团活动 5月份，在学长的动员下，我参加了学院研究生会换届选举，碰巧当选了学院研究生会副主席。 在此后的半年中，我参与了9月的迎新，组织同学参加校篮球赛和校羽毛球赛，和华师教育学院以及武理机电工程学院联合举办了三校三院研究生羽毛球赛。 荣誉 今年，我参加了三个数学建模比赛。中青杯获得了三等奖，MathorCup和中国研究生数模只拿到了成功参赛奖。 下半年，我靠着89.833的平均成绩（rank 4/22），勉强获得了“优秀学业奖学金”二等奖和优秀研究生。 考证 一直以来，我对软件测试都很感兴趣。正巧软考中级下设有软件评测师，遂报名参加了考试。 临考前，我用了12个晚上的时间（每晚2个小时），做完了历年真题，并对重要的知识点进行了总结。 前段时间，考试成绩出来了，上午和下午都在60分以上，超过了我的预期。 英语 6月，我再次参加了英语六级考试。虽然没有达到预期的500分，但也十分接近了（493分）。 不得不说，这么多年了，英语的弱项依然是听力、翻译和写作。 有待改进 晚睡晚起 三餐时间不规律，经常不吃早饭 感情问题 说多做少 2020年的计划 科研：完成资格论文（CCF C及以上）。 编程：CCF CSP努力考到300分及以上，PAT甲级努力考到80分及以上。 工作：找到一份满意的实习和工作（推荐系统或者Java开发）。 竞赛：努力在“锐捷网络杯”程序设计大赛中获奖，弥补遗憾。 申博：申上计算机的博士（清北+华五+海外）。 影响力：在GitHub上获得10个star。 阅读：读完10本非技术书籍（科普、小说等）以及5本技术类书籍。 考证：尝试软考高级（系统分析师/系统架构设计师）。 生活：一次国内游。 博客：写50篇（及以上）高质量的博客（包括但不限于论文阅读、技术总结以及读书笔记等）。]]></content>
      <categories>
        <category>任重而道远</category>
      </categories>
      <tags>
        <tag>任重而道远</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 DeepCF&#58 A Unified Framework of Representation Learning and Matching Function Learning in Recommender System]]></title>
    <url>%2F2019%2F12%2F30%2Frecommender-system-deepcf%2F</url>
    <content type="text"><![CDATA[DeepCF一文发表在AAAI 2019上，作者将基于表示学习的方法与基于匹配函数学习的方法进行了融合，极大地改进了模型性能。 现有方法的不足 在预测匹配分数时， 现有的基于表示学习的方法使用了简单的点积或者余弦相似度，严重地限制了模型的表达能力。 现有的基于匹配函数的方法，常常使用MLP作为匹配函数，而MLP无法对低秩关系进行充分的建模。 问题描述假设有M个用户，N个物品。 根据用户的隐式反馈，构建用户-物品交互矩阵$：\mathbf{Y} \in \mathbb{R}^{M \times N}$$$y_{ui} =\begin{cases}1, &amp; \mathrm{if\ interaction\ (user}\ u, \mathrm{item}\ i)\ \mathrm{is\ observed;} \\0, &amp; \mathrm{otherwise}\end{cases} \tag{1}$$假设$y_{ui}$服从伯努利分布（二项分布）：$$P(y_{ui} = k | p_{ui}) =\begin{cases}1 - p_{ui}, &amp; k = 0 \\p_{ui}, &amp; k = 1\end{cases}=p_{ui}^k (1 - p_{ui})^{1-k} \tag{2}$$ 目标函数似然函数：$$\begin{align}L &amp;= \prod_{(u,i) \in \mathcal{Y}^+ \cup \mathcal{Y}^-} P(y_{ui} | \Theta) \\&amp;= \prod_{(u,i) \in \mathcal{Y}^+ \cup \mathcal{Y}^-} \hat y_{ui}^{y_{ui}} (1 - \hat y_{ui})^{1 - y_{ui}}\end{align} \tag{3}$$其中，$\mathcal{Y}^+$表示$\mathbf{Y}$中的正样本，$\mathcal{Y}^-$表示采集的负样本。 两边取对数：$$\ell_{BCE} = - \sum_{(u,i) \in \mathcal{Y}^+ \cup \mathcal{Y}^-} y_{ui} \log \hat y_{ui} + (1 - y_{ui}) \log (1 - \hat y_{ui}) \tag{4}$$ DeepCF处理过程 模型结构 论文地址：https://arxiv.org/pdf/1901.04704.pdf 实验代码：https://github.com/familyld/DeepCF]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Attentional Factorization Machines&#58 Learning the Weight of Feature Interactions via Attention Networks]]></title>
    <url>%2F2019%2F12%2F26%2Frecommender-system-afm%2F</url>
    <content type="text"><![CDATA[Attentional Factorization Machines（AFM）一文发表在IJCAI 2017上，作者在分解机中引入了attention机制，为不同的特征交互赋予不同的权重。 分解机$$\hat y_{FM} (\mathbf{x}) =\underset{ \mathrm{linear\ regression}}{ \underbrace{w_0 + \sum_{i=1}^n w_i x_i}} + \underset{ \mathrm{pair-wise\ feature\ interactions}}{ \underbrace{\sum_{i=1}^n \sum_{j=i+1}^n \hat w_{ij} x_i x_j}} \tag{1}$$ 其中，$w_0$表示全局偏置，$w_i$表示第i个特征的权重，$\hat w_{ij} = \mathbf{v}_i^T \mathbf{v}_j$表示交叉特征$x_i x_j$的权重。 $\mathbf{v}_i = \mathbb{R}^k$表示特征i的embedding向量，k表示embedding向量的大小。 缺点：并非所有的特征都与预测相关，而分解机对所有的特征交互使用了相同的权重。 模型结构 图中省略了线性回归部分。 逐对交互层 令$\mathcal{X}$为特征向量$\mathbf{x}$中的非零特征集合，embedding层的输出为$\varepsilon = \{ \mathbf{v}_i x_i \}_{i \in \mathcal{x} }$。因此，逐对交互层（Pair-wise Interaction Layer）的输出为： $$ f_{PI}(\varepsilon) = \{ (\mathbf{v}_i \odot \mathbf{v}_j) x_i x_j \}_{(i,j) \in \mathcal{R}_x} \tag{2} $$ 其中，$\odot$表示逐元素相乘， $\mathcal{R}_x = \{ (i,j) \}_{i \in \mathcal{X}, j \in \mathcal{X}, j > i}$。 使用sum pooling将$f_{PI}(\varepsilon)$压缩成一个向量，然后用一个全连接层将其变为预测分数$$\hat y = \mathbf{p}^T \sum_{(i,j) \in \mathcal{R}_x} (\mathbf{v}_i \odot \mathbf{v}_j) x_i x_j + b \tag{3}$$其中，$\mathbf{p} \in \mathbb{R}^k$和$b \in \mathbb{R}$表示预测层的权重和偏置。 当$\mathbf{p} \equiv [1,1,\dots,1]$和$b \equiv 0$时，上式将退化为FM。 Attention池化层该层的输出为：$$f_{Att}(f_{PI}(\varepsilon)) =\sum_{(i,j) \in \mathcal{R}_x} a_{ij} (\mathbf{v}_i \odot \mathbf{v}_j) x_i x_j \tag{4}$$作者使用一层的MLP当作attention网络：$$a_{ij}^\prime = \mathbf{h}^T \mathrm{ReLU}(\mathbf{W} (\mathbf{v}_i \odot \mathbf{v}_j) x_i x_j + \mathbf{b}) \\a_{ij} = \frac{ \mathrm{exp(a_{ij}^\prime)}}{ \sum_{(i,j) \in \mathcal{R}_x} \mathrm{exp(a_{ij}^\prime)}} \tag{5}$$其中，$\mathbf{W} \in \mathbb{R}^{t \times k}$，$\mathbf{b} \in \mathbb{R}^t$，$\mathbf{h} \in \mathbb{R}^t$。 这里的t表示attention网络中隐含层的大小，作者称之为attention factor。 模型表达式$$\hat y_{AFM} (\mathbf{x}) =w_0 + \sum_{i=1}^n w_i x_i + \mathbf{p}^T \sum_{i=1}^n \sum_{j=i+1}^n a_{ij} (\mathbf{v}_i \odot \mathbf{v}_j) x_i x_j \tag{6}$$ 模型的参数$\Theta = \{w_0, \{ w_i \}_{i=1}^n, \{ \mathbf{v}_i \}_{i=1}^n, \mathbf{p, W, b, h} \}$。 目标函数论文将AFM用于回归任务，因此，作者采用了平方损失：$$L = \sum_{x \in \tau} (\hat y_{AFM}(\mathbf{x}) - y(\mathbf{x}))^2 \tag{7}$$其中，$\tau$表示训练集。 为了防止过拟合，作者对逐对交互层使用了丢弃法（dropout），对attention网络使用了L2正则项。 因此，实际的目标函数如下：$$L = \sum_{x \in \tau} (\hat y_{AFM}(\mathbf{x}) - y(\mathbf{x}))^2 + \lambda \left \Vert \mathbf{W} \right \Vert^2 \tag{8}$$论文地址：https://www.ijcai.org/proceedings/2017/0435.pdf 实验代码：https://github.com/hexiangnan/attentional_factorization_machine]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Neural Factorization Machines for Sparse Predictive Analytics]]></title>
    <url>%2F2019%2F12%2F25%2Frecommender-system-nfm%2F</url>
    <content type="text"><![CDATA[Neural Factorization Machine（NFM）一文发表在SIGIR 2017上，作者将分解机与神经网络整合在一起，利用分解机对二元特征交互进行建模，使用神经网络对高层特征交互进行建模。 分解机$$\hat y_{FM}(\mathbf{x}) = w_0 + \sum_{i=1}^n w_i x_i + \sum_{i=1}^n \sum_{j=i+1}^n \mathbf{v}_i^T \mathbf{v}_j \cdot x_i x_j \tag{1}$$ 模型结构 为了清楚地描述，图中没有显示线性回归部分。 二元交互层$$f_{BI}(\mathcal{V}_x)= \sum_{i=1}^n \sum_{j=i+1}^n x_i \mathbf{v}_i \odot x_j \mathbf{v}_j= \sum_{i=1}^n \sum_{j=1}^{i-1} x_i \mathbf{v}_i \odot x_j \mathbf{v}_j \tag{2}$$ 令$\mathbf{v}^2 = \mathbf{v} \odot \mathbf{v}$，则：$$2 f_{BI}(\mathcal{V}_x)= \sum_{i=1}^n (\sum_{j=1}^n x_i \mathbf{v}_i \odot x_j \mathbf{v}_j - x_i \mathbf{v}_i \odot x_i \mathbf{v}_i)= (\sum_{i=1}^n x_i \mathbf{v}_i)^2 - \sum_{i=1}^n (x_i \mathbf{v}_i)^2 \tag{3}$$ 从而，可以推出：$$\Rightarrow f_{BI}(\mathcal{V}_x) = \frac{1}{2}\left [(\sum_{i=1}^n x_i \mathbf{v}_i)^2 - \sum_{i=1}^n (x_i \mathbf{v}_i)^2 \right] \tag{4}$$ 模型表达式$$\begin{align}\hat y_{NFM}(\mathbf{x})&amp;= w_0 + \sum_{i=1}^n w_i x_i \\&amp;+\mathbf{h}^T \sigma_L( \mathbf{W}_L ( \dots \sigma_1(\mathbf{W}_1 f_{BI}(\mathcal{V}_x) + \mathbf{b}_1)) \dots ) + \mathbf{b}_L)\end{align} \tag{5}$$ 模型参数$\Theta = \{ w_0, \{ w_i, \mathbf{v}_i \}, \mathbf{h}, \{\mathbf{W}_l, \mathbf{b}_l \} \}$ 目标函数由于该论文聚焦于回归任务，因此，作者采用了平方损失：$$L_{reg} = \sum_{\mathbf{x} \in \mathcal{X}} (\hat y(\mathbf{x}) - y(\mathbf{x}))^2 \tag{6}$$ 论文地址：http://staff.ustc.edu.cn/~hexn/papers/sigir17-nfm.pdf 实验代码：https://github.com/hexiangnan/neural_factorization_machine]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Deep Interest Network for Click-Through Rate Prediction]]></title>
    <url>%2F2019%2F12%2F24%2Frecommender-system-din%2F</url>
    <content type="text"><![CDATA[Deep Interest Network for Click-Through Rate Prediction是阿里巴巴发表在KDD 2018上的一篇论文。作者在常见的Embedding&amp;MLP范式中，引入了attention机制，极大地改进了模型的表达能力。 Motivation在Embedding&amp;MLP范式中，各种各样的用户兴趣被压缩到同一个长度固定的向量中，这限制了Embedding&amp;MLP方法的表达能力。此外，将某一用户的全部兴趣压缩到同一个向量中是没有必要的，因为当预测候选广告时，只有部分兴趣会影响他的行为。 Feature Representation Base Model 损失函数使用negative log-likelihood function：$$L = -\frac{1}{N}\sum_{(\mathbf{x}, y) \in \mathbf{S}}\left( y \log p(\mathbf{x}) + (1 - y) \log (1 - p(\mathbf{x})) \right) \tag{1}$$其中，S是大小为N的训练集，$\mathbf{x}$是模型的输入，$y \in \{ 0, 1 \}$是类别，$p(\mathbf{x})$是模型的输出。 Deep Interest Network $\mathcal{V}_U$为用户表示向量，A为候选广告：$$\mathcal{V}_U(A) = f(\mathcal{V}_A, \mathbf{e}_1, \mathbf{e}_2, \cdots, \mathbf{e}_H) = \sum_{j=1}^H a(\mathbf{e}_j, \mathcal{V}_A) \mathbf{e}_j = \sum_{j=1}^H \mathbf{w}_j \mathbf{e}_j \tag{2}$$其中，$\{\mathbf{e}_1, \mathbf{e}_2, \cdots, \mathbf{e}_H\}$是用户U历史行为的embedding向量构成的集合，$\mathcal{V}_A$表示广告A的embedding向量，$a(\mathbf{e}_j, \mathcal{V}_A)$是attention网络。 如上图所示，在attention网络中，除了用户和物品（广告）embedding向量外，它们的叉积也被喂进之后的网络中。 注意：在传统的attention方法中，$\sum_j \mathbf{w}_j = 1$。 为了保留用户兴趣的强度，这种约束被抛弃了，$a(\cdot)$没有使用softmax。 $\sum_j \mathbf{w}_j$可以看作被激活的用户兴趣强度的估计值。 正则项小批量敏感（mini-batch aware）的正则$$L_2(W) \approx \sum_{j=1}^K \sum_{m=1}^B \frac{\alpha_{mj}}{n_j}\left \Vert \mathbf{w}_j \right \Vert_2^2$$ 激活函数PReLU：$$f(s) =\begin{cases}s &amp; \mathrm{if\ s &gt; 0} \\\alpha s &amp; \mathrm{if\ s \le 0}\end{cases}= p(s) \cdot s + (1 - p(s)) \cdot \alpha s$$其中，$p(s) = I(s &gt; 0)$是指示函数，$\alpha$是一个可学习的参数。 由于PReLU采用了硬整流点（0），当每层的输入服从不同的分布时，可能不太适用。 作者提出了Dice$$f(s) = p(s) \cdot s + (1 - p(s)) \cdot \alpha s \\p(s) = \frac{1}{ 1 + e^{- \frac{ s - E[s] }{ \sqrt{Var[s] + \epsilon} }}}$$其中，$\epsilon$是一个很小的常量，作者将其设置为$10^{-8}$。 在训练阶段，E[s]和Var[s]是每个小批量输入的均值和方差； 在测试阶段，E[s]和Var[s]是通过在数据上移动E[s]和Var[s]的平均值来计算。 参考文献Guorui Zhou, Xiaoqiang Zhu, Chenru Song, Ying Fan, Han Zhu, Xiao Ma, Yanghui Yan, Junqi Jin, Han Li, and Kun Gai. 2018. Deep Interest Network for Click-Through Rate Prediction. In Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining (KDD ‘18). ACM, New York, NY, USA, 1059-1068. DOI: https://doi.org/10.1145/3219819.3219823]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python切片操作]]></title>
    <url>%2F2019%2F12%2F22%2Fpython-slicing%2F</url>
    <content type="text"><![CDATA[为了访问list、str等序列类型中某些元素所构成的子集，Python提供了一种简单的语法——切片。 切片语法普通切片切片操作的基本写法是somelist[start:end]，取值范围[start,end)，不包括end。 12a = list(range(10))a[2:4] # [2, 3] 如果从开头获取切片，则可以不写start。 123a[:4] # [0, 1, 2, 3]# a[0:4]等同于a[:4]print(a[0:4] == a[:4]) # True 同样地，如果切片要取到末尾，则可以不写end。 123a[4:] # [4, 5, 6, 7, 8, 9]# a[4:len(a)]等同于a[4:]print(a[4:len(a)] == a[4:]) 如果start和end都被省略，则表示原对象的一份拷贝。 123a[:] # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]a[:] == a # Truea[:] is a # False 在指定切片起止索引时，若要从尾部向前算，则可以使用负数来表示相关偏移量。 1234a[:-1] # [0, 1, 2, 3, 4, 5, 6, 7, 8]a[-5:] # [5, 6, 7, 8, 9]a[-5:-1] # [5, 6, 7, 8]a[2:-1] # [2, 3, 4, 5, 6, 7, 8] 对序列进行切片时，即使start或end索引越界也不会出问题。 12a[:20] # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]a[-20:] # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 对切片操作得到的新列表进行修改，不会影响原列表。 12345678&gt;&gt;&gt; b = a[:4]&gt;&gt;&gt; b[0, 1, 2, 3]&gt;&gt;&gt; b[1] = 100&gt;&gt;&gt; b[0, 100, 2, 3]&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9 带间隔的切片除了基本的切片操作外，Python还提供了somelist[start:end:step]的写法，表示在[start,end)内，以step为间隔取值。 123a = list(range(10))a[::2] # [0, 2, 4, 6, 8]a[1::2] # [1, 3, 5, 7, 9] Python中有一种常见的技巧——以-1为间隔，来反转列表或者字符串等。 1a[::-1] # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] 给切片赋值如果把切片放在赋值语句的左边，会把序列中处在指定范围内的对象替换为新值。 切片的长度与新值的个数无需相等。序列会根据新值的个数相应地扩张或收缩。 12345a = list(range(10))# 收缩 [0, 1, 20, 30, 5, 6, 7, 8, 9]a[2:5] = [20, 30]# 扩张 [0, 1, 20, 30, 40, 5, 6, 7, 8, 9]a[2:4] = [20, 30, 40] 如果把切片放在赋值语句的左边，那么右侧必须是个可迭代对象（即使只有单独一个值）。 注意下面的两种写法： 12a[2:5] = 100 # 错误的写法a[2:5] = [100] # 正确的写法 第一种写法将会导致如下的错误： 123Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: can only assign an iterable 将切片作为del操作的对象，可以删除序列中的元素。 123456&gt;&gt;&gt; a = list(range(10))&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; del a[2:5] &gt;&gt;&gt; a[0, 1, 5, 6, 7, 8, 9]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python函数注解]]></title>
    <url>%2F2019%2F12%2F20%2Fpython-function-annotations%2F</url>
    <content type="text"><![CDATA[Python3引入了一种新语法——函数注解，用于为函数声明中的参数和返回值添加注解。注解中最常用的类型是类（如str或者int）和字符串。 语法参数函数声明中的各个参数可以在:后增加注解表达式。 12def sum(a: int, b: int): return a + b 如果参数有默认值，注解放在参数名和=号之间，就像下面这样。 12def sum(a: int, b: int = 4): return a + b 返回值如果想注解返回值，在)和函数声明末尾的:之间添加-&gt;和注解表达式。 12def sum(a: int, b: int = 4) -&gt; int: return a + b 访问函数注解Python不会对注解做任何处理，只是将其存储在函数的__annotations__属性（一个字典）中。 12&gt;&gt;&gt; print(sum.__annotations__)&#123;'a': &lt;class 'int'&gt;, 'b': &lt;class 'int'&gt;, 'return': &lt;class 'int'&gt;&#125; return键保存的是返回值注解。 参考资料函数注解提案 https://www.python.org/dev/peps/pep-3107/]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Bayesian Probabilistic Matrix Factorization using Markov Chain Monte Carlo]]></title>
    <url>%2F2019%2F12%2F18%2Frecommender-system-bpmf%2F</url>
    <content type="text"><![CDATA[占坑，有空补上…]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 965.单值二叉树]]></title>
    <url>%2F2019%2F12%2F17%2Fleetcode-965-univalued-binary-tree%2F</url>
    <content type="text"><![CDATA[如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。只有给定的树是单值二叉树时，才返回 true；否则返回 false。 示例 1： 1234567 1 / \ 1 1 / \ \1 1 1输入：[1,1,1,1,1,null,1]输出：true 示例 2： 1234567 2 / \ 2 2 / \5 2 输入：[2,2,2,5,2]输出：false 提示： 给定树的节点数范围是 [1, 100]。 每个节点的值都是整数，范围为 [0, 99] 。 方法一：递归1234567891011121314151617# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isUnivalTree(self, root: TreeNode) -&gt; bool: if not root: return True if root.left and root.left.val != root.val: return False if root.right and root.right.val != root.val: return False return self.isUnivalTree(root.left) and self.isUnivalTree(root.right) 时间复杂度为O(N)，空间复杂度为O(H)。其中，N为二叉树的节点个数，H为二叉树的高度。 方法二：迭代12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isUnivalTree(self, root: TreeNode) -&gt; bool: stack = [root] while stack: node = stack.pop() if not node: continue if node.left and node.left.val != node.val: return False if node.right and node.right.val != node.val: return False stack.append(node.left) stack.append(node.right) return True 时间复杂度为O(N)，空间复杂度为O(1)。其中，N为二叉树的节点个数。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Probabilistic Matrix Factorization]]></title>
    <url>%2F2019%2F12%2F14%2Frecommender-system-pmf%2F</url>
    <content type="text"><![CDATA[为了更好地处理大型数据集以及评分较少的用户，作者提出了概率矩阵分解（PMF）模型。 待解决的问题传统的协同过滤方法有两个问题： 不能很好地处理大型数据集； 对于那些评分很少的用户，无法做出准确的预测。 符号说明 N表示用户数量，M表示物品数量。 $R_{ij}$表示用户i对物品j的评分，评分的取值范围为$\{ R_{ij} | 1 \le R_{ij} \le K \cap R_{ij} \mathrm{\ is\ integer} \}$。 $U \in R^{D \times N}$和$V \in R^{D \times M}$分别表示用户和物品的潜在特征矩阵，列向量$U_i$和$V_j$分别表示用户i和物品j的潜在特征向量。 模型结构 模型假设 假设评分服从均值为$U_i^T V_j$，方差为$\sigma^2$的正态分布，即$R_{ij} \sim N(U_i^T V_j, \sigma^2)$。$$p(R | U, V, \sigma^2) = \prod_{i=1}^N \prod_{j=1}^M \left [ \mathcal{N}(R_{ij} | U_i^T V_j, \sigma^2) \right]^{I_{ij}} \tag{1}$$其中，$\mathcal{N}(x | \mu, \sigma^2)$为正态分布的概率密度函数；$I_{ij}$为指示函数。$$I_{ij}(x) =\begin{cases} 1, &amp; \mathrm{if\ user\ i\ rated\ item\ j} \\ 0, &amp; \mathrm{otherwise}\end{cases} \tag{2}$$ 假设用户特征向量和物品特征向量都服从均值为0的正态分布，即$U_i \sim N(0, \sigma_U^2 \mathbf{I} ),\ V_j \sim N(0, \sigma_V^2 \mathbf{I})$。 $$p(U | \sigma_U^2) = \prod_{i=1}^N \mathcal{N} (U_i | 0, \sigma_U^2 \mathbf{I}) \\p(V | \sigma_V^2) = \prod_{j=1}^M \mathcal{N} (V_j | 0, \sigma_V^2 \mathbf{I})\tag{3}$$ 目标函数后验概率：$$\begin{align}p(U, V | R, \sigma^2, \sigma_U^2, \sigma_V^2)&amp;= \frac{ p(R | U, V, \sigma^2, \sigma_U^2, \sigma_V^2) \times p(U, V | \sigma^2, \sigma_U^2, \sigma_V^2) \times p(\sigma^2, \sigma_U^2, \sigma_V^2)}{ p(R, \sigma^2, \sigma_U^2, \sigma_V^2)} \\&amp;\propto p(R | U, V, \sigma^2) \times p(U, V | \sigma_U^2, \sigma_V^2) \\&amp;= p(R | U, V, \sigma^2) \times p(U | \sigma_U^2) \times p(V | \sigma_V^2) \\&amp;= \prod_{i=1}^N \prod_{j=1}^M \left [ \mathcal{N}(R_{ij} | U_i^T V_j, \sigma^2) \right ]^{I_{ij}}\times\prod_{i=1}^N \mathcal{N}(U_i | 0, \sigma_U^2 \mathbf{I})\times\prod_{j=1}^M \mathcal{N}(V_j | 0, \sigma_V^2 \mathbf{I})\end{align} \tag{4}$$两边取对数，得到：$$\begin{align}\ln p(U, V | R, \sigma^2, \sigma_U^2, \sigma_V^2)=&amp; \sum_{i=1}^N \sum_{j=1}^M I_{ij} \ln \mathcal{N}(R_{ij} | U_i^T V_j, \sigma^2) + \\&amp; \sum_{i=1}^N \ln \mathcal{N}(U_i | 0, \sigma_U^2 \mathbf{I}) +\sum_{j=1}^M \ln \mathcal{N}(V_j | 0, \sigma_V^2 \mathbf{I})\end{align} \tag{5}$$ 下面分别求解这三项：$$\begin{align}\sum_{i=1}^N \sum_{j=1}^M I_{ij} \ln \mathcal{N}(R_{ij} | U_i^T V_j, \sigma^2)&amp;= \sum_{i=1}^N \sum_{j=1}^M I_{ij} \ln \left( \frac{1}{ \sqrt{2 \pi} \sigma}\exp \{ -\frac{ (R_{ij} - U_i^T V_j)^2 }{ 2 \sigma^2 }\} \right) \\&amp;= -\frac{1}{ 2 \sigma^2} \sum_{i=1}^N \sum_{j=1}^M I_{ij} (R_{ij} - U_i^T V_j)^2 -\frac{1}{2} \sum_{i=1}^N \sum_{j=1}^M I_{ij} \ln \sigma^2 -\frac{1}{2} N M \ln (2 \pi)\end{align} \tag{6}$$ $$\begin{align}\sum_{i=1}^N \ln \mathcal{N}(U_i | 0, \sigma_U^2 \mathbf{I})&amp;= \sum_{i=1}^N \ln \frac{1}{ (2 \pi)^\frac{D}{2} \left \vert \sigma_U^2 \mathbf{I} \right \vert^{\frac{1}{2}}} \exp \{ -\frac{1}{2} U_i^T (\sigma_U^2 \mathbf{I})^{-1} U_i \} \\&amp;= -\frac{1}{2 \sigma_U^2} \sum_{i=1}^N U_i^T U_i -\frac{1}{2} N D \ln \sigma_U^2 -\frac{1}{2} N D \ln (2 \pi)\end{align} \tag{7}$$ $$\begin{align}\sum_{j=1}^M \ln \mathcal{N}(V_j | 0, \sigma_V^2 \mathbf{I})&amp;= \sum_{j=1}^M \ln \frac{1}{ (2 \pi)^\frac{D}{2} \left \vert \sigma_V^2 \mathbf{I} \right \vert^{\frac{1}{2}}} \exp \{ -\frac{1}{2} V_j^T (\sigma_V^2 \mathbf{I})^{-1} V_j \} \\&amp;= -\frac{1}{2 \sigma_V^2} \sum_{j=1}^M V_j^T V_j - \frac{1}{2} M D \ln \sigma_V^2 - \frac{1}{2} M D \ln (2 \pi)\end{align} \tag{8}$$将式(6)、(7)、(8)代入(5)中，得到：$$\begin{align}\ln p(U, V | R, \sigma^2, \sigma_U^2, \sigma_V^2)=&amp;-\frac{1}{ 2 \sigma^2} \sum_{i=1}^N \sum_{j=1}^M I_{ij} (R_{ij} - U_i^T V_j)^2 -\frac{1}{2 \sigma_U^2} \sum_{i=1}^N U_i^T U_i - \frac{1}{2 \sigma_V^2} \sum_{j=1}^M V_j^T V_j \\&amp;- \frac{1}{2} \sum_{i=1}^N \sum_{j=1}^M I_{ij} \ln \sigma^2 -\frac{1}{2} N D \ln \sigma_U^2 - \frac{1}{2} M D \ln \sigma_V^2 \\&amp;- \frac{1}{2} N M \ln (2 \pi) -\frac{1}{2} N D \ln (2 \pi) -\frac{1}{2} M D \ln (2 \pi) \\=&amp;- \frac{1}{ 2 \sigma^2} \sum_{i=1}^N \sum_{j=1}^M I_{ij} (R_{ij} - U_i^T V_j)^2 -\frac{1}{2 \sigma_U^2} \sum_{i=1}^N U_i^T U_i -\frac{1}{2 \sigma_V^2} \sum_{j=1}^M V_j^T V_j \\&amp;- \frac{1}{2} \left( \sum_{i=1}^N \sum_{j=1}^M I_{ij} \ln \sigma^2 + N D \ln \sigma_U^2 + M D \ln \sigma_V^2 \right)+ C\end{align} \tag{9}$$固定超参数，最大化式(9) 等价于最小化式(10)$$E = \frac{1}{2} \sum_{i=1}^N \sum_{j=1}^M I_{ij} (R_{ij} - U_i^T V_j)^2 +\frac{\lambda_U}{2} \sum_{i=1}^N \left \Vert U_i \right \Vert_F^2 +\frac{\lambda_V}{2} \sum_{j=1}^M \left \Vert V_j \right \Vert_F^2 \tag{10}$$其中，$\lambda_U = \frac{\sigma^2}{\sigma_U^2}$，$\lambda_V = \frac{\sigma^2}{\sigma_V^2}$ 学习算法下面使用随机梯度下降求解参数更新规则： 令$R_{U_i}^+$表示用户i评分过的物品集合，$R_{V_j}^+$表示与物品j交互过的用户的集合。$$\frac{\partial E}{\partial U_i} = - \sum_{j \in R_{U_i}^+} V_j (R_{ij} - U_i^T V_j) + \lambda_U U_i \\\frac{\partial E}{\partial V_j} = - \sum_{i \in R_{V_j}^+} U_i (R_{ij} - U_i^T V_j) + \lambda_V V_j\tag{11}$$令$e_{ij} = R_{ij} - U_i^T V_j$ 从而：$$U_i \leftarrow U_i - \eta( \sum_{j \in R_{U_i}^+} V_j e_{ij} - \lambda_U U_i) \\V_j \leftarrow V_j - \eta( \sum_{i \in R_{V_j}^+} U_i e_{ij} - \lambda_V V_j)\tag{12}$$其中，$\eta$为学习率。 优化与改进由于上述模型的预测分数可能会超出有效评分的范围，作者提出使用sigmoid函数，将输出限制在[0,1]区间内$$g(x) = \frac{1}{1+ e^{-x}} \tag{13}$$为了使输入评分与输出的预测分数相匹配，作者对输入评分$1,\cdots,K$进行了归一化$$t(x) = \frac{ x - 1 }{ K - 1 } \tag{14}$$]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 226.翻转二叉树]]></title>
    <url>%2F2019%2F12%2F11%2Fleetcode-226-invert-binary-tree%2F</url>
    <content type="text"><![CDATA[翻转一棵二叉树。 示例： 输入： 4 / \ 2 7 / \ / \ 1 3 6 9 输出： 12345 4 / \ 7 2 / \ / \9 6 3 1 方法一：递归123456789101112131415# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def invertTree(self, root: TreeNode) -&gt; TreeNode: if not root: return root node = root.left root.left = self.invertTree(root.right) root.right = self.invertTree(node) return root 方法二：迭代1234567891011121314151617181920# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def invertTree(self, root: TreeNode) -&gt; TreeNode: stack = [root] temp = None while stack: node = stack.pop() if node: temp = node.left node.left = node.right node.right = temp stack.append(node.left) stack.append(node.right) return root]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Collaborative Deep Learning for Recommender Systems]]></title>
    <url>%2F2019%2F12%2F10%2Frecommender-system-cdl%2F</url>
    <content type="text"><![CDATA[作者提出了一个分层的贝叶斯模型—— Collaborative Deep Learning（CDL），利用深度表示学习对物品的内容信息进行建模，并将其与针对评分矩阵的协同过滤整合在一起。 符号描述$\mathbf{X}_c \in \mathbb R^{J \times S}$表示由J个物品组成的矩阵，矩阵中的每一行j是一个词袋向量$\mathbf{X}_{c, j*}$（词汇表的大小为S）。 $\mathbf{R} = [R_{i,j}]_{I \times J}$表示由I个用户、J个物品组成的二元评分矩阵。 问题给定$\mathbf{R}$中的部分评分以及内容信息$\mathbf{X}_c$，预测$\mathbf{R}$中的其他评分。 CDL CDL的生成过程如下： 目标函数最大化后验概率等价于最大化$\mathbf{U}, \mathbf{V}, \{\mathbf{X}_l\}, \mathbf{X}_c, \{\mathbf{W}_l\}, \mathbf{b}_l, \mathbf{R}$的联合对数似然。 参数更新 预测$$ \mathbf{R}^*_{ij} \approx (\mathbf{u}_i^*)^T (f_e (\mathbf{X}_{0,j*}, \mathbf{W}^{+*})^T + \mathbf{\epsilon}^*_j) = (\mathbf{u}_i^*)^T \mathbf{v}_j^* $$]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux中存活下来之文本搜索grep]]></title>
    <url>%2F2019%2F12%2F08%2Flinux-command-grep%2F</url>
    <content type="text"><![CDATA[grep（Globally search a Regular Expression and Print） 选项 -E：支持正则表达式 i：忽略大小写 -v：打印不匹配的行]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 617.合并二叉树]]></title>
    <url>%2F2019%2F12%2F08%2Fleetcode-617-merge-two-binary-trees%2F</url>
    <content type="text"><![CDATA[给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 示例 1: 1234567891011121314输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树: 3 / \ 4 5 / \ \ 5 4 7 注意: 合并必须从两个树的根节点开始。 方法一：递归12345678910111213141516171819# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def mergeTrees(self, t1: TreeNode, t2: TreeNode) -&gt; TreeNode: if not t2: return t1 if not t1: return t2 t1.val += t2.val t1.left = self.mergeTrees(t1.left, t2.left) t1.right = self.mergeTrees(t1.right, t2.right) return t1 方法二：迭代123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def mergeTrees(self, t1: TreeNode, t2: TreeNode) -&gt; TreeNode: if not t1: return t2 if not t2: return t1 stack = [[t1, t2]] while stack: node = stack.pop() node[0].val += node[1].val if not node[0].left: node[0].left = node[1].left elif node[1].left: stack.append([node[0].left, node[1].left]) if not node[0].right: node[0].right = node[1].right elif node[1].right: stack.append([node[0].right, node[1].right]) return t1]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 101.对称二叉树]]></title>
    <url>%2F2019%2F12%2F06%2Fleetcode-101-symmetric-tree%2F</url>
    <content type="text"><![CDATA[给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \ 2 2 / \ / \ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \ 2 2 \ \ 3 3 说明: 如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 方法一：递归123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: if not root: return True return self.isSymmetric2(root.left, root.right) def isSymmetric2(self, node1: TreeNode, node2: TreeNode) -&gt; bool: if not node1 and not node2: return True if not node1 or not node2: return False if node1.val != node2.val: return False return self.isSymmetric2(node1.left, node2.right) and self.isSymmetric2(node1.right, node2.left) 方法二：迭代1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: if not root: return True stack = [root.left, root.right] while stack: node1 = stack.pop() node2 = stack.pop() if not node1 and not node2: continue if not node1 or not node2: return False if node1.val != node2.val: return False stack.append(node1.left) stack.append(node2.right) stack.append(node1.right) stack.append(node2.left) return True]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Fast Matrix Factorization for Online Recommendation with Implicit Feedback]]></title>
    <url>%2F2019%2F12%2F04%2Frecommender-system-eals%2F</url>
    <content type="text"><![CDATA[$$\hat r_{ui} = &lt;\mathbf{p}_u, \mathbf{q}_i&gt; = \mathbf{p}_u^T \mathbf{q}_i \tag{1}$$biasedMF$$\hat r_{ui} = b_u + b_i + &lt;\mathbf{p}_u^B, \mathbf{q}_i^B&gt;$$令$\mathbf{p}_u \leftarrow [\mathbf{p}_u^B, b_u, 1]$，$\mathbf{q}_i \leftarrow [\mathbf{p}_u^B, 1, b_i]$ 从而，可以将带偏置的矩阵分解归入式$$\hat r_{ui} = b_u + b_i + &lt;\mathbf{p}_u^B, \mathbf{q}_i^B&gt;=\begin{bmatrix}\mathbf{p}_u^B &amp; b_u &amp; 1\end{bmatrix}\begin{bmatrix}\mathbf{p}_u^B \\1 \\b_i\end{bmatrix}= \mathbf{p}_u^T \mathbf{q}_i$$目标函数：$$L = \sum_{u=1}^M \sum_{i=1}^N w_{ui} (r_{ui} - \hat r_{ui})^2 +\lambda ( \sum_{u=1}^M \left \Vert \mathbf{p}_u \right \Vert^2 + \sum_{i=1}^N \left \Vert \mathbf{q}_i \right \Vert^2) \tag{2}$$使用交替最小二乘法（Alternating Least Square, ALS）：迭代地优化一个参数，而保持其他参数不变 考虑$\mathbf{p}_u$：$$L_u = \left \Vert \mathbf{W}^u (\mathbf{r}_u - \mathbf{Q} \mathbf{p}_u)\right \Vert^2 + \lambda \left \Vert \mathbf{p}_u \right \Vert^2$$其中，$\mathbf{W}^u$是$N \times N$的对角矩阵，其对角元素$W_{ii}^u = w_{ui}$。 令$L_u$对$\mathbf{p}_u$的一阶导数等于0：$$\frac{ \partial L_u }{ \partial \mathbf{p}_u }= -2 \mathbf{Q}^T \mathbf{W}^u (\mathbf{r}_u - \mathbf{Q} \mathbf{p}_u) + 2 \lambda \mathbf{p}_u = 0 \\\begin{align}&amp;\Rightarrow ( \mathbf{Q}^T \mathbf{W}^u \mathbf{Q} + \lambda \mathbf{I} ) \mathbf{p}_u = \mathbf{Q}^T \mathbf{W}^u \mathbf{r}_u \\&amp;\Rightarrow \mathbf{p}_u = ( \mathbf{Q}^T \mathbf{W}^u \mathbf{Q} + \lambda \mathbf{I} )^{-1} \mathbf{Q}^T \mathbf{W}^u \mathbf{r}_u\end{align} \tag{3}$$其中，$\mathbf{I}$是单位矩阵。 给所有的缺失项赋相同的权重$w_0$$$\mathbf{Q}^T \mathbf{W}^u \mathbf{Q} = w_0 \mathbf{Q}^T \mathbf{Q} + \mathbf{Q}^T (\mathbf{W}^u - \mathbf{w}^0) \mathbf{Q} \tag{4}$$其中，$\mathbf{w}^0$是对角矩阵，其对角元素均为$w_0$。 由于$\mathbf{Q}^T \mathbf{Q}$独立于u，因此，它可以被预先计算好。 Element-wise ALS 令$\hat r_{ui} = \hat r_{ui}^f + p_{uf} q_{if}$，则公式（2）可重写为$$L = \sum_{u=1}^M \sum_{i=1}^N w_{ui} (r_{ui} - \hat r_{ui}^f - p_{uf} q_{if})^2 +\lambda ( \sum_{u=1}^M \left \Vert \mathbf{p}_u \right \Vert^2 + \sum_{i=1}^N \left \Vert \mathbf{q}_i \right \Vert^2)$$L对$p_{uf}$的的偏导数：$$\frac{ \partial L }{ \partial p_{uf} } = -2 \sum_{i=1}^N (r_{ui} - \hat r_{ui}^f - p_{uf} q_{if}) w_{ui} q_{if} + 2 \lambda p_{uf}$$令$\frac{ \partial L }{ \partial p_{uf} } = 0$，得到$p_{uf}$的解：$$p_{uf} = \frac{ \sum_{i=1}^N (r_{ui} - \hat r_{ui}^f) w_{ui} q_{if}}{ \sum_{i=1}^N w_{ui} q_{if}^2 + \lambda} \tag{5}$$相似地，我们可以得到$q_{if}$的解：$$q_{if} = \frac{ \sum_{u=1}^M (r_{ui} - \hat r_{ui}^f) w_{ui} p_{uf}}{ \sum_{u=1}^M w_{ui} p_{uf}^2 + \lambda} \tag{6}$$ $$L = \sum_{(u,i) \in \mathcal{R}} w_{ui} (r_{ui} - \hat r_{ui})^2 +\sum_{u=1}^M \sum_{i \notin \mathcal{R}_u} c_i \hat r_{ui}^2 + \\\lambda ( \sum_{u=1}^M \left \Vert \mathbf{p}_u \right \Vert^2 + \sum_{i=1}^N \left \Vert \mathbf{q}_i \right \Vert^2) \tag{7}$$其中，$c_i$是负反馈的置信度。$$c_i = c_0 \frac{ f_i^\alpha }{ \sum_{j=1}^N f_i^\alpha } \tag{8}$$其中，$c_0$决定缺失数据的全局权重；$f_i$表示物品i的流行度。$$f_i = \frac{ \left \vert \mathcal{R}_i \right \vert}{ \sum_{j=1}^N \left \vert \mathcal{R}_j \right \vert}$$此时，$$p_{uf} = \frac{ \sum_{i \in \mathcal{R}_u } (r_{ui} - \hat r_{ui}^f) w_{ui} q_{if} - \sum_{i \notin \mathcal{R}_u } \hat r_{ui}^f c_i q_{if}}{ \sum_{i \in \mathcal{R}_u } + \sum_{i \notin \mathcal{R}_u } c_i q_{if}^2 + \lambda} \tag{I}$$上式的计算瓶颈在于缺失数据项的相加 首先考虑分子：$$\begin{align}\sum_{i \notin \mathcal{R}_u } \hat r_{ui}^f c_i q_{if}&amp;= \sum_{i=1}^N \hat r_{ui}^f c_i q_{if} - \sum_{i \in \mathcal{R}_u } \hat r_{ui}^f c_i q_{if} \\&amp;= \sum_{i=1}^N c_i q_{if} \sum_{k \neq f} p_{uk} q_{ik} - \sum_{i \in \mathcal{R}_u } \hat r_{ui}^f c_i q_{if} \\&amp;= \sum_{k \neq f} p_{uk} \sum_{i=1}^N c_i q_{if} q_{ik} - \sum_{i \in \mathcal{R}_u } \hat r_{ui}^f c_i q_{if}\end{align} \tag{9}$$可以看到，上式主要的计算部分$\sum_{i=1}^N c_i q_{if} q_{ik}$独立于u。 令$\mathbf{S}^q = \sum_{i=1}^N c_i \mathbf{q}_i \mathbf{q}_i^T$ 则$$\sum_{i \notin \mathcal{R}_u } \hat r_{ui}^f c_i q_{if} = \sum_{k \neq f} p_{uk} s_{kf}^q - \sum_{i \in \mathcal{R}_u } \hat r_{ui}^f c_i q_{if} \tag{10}$$ 相似地，分母中$$\begin{align}\sum_{ i \notin \mathcal{R}_u } c_i q_{if}^2&amp;= \sum_{i=1}^N c_i q_{if}^2 - \sum_{i \in \mathcal{R}_u } c_i q_{if}^2 \\&amp;= s_{ff}^q - \sum_{i \in \mathcal{R}_u } c_i q_{if}^2\end{align} \tag{11}$$由式（I）、（10）以及（11）可得：$$p_{uf} = \frac{ \sum_{i \in \mathcal{R}_u } [ w_{ui} r_{ui} - (w_{ui} - c_i)\hat r_{ui}^f ] q_{if} - \sum_{k \neq f} p_{uk} s_{kf}^q}{ \sum_{i \in \mathcal{R}_u } (w_{ui} - c_i) q_{if}^2 + s_{ff}^q + \lambda} \tag{12}$$类似地可以得到$$q_{if} = \frac{ \sum_{u \in \mathcal{R}_i } [ w_{ui} r_{ui} - (w_{ui} - c_i)\hat r_{ui}^f ] p_{uf} - c_i \sum_{k \neq f} q_{ik} s_{kf}^p}{ \sum_{u \in \mathcal{R}_i } (w_{ui} - c_i) p_{uf}^2 + c_i s_{ff}^p + \lambda} \tag{12}$$其中，$\mathbf{S}^p = \mathbf{P}^T \mathbf{P}$ $$\begin{align}\sum_{u=1}^M \sum_{i=1}^N c_i \hat r_{ui}^2&amp;= \sum_{u=1}^M \sum_{i=1}^N c_i (\mathbf{p}_u^T \mathbf{q}_i)(\mathbf{q}_i^T \mathbf{p}_u) \\&amp;= \sum_{u=1}^M \mathbf{p}_u^T \sum_{i=1}^N (c_i \mathbf{q}_i \mathbf{q}_i^T) \mathbf{p}_u \\&amp;= \sum_{u=1}^M \mathbf{p}_u^T \mathbf{S}^q \mathbf{p}_u\end{align}$$因此，式（7）目标函数中$$\begin{align}\sum_{u=1}^M \sum_{i \notin \mathcal{R}_u} c_i \hat r_{ui}^2&amp;= \sum_{u=1}^M \sum_{i=1}^N c_i \hat r_{ui}^2 -\sum_{u=1}^M \sum_{i \in \mathcal{R}_u} c_i \hat r_{ui}^2 \\&amp;= \sum_{u=1}^M \mathbf{p}_u^T \mathbf{S}^q \mathbf{p}_u -\sum_{(u,i) \in \mathcal{R}} c_i \hat r_{ui}^2\end{align}$$]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Deep Neural Networks for YouTube Recommendations]]></title>
    <url>%2F2019%2F12%2F02%2Frecommender-system-youtube-dnn%2F</url>
    <content type="text"><![CDATA[深度学习在工业界推荐系统中的典型实例。 YouTube推荐系统架构 第一阶段：candidate generation model。从数百万的视频库中筛选出数百的候选项。 第二阶段：ranking model。对数百候选视频进行排序。 Candidate generation 候选生成模型利用了用户的观看历史、搜索历史、人口统计学特征以及简单的二元和连续特征（如性别、视频存在的时间等）。 平均池化。 候选生成模型使用用户最近一次的观看作为测试集，而没有采用传统的随机留一法（random hold-out）。因为随机留一法泄露了未来的信息，忽略了那些不对称的消费模式。 候选生成模型的网络结构遵循常见的塔型结构，即网络的底部最宽，之后每个隐含层的单元数量减半。 Ranking 深度排序模型利用了更多的特征，如 目标：预测预期的观看时长。 深度排序模型使用加权logistic回归作为输出层的激活函数。正样本的权重为观看时长，而负样本的权重为1。 一个事件的几率（odds）是指该事件发生的概率与该事件不发生的概率的比值。 如果事件发生的概率为p，那么该事件的几率为$\frac{p}{1-p}$，该事件的对数几率或logit函数为：$$\ln (odds) = \ln \frac{p}{1 - p}$$logistic回归模型：$$P(Y=1|x) = \frac{1}{1 + e^{-(Wx+b)}}$$Y=1的对数几率为：$$\ln odds = \ln \frac{P(Y=1|x)}{1-P(Y=1|x)} = Wx + b$$对两边进行变换，可以得到：$$odds = \frac{p}{1-p} = e^{W x + b}$$采用加权logistic回归，视频i被观看的几率为$$\mathrm{odds(i)} = \frac{ T_i p}{ 1 - T_i p}= \frac{ E(T_i)}{ 1 - T_i p}$$其中，p是样本i被点击的概率，$T_i$表示样本i的观看时长，$E(T_i)$是样本i观看时长的期望。 假定$T_i p$很小，根据泰勒公式$$\frac{1} {1-x} = 1 + x + O(x^2)$$从而：$$\begin{align}\mathrm{odds(i)}&amp;\approx E(T_i) (1 + T_i p) \\&amp;\overset{p\ is\ small}{\approx} E(T_i)\end{align}$$由于p很小，因此，odds(i)近似等于$E(T_i)$。 在serving阶段，使用指数函数$e^{Wx+b}$作为最终的激活函数，得到的结果就是预期的观看时长。]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux中存活下来之head和tail]]></title>
    <url>%2F2019%2F12%2F01%2Flinux-command-head-and-tail%2F</url>
    <content type="text"><![CDATA[head和tail是Linux中经常使用的查看文件内容的命令。 headhead – display first lines of a file 1head [-n count | -c bytes] [file ...] n：显示文件的前n行。n默认为10。 c：显示文件的前c个字节。n默认为为10。 不带参数的head等价于head -n 10。 如果指定了多个文件，则每个文件前面都有一个由字符串“ ==&gt; XXX &lt;== ”组成的标头，其中XXX是文件名称。 tailtail – display the last part of a file 1tail [-F | -f | -r] [-q] [-b number | -c number | -n number] [file ...] b：显示文件的后number个512字节块。 c：显示文件的后number个字节。 n：显示文件的后number行 q：不显示文件名称。 r：按照从后往前的顺序输出。 如果指定了多个文件，则每个文件前面都有一个由字符串“ ==&gt; XXX &lt;== ”组成的标头，其中XXX是文件名称。 如果指定了-q参数，则不会输出由字符串“ ==&gt; XXX &lt;== ”组成的标头。 Numbers having a leading plus (+&#39;) sign are relative to the beginning of the input, for example, `-c +2’’ starts the display at the second byte of the input. Numbers having a leading minus (-&#39;) sign or no explicit sign are relative to the end of the input, for example, `-n 2’’ displays the last two lines of the input. The default starting loca- tion is -n 10’’, or the last 10 lines of the input.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux中存活下来之wc命令]]></title>
    <url>%2F2019%2F11%2F30%2Flinux-command-wc%2F</url>
    <content type="text"><![CDATA[wc：word, line, character, and byte count 1wc [-clmw] [file ...] c：byte，统计字节数。该选项会取消它前面的m。当采用uft-8编码时，一个汉字占用三个字节。 12345hgs:Desktop hegongshan$ cat test.txt My name is He Gongshan. # 24个字节湖北 武汉 # 4个汉字占用12个字节，空格和换行2个字节hgs:Desktop hegongshan$ wc -c test.txt 38 test.txt l：line，统计行数。该选项统计的是换行符。最后一个换行符之后的字符不会被统计。 12345678910hgs:Desktop hegongshan$ cat test.txt My name is He Gongshan.湖北 武汉 # 末尾有换行符hgs:Desktop hegongshan$ wc -l test.txt 2 test.txthgs:Desktop hegongshan$ cat test2.txt My name is He Gongshan.湖北 武汉hgs:Desktop hegongshan$ # 末尾没有换行符hgs:Desktop hegongshan$ wc -l test2.txt 1 test2.txt m：character，统计字符数。该选项会取消它后面的c。 12345hgs:Desktop hegongshan$ cat test.txt My name is He Gongshan. # 24个字符（末尾有一个换行符）湖北 武汉 # 6个字符（末尾有一个换行符）hgs:Desktop hegongshan$ wc -m test.txt 30 test.txt w：word，统计单词数。按照英语的习惯，空格隔开算一个单词。 12345hgs:Desktop hegongshan$ cat test.txt My name is He Gongshan. # 5个单词湖北 武汉 # 2个单词hgs:Desktop hegongshan$ wc -w test.txt 7 test.txt 注意，c和m不能同时使用。按照行数、单词数、字节数/字符数以及文件名的顺序输出。 默认情况，wc命令将使用c、l和w三个参数。 12345hgs:Desktop hegongshan$ cat test.txtMy name is He Gongshan.湖北 武汉hgs:Desktop hegongshan$ wc test.txt 2 7 38 test.txt 当统计多个文件时，除了输出每个文件的各项统计数据外，还将输出总共的统计数据。 123456789hgs:Desktop hegongshan$ cat test.txt hgs.txtMy name is He Gongshan.湖北 武汉Wuhan Hubei China中国hgs:Desktop hegongshan$ wc test.txt hgs.txt 2 7 38 test.txt 2 4 25 hgs.txt 4 11 63 total]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人月神话》阅读笔记]]></title>
    <url>%2F2019%2F11%2F29%2Fthe-mythical-man-month%2F</url>
    <content type="text"><![CDATA[软件工程 焦油坑贯彻执行为什么巴比伦塔会失败其缺乏两个方面，其一是交流；其二是交流的结果——组织。 团队如何进行相互之间的交流沟通？ 非正式途径。如打电话。 会议。常规项目会议。 工作手册。项目工作手册不是一篇独立的文档，它是对项目必须产出的一系列文档进行组织的一种结构。这包括目的、外部规格说明、接口说明、技术标准、内部说明和管理备忘录。 交流和交流的结果——组织，是成功的关键。交流和组织的技能需要管理者仔细考虑，相关经验的积累和能力的提高同软件技术本身一样重要。]]></content>
      <categories>
        <category>software engineering</category>
      </categories>
      <tags>
        <tag>software engineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python集合（set）]]></title>
    <url>%2F2019%2F11%2F28%2Fpython-set%2F</url>
    <content type="text"><![CDATA[set和dict类似，也是一组key的集合，但不存储value。 初始化像dict一样，集合也可以通过构造方法或者花括号{}来创建。 创建空集合注意下面两种写法的区别： 1234567# 创建空字典x = &#123;&#125;print(type(x))# 创建空集合x = set()print(type(x)) 输出： 12&lt;class 'dict'&gt;&lt;class 'set'&gt; 创建非空集合123456789# 使用花括号创建集合x = &#123;1, 2&#125;print(type(x), x)# 使用构造器创建集合y = set([1, 2])print(type(y), y)print(x == y) 输出： 123&lt;class 'set'&gt; &#123;1, 2&#125;&lt;class 'set'&gt; &#123;1, 2&#125;True 添加元素add方法每次添加一个元素到集合中。如果该元素已经在集合中，调用该方法将不会有任何效果。 1234567test_set = set()test_set.add(1)print(test_set)# 添加集合中已有的元素test_set.add(1)print(test_set) 输出： 12&#123;1&#125;&#123;1&#125; 删除元素使用poppop方法删除并返回任意的集合元素。若集合为空，将导致KeyError。 12345678x = set([1,2])print(x.pop())print(x)print(x.pop())print(x)print(x.pop()) 输出： 12345671&#123;2&#125;2set()Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;KeyError: 'pop from an empty set' 删除指定元素remove方法可以删除集合中的指定元素。若该元素不在集合中，将导致KeyError。 12345x = &#123;1, 2&#125;x.remove(2)print(x)x.remove(3) 输出： 1234&#123;1&#125;Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;KeyError: 3 discard方法也可以删除集合中的指定元素。若该元素不在集合中，则什么也不会发生。 12345x = &#123;1, 2&#125;x.discard(2)print(x)x.discard(3) 输出： 1&#123;1&#125; 注意remove方法和discard方法的区别：若待删除的元素不在集合中，remove方法将产生KeyError；而discard方法什么也不会发生。 删除所有元素clear方法可以删除集合中的所有元素。 12345x = &#123;1, 2, 3&#125;print(x)x.clear()print(x) 输出： 12&#123;1, 2, 3&#125;set() 合并集合使用unionunion方法可以合并多个集合，并返回合并后的集合，但调用该方法的集合不会变化。 1234567x = &#123;1, 2, 3&#125;y = &#123;4, 5, 6&#125;z = &#123;7, 8, 9&#125;k = x.union(y, z)print(k)print(x, y, z) 输出： 12&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;&#123;1, 2, 3&#125; &#123;4, 5, 6&#125; &#123;8, 9, 7&#125; 可以看到，调用union方法后，x本身并未发生改变，而是创建了一个新的集合。 使用updateupdate方法会将其他集合合并到当前集合中。 123456x = &#123;1, 2, 3&#125;y = &#123;4, 5, 6&#125;z = &#123;7, 8, 9&#125;x.update(y, z)print(x) 输出： 1&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125; 可以看到，调用update后，x发生了变化。 集合交intersection可以求多个个集合的交集。 123456789101112x = &#123;1, 2, 3&#125;y = &#123;2, 3, 4&#125;z = &#123;3, 4, 5&#125;# 合并两个集合print(x.intersection(y))# 合并多个集合k = x.intersection(y, z)print(k)# x没有被改变print(x) 输出： 123&#123;2, 3&#125;&#123;3&#125;&#123;1, 2, 3&#125; 集合差difference方法可以求两个或多个集合的差。 123456789x = &#123;1, 2, 3&#125;y = &#123;2, 3, 4&#125;z = &#123;3, 4, 5&#125;# x - yprint(x.difference(y))# x - y - zprint(x.difference(y, z)) 输出： 12&#123;1&#125;&#123;1&#125; 复制集合copy方法可以返回集合的浅拷贝。 12345x = &#123;1, 2, 3&#125;y = x.copy()print(y)print(x is y) 输出： 12&#123;1, 2, 3&#125;False]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令总结]]></title>
    <url>%2F2019%2F11%2F25%2Fgit%2F</url>
    <content type="text"><![CDATA[作为当前最优秀的版本控制系统（version control system），Git需要熟练掌握。 clone：从远程克隆仓库到本地 git init：初始化 当前改变 add：将文件添加到索引中。 1git add mv：等同于Linux中的mv命令，用于文件重命名或者移动文件。 reset：版本回退。 rm：等同于Linux中的rm命令，用于删除文件。 log：查看日志信息 show status：查看工作目录的当前状态 branch：查看仓库的分支 删除分支： 1git branch -d branch -m checkout：切换分支 checkout -b：创建一个新分支，并切换到该分支 git commit -m，–message git diff git merge git tag -d，–delete：删除标签 -l，–list：列出所有的标签 git fetch git pull push：推送到远程仓库的指定版本 git remote help：查看命令的帮助信息]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 509.斐波那契数]]></title>
    <url>%2F2019%2F11%2F24%2Fleetcode-509-fibonacci-number%2F</url>
    <content type="text"><![CDATA[斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： 12F(0) = 0, F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1. 给定 N，计算 F(N)。 示例 1： 123输入：2输出：1解释：F(2) = F(1) + F(0) = 1 + 0 = 1. 示例 2： 123输入：3输出：2解释：F(3) = F(2) + F(1) = 1 + 1 = 2. 示例 3： 123输入：4输出：3解释：F(4) = F(3) + F(2) = 2 + 1 = 3. 提示：0 ≤ N ≤ 30 方法一：递归12345678class Solution: def fib(self, N: int) -&gt; int: # 递归 if N == 0: return 0 if N == 1: return 1 return self.fib(N-1) + self.fib(N-2) 上述解法虽然形式简单，但时间复杂度为$O(2^n)$。 方法二：动态规划1234567891011class Solution: def fib(self, N: int) -&gt; int: # 动态规划 if N == 0: return 0 if N == 1: return 1 arr = [0, 1] for i in range(2, N+1): arr.append(arr[i-1] + arr[i-2]) return arr[N] 该方法的时间复杂度和空间复杂度均为O(n)。 上述方法仍可以进一步优化 123456789101112class Solution: def fib(self, N: int) -&gt; int: if N == 0: return 0 if N == 1: return 1 pre = 0 cur = 1 for i in range(2, N+1): cur += pre pre = cur - pre return cur 此时，时间复杂度不变，空间复杂度为O(1)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字典（dict）]]></title>
    <url>%2F2019%2F11%2F23%2Fpython-dict%2F</url>
    <content type="text"><![CDATA[dict是Python中的标准映射类型，可以存储任意类型对象。 创建字典字典可以通过将以逗号分隔的 键: 值 对列表包含于花括号{}之内来创建，也可以通过dict构造器来创建。 使用花括号{}1234567# 创建一个空字典test_dict = &#123;&#125;print(test_dict)print(type(test_dict))test_dict2 = &#123;'date': 2019, 12: 2020&#125;print(test_dict2) 输出： 123&#123;&#125;&lt;class 'dict'&gt;&#123;'date': 2019, 12: 2020&#125; 使用dict构造器字典dict类有四个初始化方法，函数原型如下： 12345678# 创建一个空字典dict()# 使用映射对象创建字典dict(mapping)# 使用iterable对象创建字典dict(iterable)# 使用键值对创建字典dict(**kwargs) dict(iterable)通过如下的方式创建字典 123d = &#123;&#125;for k, v in iterable: d[k] = v 示例： 1234567891011test_dict1 = dict()# 使用映射对象创建字典test_dict2 = dict(zip(['name','age'], ['gongshan',24]))# 使用iterable对象创建字典test_dict3 = dict([('name','gongshan'), ('age',24)])# 使用键值对创建字典test_dict4 = dict(name='gongshan', age=24)print(test_dict1)print(test_dict2 == test_dict3 == test_dict4)print(test_dict2) 输出： 123&#123;&#125;True&#123;'name': 'gongshan', 'age': 24&#125; 访问元素使用d[key]返回键key对应的值。 12345test_dict = &#123;'name': 'gongshan', 'age': 24&#125;# 访问元素print(test_dict['name'])print(test_dict['age']) 输出： 12gongshan24 使用get方法函数原型： 1get(key[, default]) 如果键名key存在，则返回对应的值value；否则，返回default（键值对key=default不会加入字典中）。default默认为None。 示例： 12345678910test_dict = &#123;'name': 'gongshan', 'age': 24&#125;# 访问存在的键名print(test_dict.get('name'))# 访问不存在的键名，默认值为Noneprint(test_dict.get('sex'))# 为不存在的键名key，设置默认值print(test_dict.get('sex','male'))print(test_dict) 输出： 123456gongshanNonemale&#123;'name': 'gongshan', 'age': 24&#125; 使用setdefault方法函数原型： 1setdefault(key[, default]) 如果键key存在，则返回其值；否则，插入值为default的键key，并返回default。default默认为None。 setdefault方法和get方法的不同之处：setdefault方法会将不存在的键key及其值default插入字典中，而get方法并不会。 示例： 1234567891011121314test_dict = &#123;'name': 'gongshan', 'age': 24&#125;# 键存在value = test_dict.setdefault('name')print(value)# 键不存在value = test_dict.setdefault('sex')print(value)print(test_dict)# 键不存在，但设置了默认值value = test_dict.setdefault('address','wuhan')print(value)print(test_dict) 输出： 1234567gongshanNone&#123;'name': 'gongshan', 'age': 24, 'sex': None&#125;wuhan&#123;'name': 'gongshan', 'age': 24, 'sex': None, 'address': 'wuhan'&#125; 添加/修改元素使用如下的语法添加/修改字典的元素： 1字典[键] = 值 示例： 12345678910test_dict = &#123;'name': 'gongshan', 'age': 24&#125;print(test_dict)# 添加元素test_dict['sex'] = 'male'print(test_dict)# 修改name的值test_dict['name'] = 'Gongshan He'print(test_dict) 输出： 123&#123;'name': 'gongshan', 'age': 24&#125;&#123;'name': 'gongshan', 'age': 24, 'sex': 'male'&#125;&#123;'name': 'Gongshan He', 'age': 24, 'sex': 'male'&#125; 删除元素使用关键字del123456test_dict = &#123;'name': 'gongshan', 'age': 24&#125;print(test_dict)# 删除键名为name的元素del test_dict['name']print(test_dict) 输出： 12&#123;'name': 'gongshan', 'age': 24&#125;&#123;'age': 24&#125; 使用pop方法函数原型如下： 12# d是一个可选的位置参数pop(self, k, d=None): 如果键key在字典中，则将其删除并返回其值；否则，返回d。如果d未给出且key不存在，则会引发KeyError。 示例： 1234567891011test_dict = &#123;'name': 'gongshan', 'age': 24&#125;# 删除namevalue = test_dict.pop('name')print(test_dict)# 删除一个不存在的键test_dict.pop('sex')# 删除一个不存在的键，并指明defaultvalue = test_dict.pop('sex', 'male')print(value) 输出： 12345&#123;'age': 24&#125;Traceback (most recent call last): File "&lt;stdin&gt;", line 2, in &lt;module&gt;KeyError: 'sex'male 使用popitem方法从字典中删除并返回一个(键，值)。删除时，遵循后进先出（LIFO）的顺序。如果字典为空，则会引发KeyError。 1234test_dict = &#123;'name': 'gongshan', 'age': 24&#125;print(test_dict.popitem())print(test_dict.popitem())print(test_dict.popitem()) 输出： 12345('age', 24)('name', 'gongshan')Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;KeyError: 'popitem(): dictionary is empty' 遍历字典遍历字典中的键如果只想遍历字典的键，使用dict的keys方法。 12345test_dict = &#123;'name': 'gongshan', 'age': 24&#125;print(test_dict.keys())for k in test_dict.keys(): print(k) 输出： 123dict_keys(['name', 'age'])nameage 遍历字典中的值如果只想遍历字典的键，使用dict的values方法。 12345test_dict = &#123;'name': 'gongshan', 'age': 24&#125;print(test_dict.values())for v in test_dict.values(): print(v) 输出： 123dict_values(['gongshan', 24])gongshan24 遍历字典中的(键,值)对如果想要遍历字典中的(键,值)对，可以使用dict的values方法。 12345test_dict = &#123;'name': 'gongshan', 'age': 24&#125;print(test_dict.items())for k, v in test_dict.items(): print(k,v) 输出： 123dict_items([('name', 'gongshan'), ('age', 24)])name gongshanage 24 复制字典dict的copy方法，可以返回原字典的浅拷贝。 12345test_dict = &#123;'name': 'gongshan', 'age': 24&#125;test_dict2 = test_dict.copy()print(test_dict2)print(test_dict is test_dict2) 输出： 12&#123;'name': 'gongshan', 'age': 24&#125;False 清空字典dict的clear方法，可以删除字典中的所有元素。 123test_dict = &#123;'name': 'gongshan', 'age': 24&#125;test_dict.clear()print(test_dict) 输出： 1&#123;&#125; 判断字典是否为空 在条件判断中，空字典表示False。 1234test_dict = &#123;&#125;# 若为空if not test_dict: print('dict is empty.') 输出： 1dict is empty. 判断长度是否为0 1234test_dict = &#123;&#125;# 若为空if len(test_dict) == 0: print('dict is empty.') 输出： 1dict is empty. 判断键是否在字典中使用key in dict语法，可以判断key是否在dict中。如果key在dict中，则返回True；否则，返回False。 123test_dict = &#123;'name': 'gongshan', 'age': 24&#125;print('sex' in test_dict)print('sex' not in test_dict) 输出： 12FalseTrue]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统相关资源]]></title>
    <url>%2F2019%2F11%2F21%2Frecommender-system-resource%2F</url>
    <content type="text"><![CDATA[SIGIR 2020-01-15 IJCAI 2020-01-15 ICWE 2020-01-19 ICML 截稿时间 2020-01-31 KDD 截稿时间 2020-02-13 ECML-PKDD 2020-03-19 相关会议推荐系统专会RecSys - ACM Conference on Recommender Systems 数据挖掘CCF A SIGKDD - ACM Knowledge Discovery and Data Mining dblp ICDE - IEEE International Conference on Data Engineering dblp SIGIR - International Conference on Research on Development in Information Retrieval dblp CCF B CIKM - ACM International Conference on Information and Knowledge Management dblp WSDM - ACM International Conference on Web Search and Data Mining dblp ICDM - International Conference on Data Mining dblp SDM - SIAM International Conference on Data Mining dblp 人工智能CCF A AAAI - AAAI Conference on Artificial Intelligence dblp NeurIPS - Annual Conference on Neural Information Processing Systems dblp IJCAI - International Joint Conference on Artificial Intelligence dblp CCF B UAI - International Conference on Uncertainty in Artificial Intelligence dblp WebCCF A WWW - International World Wide Web Conferences dblp 相关期刊数据挖掘CCF A TOIS - ACM Transactions on Information Systems dblp TKDE - IEEE Transactions on Knowledge and Data Engineering dblp 会议时间Conference Partner (会伴) CCF会议 https://www.myhuiban.com/conferences/ccf 在线查看各个会议的截稿时间 数据集 MovieLens https://grouplens.org/datasets/movielens/ Last.fm https://grouplens.org/datasets/hetrec-2011/ Pinterest https://sites.google.com/site/xueatalphabeta/academic-projects Amazon http://jmcauley.ucsd.edu/data/amazon/ Netflix https://www.kaggle.com/netflix-inc/netflix-prize-data 相关工具/仓库 LibRec: A Leading Java Library for Recommender Systems Best practice https://github.com/microsoft/recommenders Must-read papers https://github.com/hongleizhang/RSPapers Classic papers https://github.com/wzhe06/Reco-papers 相关学者 何向南 http://staff.ustc.edu.cn/~hexn/ 郭贵冰 https://guoguibing.github.io 王灏 http://www.wanghao.in 相关书籍 《推荐系统实践》，人民邮电出版社 《Recommender Systems Handbook》（推荐系统 技术、评估及高效算法，机械工业出版社）]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Wide & Deep Learning for Recommender Systems]]></title>
    <url>%2F2019%2F11%2F20%2Frecommender-system-wide%26deep%2F</url>
    <content type="text"><![CDATA[Memorization Generalization impression feature cross-product transformation Memorization can be loosely defined as learning the frequent co-occurrence of items or features and exploiting the correlation available in the historical data. Generalization, on the other hand, is based on transitivity of correlation and explores new feature combinations that have never or rarely occurred in the past. Wide &amp; Deep LearningWide$$y = \mathbf{w}^T \mathbf{x} + b$$ 其中，$\mathbf{x} = [x_1,x_2,\cdots,x_d]$ 既包含原始特征，又包含转换特征。$$\phi_k(\mathbf{x}) = \prod_{i=1}^d x_i^{c_{ki}} \quad c_{ki} \in \{ 0,1 \}$$]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVD++]]></title>
    <url>%2F2019%2F11%2F18%2Frecommender-system-svdplusplus%2F</url>
    <content type="text"><![CDATA[SVD++源自于Koren在2008年发表在KDD上Factorization Meets the Neighborhood: a Multifaceted Collaborative Filtering Model一文。 SVD++$$\hat r_{ui} = b_{ui} + q_i^T\left( p_u + \left \vert N(u) \right \vert^{-\frac{1}{2}} \sum_{j \in N(u)} y_j\right) \tag{7}$$ 其中，$p_u$从显式评分中学习，$\left \vert N(u) \right \vert^{-\frac{1}{2}} \sum_{j \in N(u)} y_j $从隐式反馈的角度来考虑，二者互相补充。 在SVD++中，用户被表示为$\left( p_u + \left \vert N(u) \right \vert^{-\frac{1}{2}}\sum_{j \in N(u)} y_j \right)。$ https://github.com/guoguibing/librec/blob/3.0.0/core/src/main/java/net/librec/recommender/cf/rating/SVDPlusPlusRecommender.java]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Collaborative Denoising Auto-Encoders for Top-N Recommender Systems]]></title>
    <url>%2F2019%2F11%2F13%2Frecommender-system-cdae%2F</url>
    <content type="text"><![CDATA[参考文献Y. Wu, C. DuBois, A. X. Zheng, and M. Ester.Collaborative denoising auto-encoders for top-n recommender systems. In WSDM, pages 153–162, 2016.]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Deep Item-based Collaborative Filtering for Top-N Recommendation]]></title>
    <url>%2F2019%2F11%2F13%2Frecommender-system-deepicf%2F</url>
    <content type="text"><![CDATA[作者提出了基于深度神经网络的item-based CF（DeepICF），同时学习物品之间的二元关系和高层关系。 DeepICF Input &amp; Embedding Layer对于目标物品i，使用其ID表示它，然后将其转换为embedding向量$\mathbf{p}_i \in \mathbb{R}^k$，k表示embedding size。 对于用户u，使用其交互过的物品$\mathcal{R}_u^+$的ID表示它。 然后，将用户u的每一个历史物品$j \in \mathcal{R}_u^+$，转换为embedding向量$\mathbf{q}_j \in \mathbb{R}^k$。 Pairwise Interaction Layer作者使用逐元素相乘来捕获物品之间的二元关系。 该层的输出结果：$\mathcal{V}_{ui} = \{ \mathbf{q}_j \odot \mathbf{p}_i | j \in \mathcal{R^+_u} \setminus i \}$ Pooling Layer由于不同用户的历史物品数量并不相同，因此，pairwise interaction层的输出大小会发生变化。对此，作者使用池化层将其转换为固定大小的向量。 方法一：加权平均池化 $$f_{avg}(\mathcal{V}_{ui}) = \frac{1}{ \left \vert \mathcal{V}_{ui} \right \vert^\alpha} \sum_{\mathbf{v} \in \mathcal{V}_{ui}} \mathbf{v}= \frac{1}{ (\left \vert \mathcal{R}_u^+ \right \vert - 1)^\alpha} (\sum_{j \in \mathcal{R^+_u} \setminus i} \mathbf{q}_j \odot \mathbf{p}_i) \tag{1}$$ 其中，$\alpha$是归一化超参数。 然而，加权平均池化的不足之处在于：假定用户的历史物品对目标物品的预测贡献相同。 方法二：基于attention的池化 $$f_{att}(\mathcal{V}_{ui}) = \frac{1}{ \left \vert \mathcal{V}_{ui} \right \vert^\alpha} \sum_{\mathbf{v} \in \mathcal{V}_{ui}} a(\mathbf{v}) \cdot \mathbf{v}= \frac{1}{ (\left \vert \mathcal{R}_u^+ \right \vert - 1)^\alpha} \sum_{j \in \mathcal{R^+_u} \setminus i} a(\mathbf{q}_j \odot \mathbf{p}_i) \cdot (\mathbf{q}_j \odot \mathbf{p}_i) \tag{2}$$ 其中，$a(\mathbf{v})$是attention函数。 作者使用包含一个隐含层的MLP作为attention网络。 $$a(\mathbf{v}) = \mathrm{softmax}^\prime (\mathbf{h}^T ReLU(\mathbf{Wv + b})) \tag{3}$$其中，$\mathbf{W} \in \mathbb{R}^{k^\prime \times k}$、$\mathbf{b} \in \mathbb{R}^{k^\prime}$分别表示attention网络的权重矩阵和偏差向量；$k^\prime$表示隐含层的大小； $\mathbf{h } \in \mathbb{R}^{k^\prime}$表示attention网络输出层的权重； $\mathrm{softmax}^\prime$是softmax函数的变体：$$\mathrm{softmax}^\prime (a(\mathbf{v})) = \frac{ \exp a(\mathbf{v})}{ [\sum_{\mathbf{v} \in \mathcal{V}_{ui}} \exp a(\mathbf{v})]^\beta} \tag{4}$$其中，$\beta$是平滑指数。 Deep Interaction Layer用$\mathbf{e}_{ui}$表示池化层的输出向量。 在池化层之上，作者提出使用MLP对物品之间的高层关系进行建模。$$\mathbf{e}_1 = ReLU(\mathbf{W}_1 \mathbf{e}_{ui} + \mathbf{b}_1) \\\mathbf{e}_2 = ReLU(\mathbf{W}_2 \mathbf{e}_1 + \mathbf{b}_2) \\\dots \\\mathbf{e}_L = ReLU(\mathbf{W}_L \mathbf{e}_{L-1} + \mathbf{b}_L) \tag{5}$$其中，$\mathbf{W}_l$、$\mathbf{b}_l$和$\mathbf{e}_l$分别表示第l个隐含层的权重矩阵、偏差向量和输出向量。 Prediction Layer$$\hat y_{ui} = \mathbf{z}^T \mathbf{e}_L + b_u + b_i \tag{6}$$ 其中，$\mathbf{z}$、$b_u$和$b_i$分别为预测层的权重向量、用户偏差和物品偏差。 目标函数$$\mathcal{L} = \frac{-1}{\left \vert \mathcal{R}^+\right \vert + \left \vert \mathcal{R}^-\right \vert}\left [\sum_{(u,i) \in \mathcal{R}^+} \log \delta(\hat y_{ui}) +\sum_{(u,i) \in \mathcal{R}^-} \log ( 1 - \delta(\hat y_{ui}) )\right ] +\lambda \left \Vert \Theta \right \Vert^2 \tag{7}$$ 其中，$\delta(\cdot)$是sigmoid函数；$\mathcal{R}^+$是正样本，$\mathcal{R}^-​$是负样本。 参考文献Deep Item-based Collaborative Filtering for Top-N Recommendation Feng Xue, Xiangnan He, Xiang Wang, Jiandong Xu, Kai Liu, &amp; Richang Hong, ACM Transactions on Information Systems (TOIS 2019). [PDF] [Codes]]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文中经常使用的词组]]></title>
    <url>%2F2019%2F11%2F11%2Fpaper-phrase%2F</url>
    <content type="text"><![CDATA[日积月累，以备写作之需。 1.without special mention / unless stated differently / unless specified / unless otherwise stated / without additional explanation / without special declaration 2.符号表示 denote A by B，用B表示A set A to B，将A设置为B refer to A as B 将A称为B replace A by B 用B替换A to be specific / specifically to be fair leave … as future work other than take … into consideration/account account for provide A with B distinguish A from B associate A with B relate A to B combine A with B replace A with B 用B代替A be formulated as 归结为 include but are not limited to n. / doing 包括但不限于 be limited by notably 显著地；尤其 rely on in addition as a consequence 因此 to this end notably / noticeably 显著地 namely to our best knowledge / to the best of our knowledge 据我们所知 be prone to doing It is worth pointing out that … prevent … from … for the purpose of … as such / as a result 因此 take … as an example.]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow2张量操作]]></title>
    <url>%2F2019%2F11%2F09%2Ftensorflow-tensor%2F</url>
    <content type="text"><![CDATA[本文总结了TensorFlow2中常见的张量操作。 逐元素相加 1tf.add(x,y,name=None) 示例： 12print(tf.add(1,2))print(tf.add([1,2],[3,4])) 12tf.Tensor(3, shape=(), dtype=int32)tf.Tensor([4 6], shape=(2,), dtype=int32) 逐元素相减 平方 tf.square(x,name=None) 示例： 12print(tf.square(5))print(tf.square([1,2])) 12tf.Tensor(25, shape=(), dtype=int32)tf.Tensor([1 4], shape=(2,), dtype=int32) tf.pow() tf.constant 创建常数常量 123456tf.constant( value, dtype=None, shape=None, name='Const') tf.zeros、tf.ones、tf.fill tf.matmul tf.reduce_sum() tf.tile 与NumPy ndarray的相互转换TensorFlow numpy() tf.Variable tf.cast]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试基础知识]]></title>
    <url>%2F2019%2F11%2F09%2Fsoftware-testing%2F</url>
    <content type="text"><![CDATA[今天参加了软件评测师考试，趁着热乎劲，总结下软件测试的相关知识。 软件测试原则1.所有的软件测试都应追溯到用户需求。 2.应当把“尽早地和不断地进行软件测试”作为软件测试者的座右铭。 3.完全测试是不可能的，测试需要终止。 4.测试无法显示软件潜在的缺陷。 5.充分注意测试中的群集现象。 6.程序员应避免检查自己的程序。 7.尽量避免测试的随意性。 软件测试对象根据软件的定义，软件包括程序、数据和文档。 所以，软件测试并不仅仅是程序测试，还应包括相应文档和数据的测试。 软件测试分类 按照开发阶段划分：单元测试、集成测试、系统测试、确认测试以及验收测试。 常见的单元测试工具：Java JUnit、Python unittest 按照测试技术划分：白盒测试（white-box testing）、黑盒测试（black-box testing）以及灰盒测试（gray-box testing）。 根据是否需要执行被测试代码划分：静态测试（static testing）和动态测试（dynamic testing）。 静态测试指不运行被测程序本身，仅通过分析或检查源程序的文法、结构、过程、接口等来检查程序的正确性。 动态测试是指通过运行软件来检验软件的动态行为和运行结果的正确性，主要是对软件的逻辑、功能等方面进行评估。 测试停止准则1.测试用例全部执行结束 2.测试覆盖率达到要求 3.测试超出了预定时间 4.查出了预定数目的故障 5.执行了预定的测试方案 白盒测试用于确认程序结构逻辑的正确性。 逻辑覆盖法语句覆盖语句覆盖（Statement Coverage，SC）：选择足够多的测试数据，使被测程序中每条语句至少执行一次。 判定覆盖判定覆盖（Decision Coverage，DC）：设计足够的测试用例，使得被测程序中的每个判定表达式至少获得一次“真值”或“假值”，从而使程序的每一个分支至少都通过一次。 条件覆盖条件覆盖（Condition Coverage，CC）：构造一组测试用例，使得每一判定语句中每个逻辑条件的可能值至少满足一次。 条件/判定覆盖条件/判定覆盖（Condition/ Decision Coverage，CDC）：设计足够的测试用例，使得判定中每个条件的所有可能（真/假）至少出现一次，并且每个判定本身的判定结果（真/假）也至少出现一次。 条件组合覆盖多条件覆盖，也称条件组合覆盖（Multiple Condition Coverage，MCC）：选择足够的测试用例，使得每个判定中条件的各种可能组合都至少出现一次。 修正条件/判定覆盖修正条件/判定覆盖（Modified Condition/ Decision Coverage，MC/DC）：设计适当数量的测试用例，保证在一个程序中每一种输入输出至少得出现一次，在程序中的每一个条件必须产生所有可能的输出结果至少一次，并且每个判断中的每个条件必须能够独立影响一个判断的输出，即在其他条件不变的前提下仅改变这个条件的值，而使判断结果改变。 基本路径测试在程序控制流图的基础上，通过分析控制构造的环路复杂度，导出基本可执行路径集合，从而设计测试用例的方法。 程序的环路复杂度是程序中每个可执行语句至少执行一次所需要的测试用例数目的上限。 123程序的环路复杂度V(G)=边数-节点数+2 =控制流图中判定节点数+1 =控制流图的区域数 黑盒测试（功能测试）用于确认软件功能的正确性和可操作性。 等价类划分法 确定等价类的原则： 1.如果规定了输入数据的取值范围或值的个数，可以确定一个有效等价类和两个无效等价类。 例如，如果规定输入值a的取值范围为1~99，那么可以得到一个有效等价类{a|1&lt;=a&lt;=99}和两个无效等价类{a|a&lt;1}、{a|a&gt;99} 2.如果输入条件规定了输入值的集合或者规定了“必须如何”的条件，则可以确定一个有效等价类和一个无效等价类（该集合有效值之外）。 例如，如果规定输入值b为奇数，那么可以得到一个有效等价类{b|b是奇数}和一个无效等价类{b|b不是奇数}。 3.如果规定了一组输入数据（假设包括n个输入值），并且程序要对每一个输入值分别进行处理，可以确定n个有效等价类和一个无效等价类。 例如，如果规定输入值x的取值为1，2，3三个数之一，那么可以得到3个有效等价类{x|x=1}、{x|x=2}、{x|x=3}和一个无效等价类{x|x≠1,2,3}。 4.如果规定了输入数据必须遵守的规则或限制条件，可以确定一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）。 例如，如果规定输入值A是最多保留两位小数的正浮点数，那么可以得到一个有效等价类{A|A是最多保留两位小数的正浮点数}和三个无效等价类{A|A不是浮点数}、{A|A不是正浮点数}以及{A|A是多于两位小数的正浮点数}。 编写测试用例 如果输入全部都来自有效等价类，则从每个有效等价类选取一个代表元素作为输入； 如果要考虑无效等价类，则每次只选取一个无效等价类，其余输入都从有效等价类中选取。 边界值分析边界值分析法是对输入或输出的边界值进行测试的一种黑盒测试方法。 通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。 长期的测试工作经验告诉我们，大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内容。 用边界值测试方法设计测试用例，首先应确定边界情况。 通常输入和输出等价类的边界，就是应着重测试的边界情况。 应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据。 负载压力测试负载压力测试是指在一定约束条件下测试系统所能承受的并发用户量、运行时间、数据量，以确定系统所能承受的最大负载压力。负载压力测试包括负载测试、压力测试、并发性能测试、疲劳强度测试、大数据量测试等内容。 常用工具：Apache JMeter、LoadRunner 负载测试负载测试是通过逐步增加系统负载，测试系统性能的变化，并最终确定在满足性能指标的情况下，系统所能承受的最大负载量的测试。 压力测试压力测试是通过逐步增加系统负载，测试系统性能的变化，并最终确定在什么负载条件下，系统性能处于失效状态，以此来获得系统能提供的最大服务级别的测试。 通俗地讲，压力测试是为了发现在什么条件下系统的性能会变得不可接受。 可见，压力测试是一种特定类型的负载测试。 并发性能测试逐渐增加并发用户数负载，直到系统的瓶颈或者不能接收的性能点，通过综合分析交易执行指标、资源监控指标等来确定系统并发性能的过程。 疲劳强度测试通常是采用系统稳定运行情况下能够支持的最大并发用户数，或者日常运行用户数，持续执行一段时间业务，保证达到系统疲劳强度需求的业务量，通过综合分析交易执行指标和资源监控指标，来确定系统处理最大工作量强度性能的过程。 大数据量测试大数据量测试包括独立的数据量测试和综合数据量测试。 独立数据量测试是指针对系统存储、传输、统计、查询等业务进行的大数据量测试； 综合数据量测试是指和压力测试、负载测试、疲劳强度测试相结合的综合测试。 Web应用测试页面设计测试页面测试可以从以下几个方面进行： 1.页面的一致性如何； 2.在每个页面上是否设计友好的用户界面和直观的导航系统； 3.是否考虑多种浏览器的需要； 4.是否建立了页面文件的命名体系； 5.是否充分考虑了合适的页面布局技术，如层叠样式表、表格和帧结构等。 链接测试首先，测试所有链接是否按指示的那样确实连接到了该链接的页面； 其次，测试所链接的页面是否存在； 最后，保证Web应用系统上没有孤立的页面。所谓孤立页面是指没有链接指向该页面，只有知道正确的URL地址才能访问。 图形测试主要检查点如下： 1.颜色饱和度和对比度是否合适； 2.需要突出的链接的颜色是否容易识别； 3.是否正确加载所有的图形。 表单测试1.检查每个字段的所有验证； 2.检查字段的缺省值； 3.检查表单中的错误输入，是否有错误提示； 4.提交操作的完整性。 兼容性测试平台兼容性和浏览器兼容性 测试浏览器的兼容性可以与操作系统的兼容性结合起来，最有效的方法是创建一个兼容性测试矩阵。 平台\浏览器 IE(7,8,9,10) Chrome Firefox Safari … Windows (XP,7,8,10) Mac Linux … &nbsp; 安全性测试功能验证采用软件测试中的黑盒测试方法，对涉及安全的软件功能进行测试，验证所提供的功能是否有效。 漏洞扫描借助于特定的漏洞扫描工具，在安全漏洞造成严重危害前，发现漏洞并加以防范。 模拟攻击试验模拟攻击试验是一组特殊的黑盒测试案例，通过模拟典型的安全攻击来验证软件或信息系统的安全防护能力。 侦听测试通过典型的网络数据包获取技术，在系统数据通信或数据交互的过程中，对数据进行截取分析，从而发现系统在防止敏感数据被窃取方面的安全防护能力。]]></content>
      <categories>
        <category>software testing</category>
      </categories>
      <tags>
        <tag>software testing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索引擎常用技巧]]></title>
    <url>%2F2019%2F11%2F08%2Fsearch-engine-technique%2F</url>
    <content type="text"><![CDATA[人人都会“用”搜索引擎，但却不是谁都能“用好”搜索引擎。 精确搜索使用双引号将检索词括起来，可以获取完全匹配。 模糊检索使用通配符*号，可以进行模糊检索。 注：搜索引擎默认使用此类检索。 例如，想要检索以智能结尾的词，可以使用*智能。 布尔检索逻辑与and：人工智能 and 推荐系统 逻辑或or：人工智能 or 推荐系统 包含/不包含：+、-语法： 12关键字1 +关键词2关键字 -排除关键字 注意：+、-号前面要有空格，后面则不能有空格。 例如： 想要检索人工智能，但不想包含推荐系统，则可以使用人工智能 -推荐系统 站内搜索：site仅在指定的网站中搜索 语法：site:站点域名 例如：site:hegongshan.com 文档搜索：filetype指定文件类型 语法：filetype:文档类型 例如：人工智能 filetype:pdf inurl将搜索结果限定在url链接中 语法：inurl:链接 intitle将搜索结果限定在网页标题中 语法：intitle:关键字]]></content>
      <categories>
        <category>search engine</category>
      </categories>
      <tags>
        <tag>search engine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 HOSLIM&#58 Higher-Order Sparse LInear Method for Top-N Recommender Systems]]></title>
    <url>%2F2019%2F11%2F03%2Frecommender-system-hoslim%2F</url>
    <content type="text"><![CDATA[HOSLIM在Sparse LInear Method（SLIM）的基础上，考虑了物品之间的高层关系（higher-order）。 HOSLIM预测模型用户u对物品i的预测分数$\tilde r_{ui}​$$$\tilde r_{ui} = \mathbf{r}_u^T \mathbf{s}_i + \mathbf{r^\prime}_u^T \mathbf{s}_i^\prime \tag{1}$$因此，HOSLIM的预测模型可以表示为：$$\tilde R = RS + R^\prime S^\prime$$其中，$R \in \mathbb{R}^{n \times m}​$是用户-物品隐式反馈矩阵，$R^\prime \in \mathbb{R}^{n \times p}​$是用户-物品集合隐式反馈矩阵； $S \in \mathbb{R}^{m \times m}$是物品-物品相似度矩阵，$S^\prime\in \mathbb{R}^{p \times m} ​$是物品集合-物品相似度矩阵。 目标函数$$\mathcal{L} =\min_{\mathbf{s}_i,\mathbf{s}^\prime_i} =\frac{1}{2} \left \Vert \mathbf{r}_i - R \mathbf{s}_i - R^\prime \mathbf{s}^\prime_i \right \Vert_2^2 + \frac{\beta}{2} \left \Vert \mathbf{s}_i \right \Vert_2^2 + \frac{\beta}{2} \left \Vert \mathbf{s}^\prime_i \right \Vert_2^2 + \lambda \left \Vert \mathbf{s}_i \right \Vert_1 + \lambda \left \Vert \mathbf{s}^\prime_i \right \Vert_1 \tag{2} \\\begin{align}\mathrm{subject\ to}\&amp;\mathbf{s}_i \geq 0 \\&amp;\mathbf{s}^\prime_i \geq 0 \\&amp;s_{ii} = 0 \\&amp;s^\prime_{ji} = 0,\ i \in \mathcal{I}_j\end{align}$$ 其中，约束条件$s_{ii} = 0​$确保：当计算$\tilde r_{ui}​$时，$r_{ui}​$不会被使用。 $\mathbf{s}^\prime_{ji} = 0$确保：当计算$\tilde r_{ui}$时，物品集合j ($i \in \mathcal{I}_j​$)不会被使用。 参考文献Evangelia Christakopoulou and George Karypis. 2014. Hoslim: Higher-order sparse linear method for top-n recommender systems. In Pacific-Asia Conference on Knowledge Discovery and Data Mining. Springer, 38–49.]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 FISM&#58 Factored Item Similarity Models for Top-N Recommender Systems]]></title>
    <url>%2F2019%2F10%2F26%2Frecommender-system-fism%2F</url>
    <content type="text"><![CDATA[针对Top-N推荐问题，作者提出了一种叫作FISM（Factored Item Similarity Models）的推荐算法，用两个低维隐因子矩阵的乘积来表示物品相似度矩阵。 符号说明1.所有的向量使用粗体小写字母表示，例如$\mathbf{p,q}​$。 2.所有的矩阵使用粗体大写字母表示，例如$\mathbf{R}$。此外，$\mathbf{p_j}$表示矩阵$\mathbf{P}$的第j行。 3.评估时的预测值，在字母上方加波浪号，如$\tilde r_{ui}$；训练时的估计值，在字母上方加估计符号，如$\hat r_{ui}$。 4.$\mathcal{C}$和$\mathcal{D}$分别表示用户和物品集合，$\vert \mathcal{C} \vert=n$，$\vert \mathcal{D} \vert=m$。 5.$\mathbf{R}​$表示用户-物品隐式反馈矩阵；$\mathcal{R}_u^+​$表示用户u评分过的物品集合；$\mathcal{R}_u^-​$表示用户u未评分过的物品集合。 6.$\vert \mathcal{R}_u^+ \vert = n_u^+ $ SLIMSparse LInear Method (SLIM)的预测模型：$$\mathbf{\tilde r}_u = \mathbf{r_u S} \tag{1}$$其中，$\mathbf{r_u}$表示用户u对所有物品的评分组成的向量；$\mathbf{S} \in \mathbb{R}^{m \times m}$表示物品相似度矩阵。 目标函数：$$L= \min_{\mathbf{S}} \frac{1}{2} \sum_{(u,i) \in \mathbf{R}} \left \Vert r_{ui} - \hat r_{ui} \right \Vert_F^2 + \frac{\beta}{2} \left \Vert \mathbf{S} \right \Vert_F^2 + \lambda \left \Vert \mathbf{S} \right \Vert_1 \\subject\ to\ \mathbf{S} \geq 0, diag(\mathbf{S}) = 0 \tag{2}$$其中，$\left \Vert \mathbf{S} \right \Vert_F$是矩阵$\mathbf{S}$的Frobenius范数（参见补充知识）；$\beta$和$\lambda$是正则化参数。 SLIM的不足之处在于：无法捕捉物品之间的传递关系。 如果物品i和j未被任何用户同时评分过，则$s_{ij} = 0$。 但是，物品i和j可能均和第三个物品k相似，从而使得物品i和j彼此相似。 NSVDNSVD用两个低秩矩阵$\mathbf{P} \in \mathbb{R}^{m \times k}$和$\mathbf{Q} \in \mathbb{R}^{m \times k}$（$k \ll m $）的乘积来表示物品相似度。 给定物品i和j，二者的相似度$sim(i,j) = \mathbf{p}_i \cdot \mathbf{q}_j^T$。 预测模型：$$\hat r_{ui} = \tilde r_{ui} = b_u + b_i + \sum_{j \in \mathcal{R}_u^+} \mathbf{p}_j \mathbf{q}_i^T \tag{3}$$目标函数：$$\min_{\mathbf{P,Q}} \frac{1}{2} \sum_{u \in \mathcal{C}} \sum_{i \in \mathcal{R}_u^+} \left \Vert r_{ui} - \hat r_{ui} \right \Vert_F^2 + \frac{\beta}{2} (\left \Vert \mathbf{P} \right \Vert_F^2 + \left \Vert \mathbf{Q} \right \Vert_F^2) \tag{4}$$NSVD的不足之处在于：在估计评分时，没有排除物品自己对自己的影响。 例如，在训练时，要估计用户u对物品i的评分$\hat r_{ui}​$，且$i \in \mathcal{R}_u^+​$ 根据公式(3)可以得到：$$\hat r_{ui} = b_u + b_i + \mathbf{p}_i \mathbf{q}_i^T + \sum_{j \in \mathcal{R}_u^+ \setminus \{i\}} \mathbf{p}_j \mathbf{q}_i^T \tag{5}$$ FISM预测模型：$$\tilde r_{ui} = b_u + b_i + \left \vert R_u^+ \right \vert^{- \alpha} \sum_{j \in \mathcal{R_u^+}} \mathbf{p}_j \mathbf{q}_i^T \tag{6}$$ 作者提出了两种版本的FISM模型，它们使用不同的损失函数。 FISMrmse平方误差损失函数：$$\mathcal{L(\cdot)} = \sum_{i \in \mathcal{D}} \sum_{u \in \mathcal{C}} (r_{ui} - \hat r_{ui})^2 \tag{7}$$估计值$\hat r_{ui}$的计算方法如下：$$\hat r_{ui} = b_u + b_i + (\left \vert R_u^+ \right \vert - 1)^{- \alpha} \sum_{j \in \mathcal{R_u^+ \setminus \ \{i\}}} \mathbf{p}_j \mathbf{q}_i^T \tag{8}$$由于FISM只关注隐式反馈，$\forall j \in \mathcal{R}_u^+$，$r_{uj} = 1$，因此，在公式(7)中省略了$r_{uj}$。 目标函数：$$L = \min_{\mathbf{P,Q}} \frac{1}{2} \sum_{(u,i) \in R} \left \Vert r_{ui} - \hat r_{ui} \right \Vert_F^2 + \frac{\beta}{2} (\left \Vert \mathbf{P} \right \Vert_F^2 + \left \Vert \mathbf{Q} \right \Vert_F^2) + \frac{\lambda}{2} \left \Vert \mathbf{b_u} \right \Vert_2^2 + \frac{\gamma}{2} \left \Vert \mathbf{b_i} \right \Vert_2^2 \tag{9}$$其中，$\mathbf{b_u}$和$\mathbf{b_i}$分别是用户和物品的偏置向量。 使用用户-物品交互矩阵$\mathbf{R}$中的所有元素来计算损失函数是非常耗时的，因此，作者提出对$\mathbf{R}$中的零元素（负样本）进行采样。每次迭代时，随机选择$\rho \cdot nnz(R)$个零元素。 其中，$\rho$是采样因子（sample factor），$nnz(R)$是$\mathbf{R}$中非零项（non-zero entries）的个数。 实验表明，当采样比$\rho \in [3,15]​$时，足够产生最佳的模型。 训练算法： FISMauc基于Bayesian Personalized Ranking（BPR）的排序损失函数：$$\mathcal{L(\cdot)} = \sum_{u \in \mathcal{C}} \sum_{i \in \mathcal{R}_u^+,\ j \in \mathcal{R}_u^-} ( (r_{ui} - r_{uj}) - (\hat r_{ui} - \hat r_{uj}) )^2 \tag{10}$$其中，$R_u^+$表示用户评分过的物品，$R_u^-$表示用户未评分过的物品。 目标函数：$$\min_{\mathbf{P,Q}} \frac{1}{2} \sum_{u \in \mathcal{C}} \sum_{i \in \mathcal{R}_u^+,\ j \in \mathcal{R}_u^-} \left \Vert (r_{ui} - r_{uj}) - (\hat r_{ui} - \hat r_{uj}) \right \Vert_F^2 + \frac{\beta}{2} (\left \Vert \mathbf{P} \right \Vert_F^2 + \left \Vert \mathbf{Q} \right \Vert_F^2) + \frac{\gamma}{2} \left \Vert \mathbf{b_i} \right \Vert_2^2 \tag{11}$$注意：由于$\hat r_{ui} - \hat r_{uj}$时，$b_u$被消掉了，因此，目标函数的正则项中没有$\mathbf{b}_u$。 此外，FISMauc的采样方式与FISMrmse相似。 训练算法： 补充知识1.矩阵$\mathbf{A} \in \mathbb{R}^{m \times n}$的Frobenius范数$\left \Vert \mathbf{A} \right \Vert_F$定义为：$$\left \Vert \mathbf{A} \right \Vert_F = \sqrt{tr(\mathbf{A}^T \mathbf{A})} = \sqrt {\sum_{i=1}^m \sum_{j=1}^n A_{ij}^2} \tag{12}$$2.对于矩阵$\mathbf{A}​$$$\frac{\partial \left \Vert \mathbf{A} \right \Vert_F^2}{\partial \mathbf{A}} = 2 \mathbf{A} \tag{13}$$对于向量$\mathbf{x}​$$$\frac{\partial \left \Vert \mathbf{x} \right \Vert_2^2}{\partial \mathbf{x}} = 2 \mathbf{x} \tag{14}$$ 参考文献1.S. Kabbur, X. Ning, and G. Karypis, “FISM: Factored item similar- ity models for top-n recommender systems,” in Proc. 19th ACM SIGKDD Conf. Knowl. Discovery Data Mining, 2013, pp. 659–667. 2.https://github.com/guoguibing/librec/blob/3.0.0/core/src/main/java/net/librec/recommender/cf/ranking/FISMrmseRecommender.java 3.https://github.com/guoguibing/librec/blob/3.0.0/core/src/main/java/net/librec/recommender/cf/ranking/FISMaucRecommender.java]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 NAIS&#58 Neural Attentive Item Similarity Model for Recommendation]]></title>
    <url>%2F2019%2F10%2F21%2Frecommender-system-nais%2F</url>
    <content type="text"><![CDATA[针对基于物品的协同过滤，作者采用注意力机制，提出了一种叫作Neural Attentive Item Similarity model (NAIS)的神经网络模型。 Standard Item-Based CF$$\hat y_{ui} = \sum_{j \in \mathcal{R}_u^+} r_{uj} s_{ij} \tag{1}$$ 其中，$\mathcal{R}_u^+​$表示用户u交互过的物品集合；$s_{ij}​$表示物品$i​$和物品$j​$之间的相似度； $r_{uj}$表示用户u对物品j的已知偏好（对于显式反馈，$r_{uj}$是用户u对物品j的评分；对于隐式反馈，$r_{uj}​$是1或者0，表示用户u是否与物品j有过交互行为）。 SLIMSparse LInear Method (SLIM)的目标函数：$$L= \frac{1}{2} \sum_{u=1}^U \sum_{i=1}^I (r_{ui} - \hat y_{ui})^2 + \frac{\beta}{2} \left \Vert \mathbf{S} \right \Vert_F^2 + \lambda \left \Vert \mathbf{S} \right \Vert_1 \\subject\ to\ \mathbf{S} \geq 0, diag(\mathbf{S}) = 0 \tag{2}$$其中，$U$和$I$分别表示用户和物品的数量；$\mathbf{S} \in \mathbb{R}^{I \times I}$表示物品相似度矩阵；$\beta$和$\lambda$是正则化参数。 然而，SLIM有两个明显的缺点： 时间复杂为$O(I^2)$ 无法捕捉物品之间的传递关系 FISM在Factored Item Similarity Model (FISM)中，相似度分数$s_{ij}$被表示为物品i和物品j的embedding向量的内积。$$\hat y_{ui} = \mathbf{p}_i^T \left( \frac{1}{\left \vert \mathcal{R}_u^+ - 1 \right \vert^\alpha} \sum_{j \in \mathcal{R_u^+ \setminus \{i\}}} \mathbf{q}_j \right) \\\qquad\qquad \underbrace{\mathrm{user\ u’s\ representation}} \tag{3}$$ 其中，$\alpha$是控制归一化效果的超参数；$\mathbf{p}_i$和$\mathbf{q}_j$分别表示物品$i$和物品$j$的embedding向量。 由于FISM只关注隐式反馈，$\forall j \in \mathcal{R}_u^+$，$r_{uj} = 1$，因此，在公式(3)中省略了$r_{uj}$。 时间复杂度：$O(k \left \vert \mathcal{R}_u^+ \right \vert)$。其中，k表示embedding size。 作者认为：在获得用户表示时，FISM对用户交互过的所有历史物品等同处理，这可能限制了模型的性能。 用户的兴趣会随着时间而发生变化，最新交互过的物品应该对用户未来的偏好具有更好的表达能力。 NAIS设计一给每个物品赋予一个权重，使得历史物品对用户表示产生不同的影响。$$\hat y_{ui} = \mathbf{p}_i^T \left( \frac{1}{\left \vert \mathcal{R}_u^+ \right \vert^\alpha} \sum_{j \in \mathcal{R_u^+ \setminus \{i\}}} a_j \mathbf{q}_j \right) \tag{4}$$ 其中，$a_j​$表示物品j的注意力权重（attention weight）。 然而，不管预测哪个物品i，对于同一用户的所有历史物品j来说，$a_j​$都是不变的，这显然是不合理的。 从用户表示的角度来看，该方法假定每个用户各有一个对应的静态向量，可以表示他的兴趣，这可能限制了模型的表示能力。 设计二为了解决设计一的问题，作者提出为每个物品对$(i,j)$赋予不同的权重$$\hat y_{ui} = \mathbf{p}_i^T \left( \frac{1}{\left \vert \mathcal{R}_u^+ \right \vert^\alpha} \sum_{j \in \mathcal{R_u^+ \setminus \{i\}}} a_{ij} \mathbf{q}_j \right) \tag{5}$$其中，$a_{ij}​$表示物品j在预测用户u对目标物品i的偏好时的注意力权重。 如果物品对$(i,j)​$没有在训练数据中同时出现过（没有一个用户同时和物品i、j交互过），那么无法估计该物品对的注意力权重$a_{ij}​$。 设计三为了解决设计二的泛化问题，作者将$a_{ij}$与embedding向量$\mathbf{p}_i$和$\mathbf{q}_j​$联系在一起。$$a_{ij} = f(\mathbf{p}_i,\mathbf{q}_j) \tag{6}$$作者使用MLP来表示attention函数$$\begin{cases}f_{concat}(\mathbf{p}_i,\mathbf{q}_j) = \mathbf{h}^T ReLU \left( \mathbf{W}\begin{bmatrix}\mathbf{p}_i \\\mathbf{q}_j\end{bmatrix} + \mathbf{b}\right) \\f_{prod}(\mathbf{p}_i,\mathbf{q}_j) = \mathbf{h}^T ReLU \left( \mathbf{W} (\mathbf{p}_i \odot \mathbf{q}_j) + \mathbf{b}\right)\end{cases} \tag{7}$$作者将隐含层的大小称之为注意力因子（attention factor），并使用softmax函数将注意力权重转化为概率分布。$$\hat y_{ui} = \mathbf{p}_i^T \left( \sum_{j \in \mathcal{R_u^+ \setminus \{i\}}} a_{ij}\mathbf{q}_j \right) \\a_{ij} = \frac{\exp(f(\mathbf{p}_i, \mathbf{q}_j))} {\sum_{j \in \mathcal{R_u^+ \setminus \{i\}}} \exp(f(\mathbf{p}_i, \mathbf{q}_j))} \tag{8}$$然而，softmax函数可能过度地惩罚了活跃用户的权重，从而导致上述设计的性能显著低于FISM。 为了解决这个问题，作者提出对softmax函数的分母进行平滑：$$\hat y_{ui} = \mathbf{p}_i^T \left( \sum_{j \in \mathcal{R_u^+ \setminus \{i\}}} a_{ij}\mathbf{q}_j \right) \\a_{ij} = \frac{\exp(f(\mathbf{p}_i, \mathbf{q}_j))} {[\sum_{j \in \mathcal{R_u^+ \setminus \{i\}}} \exp(f(\mathbf{p}_i, \mathbf{q}_j))]^\beta} \tag{9}$$其中，$\beta$是平滑指数。 时间复杂度：$O(a k \left \vert \mathcal{R}_u^+ \right \vert)$。其中，$a$表示注意力因子，k表示embedding size。 损失函数作者采用了常见的二元交叉熵损失$$\begin{align}L &amp;= -\frac{1}{N} \left( \sum_{(u,i) \in \mathcal{R^+}} \log \sigma(\hat y_{ui}) + \sum _{(u,i) \in \mathcal{R^-}} \log(1 - \sigma(\hat y_{ui})) \right) + \lambda \left \Vert \Theta \right \Vert^2 \\&amp;= -\frac{1}{N} \left( \sum_{(u,i) \in \mathcal{R^+} \cup \mathcal{R^-}} y_{ui} \log \sigma(\hat y_{ui}) + (1 - y_{ui}) \log(1 - \sigma(\hat y_{ui})) \right) + \lambda \left \Vert \Theta \right \Vert^2\end{align} \tag{10}$$其中，$$y_{ui}=\begin{cases}0, &amp; \mathrm{for\ unknown\ ratings} \\1, &amp; \mathrm{otherwise}\end{cases}$$ 实验设置采用留一法作为评估方法，HR和NDCG作为评估指标。 在训练时，为每个正样本随机选择4个负样本；在测试时，为每个测试物品随机选择99个负样本。 注意力因子a和embedding size k相等，$\beta=0.5, k = a = 16,\lambda = 0$。 推荐数量N设置为10。 采用Adagrad作为优化器，学习率设置为0.01。 使用FISM学到的物品embeddings初始化NAIS。 由于不同的用户交互过的物品数目也不同，为了解决这个问题，作者提出将某一用户的全部训练实例作为一个mini-batch，从而不需要设置batch_size。 参考文献[1] He, Xiangnan , et al. “NAIS: Neural Attentive Item Similarity Model for Recommendation.” IEEE Transactions on Knowledge and Data Engineering (2018):1-1. [PDF] [Code] [2] B. Sarwar, G. Karypis, J. Konstan, and J. Riedl, “Item-based collaborative filtering recommendation algorithms,” in Proc. 10th Int. Conf. World Wide Web, 2001, pp. 285–295. [3] X. Ning and G. Karypis, “SLIM: Sparse linear methods for top-n recommender systems,” in Proc. IEEE 11th Int. Conf. Data Mining, 2011, pp. 497–506. [4] S. Kabbur, X. Ning, and G. Karypis, “FISM: Factored item similar- ity models for top-n recommender systems,” in Proc. 19th ACM SIGKDD Conf. Knowl. Discovery Data Mining, 2013, pp. 659–667. 我的复现 Keras：Neural Attentive Item Similarity]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Joint Neural Collaborative Filtering for Recommender Systems]]></title>
    <url>%2F2019%2F10%2F14%2Frecommender-system-jncf%2F</url>
    <content type="text"><![CDATA[作者使用一个联合神经网络将用户和物品的深度特征学习、用户与物品之间的深度交互建模整合在一起。此外，作者综合考虑了显式反馈和隐式反馈、pointwise和pairwise损失，提出了一种新的损失函数。 Joint Neural Collaborative Filtering (J-NCF) J-NCF包含两个主要的网络：DF网络用于对用户和物品的特征进行建模，而DI网络则用于对用户和物品之间的交互进行建模。 DF网络包含两个并行的神经网络，一个是抽取用户特征的$Net_{user}​$，另一个是抽取物品特征的$Net_{item}​$。 $Net_{user}$和$Net_{item}$分别以用户的评分向量$\mathbf{v_u} = &lt;y_{u1},\cdots,y_{uN}&gt;$和物品的评分向量$\mathbf{v_i} = &lt;y_{1i},\cdots,y_{Mi}&gt;$作为输​入。$$y_{ui} =\begin{cases}0, &amp; \mathrm{for\ unknown\ ratings}, \\R_{ui}, &amp; \mathrm{when\ explicit\ feedback\ is\ available}\end{cases} \tag{3}$$其中，$R_{ui}$是用户u对物品i的评分。 可以看到，对于用户物品交互矩阵，作者遵循了DMF中的做法，综合考虑了显式反馈和隐式反馈。 在DF网络中，作者使用MLP将用户和物品的高维评分向量映射为更低维度的向量。 由于$Net_{user}$和$Net_{item}$只有输入不同，因此，下面仅描述$Net_{user}$的流程。$$\mathbf{z_u^1} = f_u^1(\mathbf{W_u^1 v_u + b_u^1}) \\\mathbf{z_u^2} = f_u^2(\mathbf{W_u^2 z_u^1 + b_u^2}) \\\vdots \\\mathbf{z_u} = f_u^X(\mathbf{W_u^X z_u^{X-1} + b_u^X}) \tag{4}$$其中，$\mathbf{W_{u}^x}$、$\mathbf{b_{u}^x}$、$f_{u}^x$分别表示DF网络中第x层的权重矩阵、偏置向量和激活函数；X表示DF网络的层数。 在DF网络中，作者采用ReLU作为激活函数。 为了研究非线性函数和线性函数在对用户和物品之间的交互进行建模的差异，作者提出使用以下两种方式来得到用户和物品的融合特征向量$a_{ui}​$，并将其作为DI网络的输入：$$a_{ui} =\begin{cases}\begin{bmatrix}z_u \\z_i\end{bmatrix}, &amp; \mathrm{concatenation,\ or} \\ z_u \odot z_i, &amp; \mathrm{multiplication}\end{cases} \tag{5}$$DI网络的处理流程如下：$$z_{ui}^1 = f_{ui}^1(\mathbf{W_{ui}^1} a_{ui} + \mathbf{b_{ui}^1}) \\z_{ui}^2 = f_{ui}^2(\mathbf{W_{ui}^2} z_{ui}^1 + \mathbf{b_{ui}^2}) \\\vdots \\z_{ui}^Y = f_{ui}^Y(\mathbf{W_{ui}^Y} z_{ui}^{Y-1} + \mathbf{b_{ui}^Y}) \tag{6}$$其中，$\mathbf{W_{ui}^y}$、$\mathbf{b_{ui}^y}$、$f_{ui}^y$分别表示DI网络中第y层的权重矩阵、偏差向量和激活函数；Y表示DI网络的层数。 在DI网络中，作者亦采用ReLU作为激活函数。 DI网络的输出是用户u和物品i之间交互的预测分数$\hat y_{ui}$:$$\hat y_{ui} = \sigma(\mathbf{h^T}z_{ui}) \tag{7}$$其中，$\sigma$是sigmoid函数，它将输出限制在区间(0,1)中；$\mathbf{h}$为DI网络输出层的权重向量。 损失函数NCF和DMF均采用了基于pointwise的对数损失函数$$\ell_{log} = - \sum_{u \in U} \sum_{i \in I} y_{ui} \log \hat y_{ui} + (1-y_{ui}) \log(1-\hat y_{ui}) \tag{10}$$常见的基于pairwise的损失函数有：TOP1、BPR-max以及TOP1-max。$$\ell_{TOP1} = \frac{1}{\left \vert N_S \right \vert} \sum_{j \in N_S} \sigma(\hat y_{uj} - \hat y_{ui}) + \sigma(\hat y_{uj}^2) \tag{11}$$其中，$\hat y_{uj}$和$\hat y_{ui}$分别为负样本j和正样本i的预测分数；$N_S$为负样本集合。 为了克服随着负样本数量的增加而产生的梯度消失问题，Hidasi和Karatzoglou提出了BPR-max和TOP1-max$$\ell_{TOP1-max} = \sum_{j \in N_S} s_j \left( \sigma(\hat y_{uj} - \hat y_{ui}) + \sigma(\hat y_{uj}^2) \right) \tag{12}$$BPR-max$$\ell_{BPR-max} = -\log \sum_{j \in N_S} s_j \sigma(\hat y_{ui} - \hat y_{uj}) \tag{13}$$其中，$s_j$为相应的softmax分数。 至于listwise损失函数，许多基于深度学习的方法将交叉熵与softmax整合在一起，作者称之为softmax+cross-entropy (XE) $$\ell_{XE} = -\log s_i = -\log \frac{e^{\hat y_{ui}}}{\sum_{j \in N_S} e^{\hat y_{uj}}} \tag{14}$$作者认为，pointwise损失只使用了评分信息，忽略了物品对之间相对顺序所包含的信息；而pairwise则刚好相反，它忽略了用户对某一物品的个人偏好信息。 因此，作者综合考虑了pointwise和pairwise，提出了一种新的损失函数：$$L = \alpha L_{pair-wise} + (1 - \alpha) L_{point-wise} \tag{15}$$其中，$\alpha$是一个权衡参数，用于控制两者的权重。 在pointwise部分，作者采用了DMF中提出的归一化对数损失函数，从而$$L = \alpha L_{pair-wise} + (1 - \alpha) (- Y_{ui} \log \hat y_{ui} - (1-Y_{ui}) \log(1-\hat y_{ui})) \tag{16}$$其中，$Y_{ui} = \frac{y_{ui}}{\max(R_u)}$，$R_u​$为用户u给出的最大评分。 作者将公式(16)称之为hybrid loss function。 训练算法 实验设置作者采用留一法作为评估方法，使用Hit Ratio（HR）和NDCG作为评估指标。 在训练的时候，为每个正样本随机选择5个负样本；在测试的时候，为每个测试物品随机选择100个负样本。 使用高斯分布（均值为0、方差为0.01的正态分布）随机初始化模型参数，优化器为mini-batch Adam。 batch_size设置为256，学习率设置为0.0001。 迭代100次，推荐数量N设置为10。 DF网络使用三层结构，每层的神经元数量为[256,128,64]；DI网络使用两层结构，每层的神经元数量为[128,8]。 参考文献[1] Wanyu Chen, Fei Cai, Honghui Chen, and Maarten De Rijke. 2019. Joint Neural Collaborative Filtering for Recommender Systems. ACM Trans. Inf. Syst. 37, 4, Article 39 (August 2019), 30 pages. DOI: https://doi.org/10.1145/3343117 [2] Xiangnan He, Lizi Liao, Hanwang Zhang, Liqiang Nie, Xia Hu and Tat-Seng Chua (2017). Neural Collaborative Filtering. In Proceedings of WWW ‘17, Perth, Australia, April 03-07, 2017. [3] Hong-Jian Xue, Xin-Yu Dai, Jianbing Zhang, Shujian Huang, and Jiajun Chen. 2017. Deep matrix factorization models for recommender systems. In Proceedings of the 26th International Joint Conference on Artificial Intelligence (IJCAI’17), Carles Sierra (Ed.). AAAI Press 3203-3209.]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homebrew——MacOS中的包管理器]]></title>
    <url>%2F2019%2F10%2F06%2Fmacos-homebrew%2F</url>
    <content type="text"><![CDATA[与Ubuntu和CentOS等Linux发行版相比，macOS没有预装wget和tree等命令。 如果需要安装这些缺失的软件包，可以使用Homebrew包管理器。 什么是HomebrewHomebrew是macOS中的第三方包管理器，可以方便地安装那些macOS中没有包含的UNIX工具，比如wget、tree等。 安装Homebrew安装Homebrew前，请确保已安装Xcode命令行工具。如果没有安装，在终端中输入如下命令： 1xcode-select --install 然后，开始安装Homebrew，在终端中输入如下命令： 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装软件包1brew install 包名 卸载软件包1brew uninstall 包名 升级软件包1brew upgrade [包名...] 若没有指定软件包，则对所有的软件包进行升级。 查看已安装的软件包1brew list 更新Homebrew12# 更新所有的软件包和Homebrewbrew update 搜索软件包1brew search 软件包 查看软件信息1brew info 软件包 显示帮助信息1brew help [command] 若没有指定命令名，则显示Homebrew的帮助信息；否则，显示该命令的帮助信息。 卸载Homebrew在终端中输入如下命令即可： 1ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)" 关于Homebrew的更多信息，请参看这里。]]></content>
      <categories>
        <category>macos</category>
      </categories>
      <tags>
        <tag>macos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Deep Matrix Factorization Models for Recommender Systems]]></title>
    <url>%2F2019%2F10%2F04%2Frecommender-system-dmf%2F</url>
    <content type="text"><![CDATA[作者综合考虑了显式评分和隐式反馈，提出了一个基于深度学习的矩阵分解方法以及一个新的损失函数。 用户-物品交互矩阵在过去的研究中，大部分的学者采用如下的方式构造交互矩阵：$$Y_{ij} =\begin{cases}0, &amp; if\ R_{ij} = unk \\1, &amp; otherwise\end{cases} \tag{1}$$其中，$R_{ij}$表示用户$i$对物品$j$的评分。 作者认为，显式评分表明了用户对物品的偏好程度，因此，在构造交互矩阵时，综合考虑了显式评分和隐式反馈。$$Y_{ij} =\begin{cases}0, &amp; if\ R_{ij} = unk \\R_{ij}, &amp; otherwise\end{cases} \tag{2}$$ 符号定义$Y​$表示经过公式(2)转换后得到的用户-物品交互矩阵。 $Y^+$表示已被观察到的交互行为，$Y^-$表示$Y$中的所有零元素，$Y^-_{sampled}$表示负样本集合（从$Y^-$中采样得到）。 $Y_{i*}$表示$Y$中的第$i$行，$Y_{*j}$表示$Y$中的第$j$列。 Deep Matrix Factorization (DMF) 作者使用ReLU作为输出层和隐含层的激活函数$$f(x) = \max(0,x) \tag{6}$$在DMF的架构中，作者使用两个多层神经网络分别转换用户u和物品v的表示。$$p_i = f_{\theta^U_N}(\cdots f_{\theta^U_3}(W_{U2}\ f_{\theta^U_2}(Y_{i*} W_{U1}))\cdots) \\q_j = f_{\theta^I_N}(\cdots f_{\theta^I_3}(W_{V2}\ f_{\theta^I_2}(Y^T_{*j} W_{V1}))\cdots)\tag{7}$$其中，$W_{U1}$和$W_{V1}$分别是U、I第一层的权重矩阵，$W_{U2}$和$W_{V2}$分别是U、I第二层的权重矩阵… 最后，使用余弦相似度，来得到最终的预测分数。$$\hat Y_{ij} = F^{DMF}(u_i,v_j|\Theta)=cosine(p_i,q_j) = \frac{p_i^T q_j}{\left \Vert p_i \right \Vert \left \Vert q_j \right \Vert} \tag{8}$$ 损失函数在过去的研究中，平方损失被大量采用$$L_{sqr} = \sum_{(i,j)\in Y^+\ \cup\ Y^-} w_{ij}(Y_{ij} - \hat Y_{ij})^2 \tag{10}$$其中，$w_{ij}$表示训练实例$(i,j)$的权重。然而，平方损失并不适用于隐式反馈问题。 在隐式反馈中，目标值$Y_{ij}​$要么是1，要么是0，表示用户$i​$与物品$j​$之间是否存在交互行为。 因此，何向南在Neural Collaborative Filtering中提出采用二元交叉熵作为损失函数：$$L = -\sum_{(i,j)\in Y^+\ \cup\ Y^-} Y_{ij} \log \hat Y_{ij}) + (1 - Y_{ij}) \log (1 - \hat Y_{ij}) \tag{11}$$作者将显式评分整合进交叉熵损失中，提出了归一化交叉熵损失（normalized cross entropy loss, nce）：$$L = -\sum_{(i,j) \in Y^+ \cup Y^-} (\frac{Y_{ij}}{\max (R)} \log \hat Y_{ij} + (1 - \frac{Y_{ij}}{\max (R)}) \log (1 - \hat Y_{ij})) \tag{12}$$其中，$\max(R)$是所有评分中的最大评分（例如，在五星评分系统中，max(R) = 5）。 其目的在于让不同的$Y_{ij}$值对损失产生不同的影响。 DMF的训练算法 由于$Y_{ij}$的预测评分$\hat Y_{ij}$可能为负，因此，作者使用公式(13)来转换原始预测评分。$$\hat Y^\circ_{ij} = \max(\mu,\hat Y_{ij}) \tag{13}$$其中，$\mu$是一个非常小的数字。在实验中，作者将其设置为$1.0e^{-6}​$。 参考文献1.Hong-Jian Xue, Xin-Yu Dai, Jianbing Zhang, Shujian Huang, and Jiajun Chen. 2017. Deep matrix factorization models for recommender systems. In Proceedings of the 26th International Joint Conference on Artificial Intelligence (IJCAI’17), Carles Sierra (Ed.). AAAI Press 3203-3209. [PDF] 2.Xiangnan He, Lizi Liao, Hanwang Zhang, Liqiang Nie, Xia Hu and Tat-Seng Chua (2017). Neural Collaborative Filtering. In Proceedings of WWW ‘17, Perth, Australia, April 03-07, 2017. 我的复现（Keras + TensorFlow）：https://github.com/hegongshan/deep_matrix_factorization]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyter入门]]></title>
    <url>%2F2019%2F10%2F01%2Fpython-jupyter%2F</url>
    <content type="text"><![CDATA[Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本。 Jupyter这个词是由Julia、Python和R中的字母组成。 安装Jupyter1pip3 install jupyter 启动Jupyter Notebook在命令行中输入如下命令： 1jupyter notebook Jupyter Notebook启动后，在浏览器中访问如下链接： 1http://localhost:8888/tree Jupyter Notebook常用快捷键shift+enter：运行代码块, 选择下面的代码块 control+enter：运行选中的代码块 Windows alt+enter 、 Mac option+enter ：运行代码块并且插入下面 命令行模式(按 Esc 生效) 双击D键：删除选中单元格 H键：显示快捷键 编辑模式(按 Enter 生效) Windows control+/ 、Mac command+/：注释整行/撤销注释 插入LaTex在Jupyter Notebook中插入LaTex， 12from IPython.display import LatexLatex('$a^2 + b^2 = c^2$') 魔法函数在ipynb文件中输入%lsmagic，查看当前可以使用的魔法函数 1%lsmagic 输出： 1234567Available line magics:%alias %alias_magic %autoawait %autocall %automagic %autosave %bookmark %cat %cd %clear %colors %conda %config %connect_info %cp %debug %dhist %dirs %doctest_mode %ed %edit %env %gui %hist %history %killbgscripts %ldir %less %lf %lk %ll %load %load_ext %loadpy %logoff %logon %logstart %logstate %logstop %ls %lsmagic %lx %macro %magic %man %matplotlib %mkdir %more %mv %notebook %page %pastebin %pdb %pdef %pdoc %pfile %pinfo %pinfo2 %pip %popd %pprint %precision %prun %psearch %psource %pushd %pwd %pycat %pylab %qtconsole %quickref %recall %rehashx %reload_ext %rep %rerun %reset %reset_selective %rm %rmdir %run %save %sc %set_env %store %sx %system %tb %time %timeit %unalias %unload_ext %who %who_ls %whos %xdel %xmodeAvailable cell magics:%%! %%HTML %%SVG %%bash %%capture %%debug %%file %%html %%javascript %%js %%latex %%markdown %%perl %%prun %%pypy %%python %%python2 %%python3 %%ruby %%script %%sh %%svg %%sx %%system %%time %%timeit %%writefileAutomagic is ON, % prefix IS NOT needed for line magics.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 BPR&#58 Bayesian Personalized Ranking from Implict Feedback]]></title>
    <url>%2F2019%2F09%2F30%2Frecommender-system-bpr%2F</url>
    <content type="text"><![CDATA[贝叶斯个性化排序（Bayesian Personalized Ranking，BPR）是一种基于pairwise的排序算法，主要利用用户的隐式反馈（如点击、浏览、购买等行为），通过最大化后验概率来对物品进行个性化排序。 BPR符号定义U表示所有用户构成的集合、I表示所有物品构成的集合，正反馈$S \subseteq U \times I$，用户u的偏好$&gt;_u \subset I^2 ​$ $&gt;_u​$需要满足： 完整性：$\forall i,j \in I : i \neq j\ \Rightarrow i &gt;_u j \lor j &gt;_u i\quad$ 反对称性：$\forall i,j \in I : i &gt;_u j \land j &gt;_u i\ \Rightarrow i = j\quad$ 传递性：$\forall i,j,k \in I : i &gt;_u j \land j &gt;_u k\ \Rightarrow i &gt;_u k\quad$ $I_u^+$表示用户u交互过的物品集合，$U_i^+​$表示与物品i有过交互的用户集合，即：$$I_u^+ := \{i \in I : (u,i) \in S \} \\U_i^+ := \{u \in U : (u,i) \in S \}$$假定相对于所有未被观察到的物品，用户更偏好 从而，训练数据集$D_s$可以表示为$$D_s := \{(u,i,j) | i \in I_u^+ \land j \in I \setminus I_u^+ \}$$其中，$(u,i,j) \in D_s$表示相对于物品j，用户u更偏好物品i；$\setminus$表示两个集合相减。 由于$&gt;_u$是反对称的，因此，负样本也被隐式地考虑了。 BPR优化方法基本假设（1）每个用户之间的偏好行为相互独立 （2）同一用户对不同物品的偏序相互独立 目标函数的推导BPR算法的基本思想是通过最大化后验概率$p(\Theta | &gt;_u)$，为所有物品$i \in I$找到正确的个性化排序。其中，$\Theta​$是任意模型（如矩阵分解）的参数向量。 根据贝叶斯公式$$p(\Theta | &gt;_u) \cdot p(&gt;_u) = p(&gt;_u | \Theta) \cdot p(\Theta) \tag{1}$$由于BPR算法假设每个用户之间的偏好行为相互独立，从而，对于任意一个用户u，其偏好的概率$p(&gt;_u)​$是一个常数。 因此，$p(\Theta | &gt;_u) ​$正比于$ p(&gt;_u | \Theta) \cdot p(\Theta)​$，即：$$p(\Theta | &gt;_u) \propto p(&gt;_u | \Theta) \cdot p(\Theta) \tag{2}$$先考虑式(2)右边第一个分量$p(&gt;_u | \Theta)$，其似然函数为$$\prod_{u \in U} p(&gt;_u | \Theta) = \prod_{(u,i,j) \in U \times I \times I} p(i &gt;_u j | \Theta)^{\delta ( \ (u,i,j)\ \in\ D_s\ )} \cdot (1 - p(i &gt;_u j | \Theta))^{\delta ( \ (u,i,j)\ \notin\ D_s\ )} \tag{3}$$其中，$\delta​$是指示函数$$\delta(b) :=\begin{cases}1, &amp; if\ b\ is\ true \\0, &amp; else\end{cases} \tag{4}$$根据完整性和反对称性，式(3)可以化简为$$\prod_{u \in U} p(&gt;_u | \Theta) = \prod_{(u,i,j) \in D_s} p(i &gt;_u j | \Theta) \tag{5}$$对于$p(i &gt;_u j | \Theta)​$这个概率，作者将其定义为$$p(i &gt;_u j | \Theta) := \sigma(\hat x_{uij} (\Theta)) \tag{6}$$其中，$\sigma​$是sigmoid函数$$\sigma (x) = \frac{1}{1+e^{-x}} \tag{7}$$当然，这里的$\sigma (x)​$可以是任何满足完整性、反对称性和传递性的函数。 $\hat{x}_{uij}(\Theta)$是关于模型参数向量$\Theta$的任意实值函数，只要该函数能够反映用户u、物品i和物品j之间的关系。 现在，我们来考虑式(2)右边的先验概率$p(\Theta)​$。 由于$\Theta$的分布是未知的，作者假设其服从均值为0，协方差矩阵为$\Sigma_\Theta = \lambda_\Theta I$的正态分布$$p(\Theta) \sim N(0, \Sigma_\Theta) \tag{8}$$$\Theta​$的概率密度函数为：$$f(\Theta) = \frac{1}{(2\pi)^{\frac{n}{2}} \lvert \Sigma_\Theta \rvert^{\frac{1}{2}}} \exp \{-\frac{1}{2} \Theta^T \Sigma_\Theta^{-1} \Theta \} \tag{9}$$经过计算$$\ln p(\Theta) \propto -\lambda_\Theta \lVert \Theta \rVert^2 \tag{10}$$于是，最大化$p(\Theta | &gt;_u) ​$变成了求解下式的最大值$$\begin{align}BPR-OPT &amp;:= \ln p(\Theta | &gt;_u) \\&amp;= \ln p(&gt;_u | \Theta) p(\Theta) \\&amp;= \ln \prod_{(u,i,j) \in D_s} \sigma(\hat x_{uij}) p(\Theta) \\&amp;= \sum_{(u,i,j) \in D_s} \ln \sigma(\hat x_{uij}) + \ln p(\Theta) \\&amp;= \sum_{(u,i,j) \in D_s} \ln \sigma(\hat x_{uij}) - \lambda_\Theta \lVert \Theta \rVert^2\end{align} \tag{11}$$其中，$\lambda_\Theta​$是模型的正则化参数。 BPR学习算法BPR-OPT对模型参数向量$\Theta$的梯度为：$$\begin{align}\frac{\partial BPR-OPT}{\partial \Theta}&amp;= \sum_{(u,i,j) \in D_s} \frac{\partial}{\partial \Theta} \ln \sigma(\hat x_{uij}) - \lambda_\Theta \frac{\partial}{\partial \Theta}\lVert \Theta \rVert^2 \\&amp;= \sum_{(u,i,j) \in D_s} \frac{\partial}{\partial \Theta} \ln \sigma(\hat x_{uij}) - 2\lambda_\Theta \Theta \\&amp;\propto \sum_{(u,i,j) \in D_s} \frac{e^{-\hat x_{uij}}}{1 + e^{-\hat x_{uij}}} \frac{\partial}{\partial \Theta}\hat x_{uij} - \lambda_\Theta \Theta\end{align} \tag{12}$$由于$\sigma (x)$为sigmoid函数，其导数为$$\sigma(x)^\prime = \frac{e^{-x}}{(1 + e^{-x})^2} = \sigma(x) (1 - \sigma(x)) \tag{13}$$故$$\begin{align}\frac{\partial}{\partial \Theta} \ln \sigma(\hat x_{uij})&amp;= \frac{1}{\sigma(\hat x_{uij})} \sigma(\hat x_{uij}) (1 - \sigma(\hat x_{uij})) \frac{\partial}{\partial \Theta}\hat x_{uij} \\&amp;= \frac{e^{-\hat x_{uij}}}{1 + e^{-\hat x_{uij}}} \frac{\partial}{\partial \Theta}\hat x_{uij} \\&amp;= \frac{1}{e^{\hat x_{uij}} + 1} \frac{\partial}{\partial \Theta}\hat x_{uij}\end{align} \tag{14}$$作者提出了一个基于自助法(bootstrapping)的随机梯度下降算法LEARNBPR来最大化BPR-OPT$$\begin{align}&amp; procedure\ LEARNBPR(D_s, \Theta) \\&amp; \quad initialize\ \Theta \\&amp; \quad \mathbf{repeat} \\&amp; \qquad draw\ (u,i,j)\ from\ D_s \\&amp; \qquad \Theta \leftarrow \Theta + \alpha \left( \frac{e^{-\hat x_{uij}}}{1 + e^{-\hat x_{uij}}} \frac{\partial}{\partial \Theta}\hat x_{uij} - \lambda_\Theta \Theta \right) \\&amp; \quad \mathbf{until}\ convergence \\&amp; \quad \mathbf{return}\ \hat \Theta \\&amp; end procedure\end{align}$$其中，$\alpha$为学习率，$\lambda_\Theta$为正则化参数。 何为自助法？从给定训练集中有放回的均匀抽样。 应用对于$\hat x_{uij} (\Theta) $，它需要满足：当$i &gt;_u j$ 时，$\hat x_{uij} &gt; 0$；反之，当$j &gt;_u i$ 时，$\hat x_{uij} &lt; 0$。 为了简化计算，作者将其定义为$$\hat x_{uij} := \hat x_{ui} - \hat x_{uj} \tag{15}$$最大化BPR-OPT，等价于最小化下式$$Loss = \sum_{(u,i,j) \in D_s} -\ln \sigma(\hat x_{ui} - \hat x_{uj}) + \lambda_\Theta \lVert \Theta \rVert^2 \tag{16}$$ 矩阵分解预测$\hat x_{ui}$，可以看作是估计矩阵X：$U \times I$。目标矩阵X可以用两个低秩矩阵W：$\lvert U \rvert \times k$和H：$\lvert I \rvert \times k$的乘积来估计。$$\hat x := W H^T \tag{17}$$W中的每一行$w_u$是描述用户u的特征向量，H中的每一行$h_i$是描述物品i的特征向量。$$\hat x_{ui} = w_u \cdot h_i^T = \sum_{f=1}^k w_{uf} h_{if} \tag{18}$$从而：$$\hat x_{uij} = \sum_{f=1}^k w_{uf} (h_{if} - h_{jf}) \tag{19}$$矩阵分解的模型参数$\Theta=(W,H)​$$$\frac{\partial}{\partial \theta} \hat x_{uij} =\begin{cases}(h_{if} - h_{jf}) &amp; if\ \theta = w_{uf}, \\w_{uf} &amp; if\ \theta = h_{if}, \\-w_{uf} &amp; if\ \theta = h_{jf}, \\0 &amp; else\end{cases} \tag{20}$$ 此时，损失函数为：$$Loss = \sum_{(u,i,j) \in D_s} -\ln \sigma(\hat x_{ui} - \hat x_{uj}) + \lambda_W \cdot w_{uf}^2 + \lambda_{H^+} \cdot h_{if}^2 + \lambda_{H^-} \cdot h_{jf}^2 \tag{21}$$其中，$\lambda_W、\lambda_{H^+}、\lambda_{H^-}​$分别为用户特征W、正样本$h_{if}​$、负样本$h_{jf}​$的正则化参数。 模型迭代公式如下：$$w_{uf} \leftarrow w_{uf} + \alpha \left(\frac{1}{e^x + 1} \cdot (h_{if} - h_{jf}) - \lambda_W \cdot w_{uf} \right) \\h_{if} \leftarrow h_{if} + \alpha \left(\frac{1}{e^x + 1} \cdot w_{uf} - \lambda_{H^+} \cdot h_{if} \right) \\h_{jf} \leftarrow h_{jf} + \alpha \left(\frac{1}{e^x + 1} \cdot (-w_{uf}) - \lambda_{H^-} \cdot h_{jf}\right)$$ 写在最后的话1.对于式(3)，论文中的原始表述为$$\prod_{u \in U} p(&gt;_u | \Theta) = \prod_{(u,i,j) \in U \times I \times I} p(i &gt;_u j | \Theta)^{\delta ( \ (u,i,j)\ \in\ D_s\ )} \cdot (1 - p(i &gt;_u j | \Theta))^{\delta ( \ (u,j,i)\ \notin\ D_s\ )}$$笔者认为后一项的指数应该是$\delta ( \ (u,i,j)\ \notin\ D_s\ )$ ，表示 $i &gt;_u j$ 不成立。 2.对于式(12)，论文中的原始表述为$$\begin{align}\frac{\partial BPR-OPT}{\partial \Theta}&amp;= \sum_{(u,i,j) \in D_s} \frac{\partial}{\partial \Theta} \ln \sigma(\hat x_{uij}) - \lambda_\Theta \frac{\partial}{\partial \Theta}\lVert \Theta \rVert^2 \\&amp;\propto \sum_{(u,i,j) \in D_s} \frac{-e^{-\hat x_{uij}}}{1 + e^{-\hat x_{uij}}} \frac{\partial}{\partial \Theta}\hat x_{uij} - \lambda_\Theta \Theta\end{align}$$根据式(14)，第一项的求导结果应该是不带负号的，即$\frac{e^{-\hat x_{uij}}}{1 + e^{-\hat x_{uij}}} \frac{\partial}{\partial \Theta}\hat x_{uij}$，个人认为是作者写错了。 对于上述两个问题，如果是我理解错了，希望大伙不吝赐教。 参考文献1.Steffen Rendle, Christoph Freudenthaler, Zeno Gantner, and Lars Schmidt-Thieme. 2009. BPR: Bayesian personalized ranking from implicit feedback. In Proceedings of the Twenty-Fifth Conference on Uncertainty in Artificial Intelligence (UAI ‘09). AUAI Press, Arlington, Virginia, United States, 452-461. [PDF] 2.https://github.com/guoguibing/librec/blob/3.0.0/core/src/main/java/net/librec/recommender/cf/ranking/BPRRecommender.java]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python元组（tuple）]]></title>
    <url>%2F2019%2F09%2F29%2Fpython-tuple%2F</url>
    <content type="text"><![CDATA[在Python中，元组与列表类似，不同之处在于列表中的元素是可以修改的，而元组中的元素是不可修改的。 元组用圆括号()来标识，并用逗号来分隔其中的元素。 创建空元组 12345# 定义空元组digits = ()print(digits)# 输出digits的类型print(type(digits)) 输出： 12()&lt;class 'tuple'&gt; 元组中只包含一个元素时，需要在元素后面添加逗号, 123digits = (1,)print(digits)print(type(digits)) 输出： 12(1,)&lt;class 'tuple'&gt; 元组中没有append()和insert()等插入元素的方法。 123digits = (1, 2)# 元组没有append和insert方法digits.append(3) 输出： 123Traceback (most recent call last): File "&lt;stdin&gt;", line 2, in &lt;module&gt;AttributeError: 'tuple' object has no attribute 'append' 元组中的元素是不可变的，一旦初始化便不可修改。 123digits = (1, 2)# 尝试修改元组中索引为0的元素digits[0] = 2 输出： 123Traceback (most recent call last): File "&lt;stdin&gt;", line 2, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python列表（list）]]></title>
    <url>%2F2019%2F09%2F28%2Fpython-list%2F</url>
    <content type="text"><![CDATA[在Python中，用方括号[]来表示列表，并用逗号来分隔其中的元素。列表中的元素类型可以不一致。 创建列表使用方括号[]来创建列表。 123# 创建一个空列表test_list = []print(type(test_list)) 输出： 1&lt;class 'list'&gt; 访问元素 使用索引访问列表中的元素，索引从0开始。 12digits = [1, 2, 3]print(digits[0]) 输出： 11 负数索引-index表示倒数第index个元素。索引-1返回最后一个列表元素，索引-2返回倒数第二个列表元素，依次类推。 12digits = [1, 2, 3]print(digits[-1]) 输出： 13 修改元素要修改列表元素，可指定列表名和要修改的元素索引，再指定该元素的新值。 123digits = [1, 2, 3]digits[0] = -1print(digits) 输出： 1[-1, 2, 3] 添加元素在列表末尾添加元素使用append(object)方法。 123test_list = [1, 2]test_list.append(3)print(test_list) 输出： 1[1, 2, 3] 在列表中插入元素使用insert(index, object)方法。 123456test_list = [1, 2]test_list.insert(0, 3)print(test_list)test_list.insert(3, 4)print(test_list) 输出： 1[3, 1, 2, 4] 用新列表扩展原来的列表使用extend()方法，可以在列表末尾一次性追加另一个列表中的多个值。 函数原型：extend(iterable) 12345digits = [1, 2, 3]digits2 = [4, 5, 6]digits.extend(digits2)print(digits) 输出： 1[1, 2, 3, 4, 5, 6] 删除元素使用del关键字删除元素删除指定索引处的元素。 12345678test_list = [1, 2, 3]# 删除索引为2的元素del test_list[2]print(test_list)# 删除索引为1的元素del test_list[1]print(test_list) 输出： 12[1, 2][1] 使用方法pop()弹出元素删除索引为index的元素，并将其返回。index默认为-1，即删除最后一个元素。 函数原型：pop(index=-1) 示例： 123456789digits = [1, 2, 3]# 删除最后一个元素x = digits.pop()print(x)print(digits)# 删除索引为1的元素digits.pop(1)print(digits) 输出： 1233[1, 2][1] 根据值删除元素如果知道要删除的值，可以使用remove方法。 值得注意的是，remove方法只移除列表中某个值的第一个匹配项。 函数原型：remove(value) 示例： 1234test_list = [1, 2, 3, 3]# 删除最后一个元素test_list.remove(3)print(test_list) 输出： 1[1, 2, 3] 反转列表使用reverse()方法，将列表中的元素反向排序。 123digits = [4, 2, 3]digits.reverse()print(digits) 输出： 1[3, 2, 4]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文中常见的缩写词]]></title>
    <url>%2F2019%2F09%2F28%2Fpaper-abbreviation%2F</url>
    <content type="text"><![CDATA[在阅读英文文献时，总能看到许多缩写词，譬如e.g.和i.e.等。本文对常见的缩写词进行了总结。 aka.also known as，又名。 cf.源自拉丁文 confer 释义：参见，参看 e.g.源自拉丁文exempli gratia 释义：等于for example，例如 et al.等于and others used as an abbreviation of et alii (masculine plural) or et aliae (feminine plural) or et alia (neutral plural) when referring to a number of people etc.源自拉丁文et cetera 释义：等等 i.e.源自拉丁文id est 释义：换言之 i.i.d.independent and identically distributed 独立同分布 n.b.源自拉丁文nota bene 释义：等于note well，注意 vs.versus 与…相比 w.r.t.with respect to]]></content>
      <categories>
        <category>paper</category>
      </categories>
      <tags>
        <tag>paper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文阅读 Neural Collaborative Filtering]]></title>
    <url>%2F2019%2F09%2F17%2Frecommender-system-neural-collaborative-filtering%2F</url>
    <content type="text"><![CDATA[Neural Collaborative Filtering提出了一种融合模型，将深度学习运用到推荐系统中，在隐式反馈问题上获得了state-of-the-art。 隐式反馈：$$y_{ui} =\begin{cases}1, &amp; if\ iteraction\ (user\ u,item\ i)\ is\ observed; \\0, &amp; otherwise.\end{cases}$$ NCF(Neural Collaborative Filtering) 似然函数：$$p(\mathcal{Y},\mathcal{Y}^{-}|\mathbf{P},\mathbf{Q},\Theta_{f}) = \prod_{(u,i) \in \mathcal{Y}} \hat y_{ui} \prod_{(u,j) \in \mathcal{Y}^{-}} (1-\hat y_{uj})$$取负对数，得到目标函数：$$\begin{align}\min L &amp;= - \sum_{(u,i) \in \mathcal{Y}}\log{\hat y_{ui}} - \sum_{(u,j) \in \mathcal{Y}^{-}} \log{(1-\hat y_{uj})} \\ &amp;= - \sum_{(u,i) \in \mathcal{Y} \cup (u,j) \in \mathcal{Y}^{-}}{y_{ui} \log{\hat y_{ui}} + (1-y_{ui}) \log{(1-\hat y_{ui})}}\end{align}$$上式就是二元交叉熵损失。 GMF$$\hat y_{ui} = a_{out}(\mathbf{h}^T (\mathbf{p_u} \odot \mathbf{q_i}))$$其中，$a_{out}$是激活函数，$\mathbf{h}^T$是输出层的边权值，$\otimes$表示逐元素相乘，$\mathbf{p_u}$和$\mathbf{q_i}$分别表示用户u和物品i的隐向量。 MLP$$\mathbf{z_1} = \phi_{1}(\mathbf{p_u}, \mathbf{q_i}) =\begin{bmatrix}\mathbf{p_u} \\\mathbf{q_i}\end{bmatrix}, \\phi_2(\mathbf{z_1}) = a_2 (\mathbf{W_2}^T \mathbf{z_1} + \mathbf{b_2})), \\\cdots \\\phi_L(\mathbf{z_{L-1}}) = a_L(\mathbf{W_L}^T \mathbf{z_{L-1}} + \mathbf{b_L})),\\\hat{y_{ui}} = \sigma(\mathbf{h^T}\phi_L (\mathbf{Z_{L-1}}))$$ 其中，$\mathbf{W}_x$第x层的权重矩阵，$\mathbf{b}_x$是偏置向量，$a_x$是激活函数，$\sigma$是Sigmoid函数。 NeuMF（Nerual matrix factorization）让GMF和MLP分别学习不同的embeddings，将两个模型的最后一个隐含层拼接起来。$$\phi^{GMF} = \mathbf{p}_u^G \odot \mathbf{q}_i^G,\\\phi^{MLP}=a_L(\mathbf{W}^T_L(a_{L-1}(\cdots a_2(\mathbf{W_2}^T \mathbf{z_1} + \mathbf{b_2}) \cdots)) + \mathbf{b_L})) \\\hat{y_{ui}} = \sigma (\mathbf{h}^T\begin{bmatrix}\phi^{GMF} \\\phi^{MLP}\end{bmatrix})$$其中，$\mathbf{p}_u^G$和$\mathbf{p}_u^M$分别表示GMF和MLP的user embedding，$\mathbf{q}_u^G$和$\mathbf{q}_u^M$亦然。 预训练NeuMF中，将GMF和MLP的最后一个隐含层，按照如下的方式拼接起来。$$\mathbf{h} \leftarrow\begin{bmatrix}\alpha \mathbf{h}^{GMF} \\(1-\alpha) \mathbf{h}^{MLP}\end{bmatrix}$$其中，$\mathbf{h}^{GMF}$和$\mathbf{h}^{MLP}$为预训练的GMF和MLP输出层的边权值$\mathbf{h}$。$\alpha$是一个超参数，用于权衡两个预训练模型。 使用Adam对预训练的GMF和MLP进行优化；对NeuMF，使用随机梯度下降SGD进行优化。 实验设置数据集：MovieLens-1m和Pinterest 评估方法：留一法（使用最后一次交互作为测试集，其他的作为训练集） 随机选取100个用户没有与之发生交互行为的物品，将测试物品与这100个样本混在一起进行排序。 评测指标：击中率（Hit Ratio）和NDCG。对这两个指标，采用Top10推荐。 Hit Ratio用于判断测试物品是否在排在前10。 为每个用户计算这两个指标，最后分别求平均值。 参数设置：使用高斯分布（均值为0，标准差为0.01）随机初始化模型参数，使用小批量的Adam优化模型。 使用三层的MLP，GMF和MLP的权衡超参数$\alpha$设置为0.5。（个人认为$\alpha$应该也是可以优化的，但是作者没有对$\alpha$的不同取值进行对比实验） 在训练集中，为每个正样本随机选择四个负样本。 相关资源Xiangnan He, Lizi Liao, Hanwang Zhang, Liqiang Nie, Xia Hu and Tat-Seng Chua (2017). Neural Collaborative Filtering. In Proceedings of WWW ‘17, Perth, Australia, April 03-07, 2017. 论文原文：http://staff.ustc.edu.cn/~hexn/papers/www17-ncf.pdf 论文代码：https://github.com/hexiangnan/neural_collaborative_filtering 作者使用的是keras 1.0.7，在最新版本中，某些函数（或者参数）已被废弃 我的复现（Keras 2.2.5）：https://github.com/hegongshan/neural_collaborative_filtering]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keras Model类中的常用方法]]></title>
    <url>%2F2019%2F09%2F17%2Fkeras-model%2F</url>
    <content type="text"><![CDATA[近一个月来，我都在阅读Keras之父著作的《Python深度学习》一书。书中最常使用的便是Keras的Model类。 通过查阅官方文档和Model类源码，本文将Keras Model类中的常用方法进行了梳理和总结。 compile用于配置训练模型。 fit以给定数量的轮次（数据集上的迭代）训练模型。 返回 一个 History 对象。其 History.history 属性是连续 epoch 训练损失和评估值，以及验证集损失和评估值的记录（如果适用）。 evaluate1234567891011evaluate(self, x=None, y=None, batch_size=None, verbose=1, sample_weight=None, steps=None, callbacks=None, max_queue_size=10, workers=1, use_multiprocessing=False) 在测试模式下返回模型的误差值和评估标准值。 计算是分批进行的。 summary12# 继承自Network类summary(self, line_length=None, positions=None, print_fn=None) 打印网络的总结信息。 1234567891011line_length: Total length of printed lines (e.g. set this to adapt the display to different terminal window sizes).positions: Relative or absolute positions of log elements in each line. If not provided, defaults to `[.33, .55, .67, 1.]`.print_fn: Print function to use. It will be called on each line of the summary. You can set it to a custom function in order to capture the string summary. It defaults to `print` (prints to stdout). predict为输入样本生成输出预测。 计算是分批进行的 predict_classes12# 子类Sequential中的方法predict_classes(self, x, batch_size=32, verbose=0) 为输入样本生成类别预测。 计算是分批进行的 参数 x: 输入数据，Numpy 数组 （或者 Numpy 数组的列表，如果模型有多个输出）。 batch_size: 批量大小。如未指定，默认为 32。 verbose: 日志显示模式，0 或 1。 save函数原型： 12# 继承自Network类save(self, filepath, overwrite=True, include_optimizer=True) 将模型保存到一个HDF5文件中。 示例： 123456789from keras.models import load_model...model.save('my_model.h5') # creates a HDF5 file 'my_model.h5'del model # deletes the existing model# returns a compiled model# identical to the previous onemodel = load_model('my_model.h5') save_weights函数原型： 12# 继承自Network类save_weights(self, filepath, overwrite=True) 将各层的权重存储到HDF5文件中。 123filepath: String, path to the file to save the weights to.overwrite: Whether to silently overwrite any existing file at the target location, or provide the user with a manual prompt. load_weights函数原型： 12# 继承自Network类load_weights(self, filepath, by_name=False, skip_mismatch=False, reshape=False) get_layer12# 继承自Network类get_layer(self, name=None, index=None) 根据名称（唯一）或索引值查找网络层。 如果同时提供了 name 和 index，则 index 将优先。索引值来自于水平图遍历的顺序（自下而上）。 Keras Model类中文文档 https://keras.io/zh/models/model/#model Model类源码 https://github.com/keras-team/keras/blob/master/keras/engine/training.py]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串（str）]]></title>
    <url>%2F2019%2F09%2F13%2Fpython-string%2F</url>
    <content type="text"><![CDATA[字符串是Python中最常用的数据类型。我们可以使用引号&#39;或”来创建字符串。 capitalize()将字符串的第一个字母变成大写，其他字母变小写。 12temp = 'wuhan City'print(temp.capitalize()) 输出： 1Wuhan city title()返回”标题化”的字符串——所有单词的首个字母转化为大写，其余字母均为小写。 12temp = 'wuHan different every day!'print(temp.title()) 输出： 1Wuhan Different Every Day! upper()将字符串中的小写字母转换为大写字母。 12temp = 'wuhan city'print(temp.upper()) 输出： 1WUHAN CITY lower()将字符串中的大写字母转换为小写字母。 12temp = 'Wuhan City'print(temp.lower()) 输出： 1wuhan city lstrip()返回截掉字符串左边的空格或指定字符后生成的新字符串。 语法： 1str.lstrip([chars]) 示例： 1234temp = ' wuhan city'print(temp.lstrip())temp = 'hhwuhan city88'print(temp.lstrip('h')) 输出： 12wuhan citywuhan city88 rstrip()返回截掉字符串右边的空格或指定字符后生成的新字符串。 strip()返回移除字符串头尾指定的字符序列（默认为空格）生成的新字符串。 join()用于将序列中的元素以指定的字符连接生成一个新的字符串。 语法： 1str.join(sequence) 示例： 12seq = ['w','u','h','a','n']print('-'.join(seq)) 输出： 1w-u-h-a-n]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pandas入门]]></title>
    <url>%2F2019%2F09%2F12%2Fpython-pandas%2F</url>
    <content type="text"><![CDATA[Pandas是一个Python数据分析库。 按照标准约定，我们在使用Pandas时，最好遵循如下格式： 1import pandas as pd DataFrame数据帧：二维表格型数据结构。 构造函数： 1DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) 常用属性 values：返回一个DataFrame的NumPy表示 shape：返回一个表示DataFrame维度的元组 访问元素 at：通过行名和列名来访问某一个元素。 12345import pandas as pddf = pd.DataFrame([[0, 2, 3], [0, 4, 1], [10, 20, 30]], index=[4, 5, 6], columns=['A', 'B', 'C'])print(df)print(df.at[4,'B']) 输出： 12345 A B C4 0 2 35 0 4 16 10 20 302 iat：通过行和列的索引来访问某一个元素。 1234import pandas as pddf = pd.DataFrame([[0, 2, 3], [0, 4, 1], [10, 20, 30]], index=[4, 5, 6], columns=['A', 'B', 'C'])print(df.iat[0,1]) 输出： 12 head 函数原型： 1head(n=5) 返回DataFrame的前n行，n的默认值为5。 tail 函数原型： 1tail(n=5) 返回DataFrame的最后n行，n的默认值为5。 遍历 iterrows()：按照行进行迭代，每次返回一个(index, Series)对 1234567import pandas as pddf = pd.DataFrame([[23,24],[25,26]],columns=['A','B'])for index,row in df.iterrows(): print(index) print(row) 输出： 123456780A 23B 24Name: 0, dtype: int641A 25B 26Name: 1, dtype: int64 iteritems()和items()：按照列进行迭代，每次返回一个(column name, Series)对 1234567import pandas as pddf = pd.DataFrame([[23,24],[25,26]],columns=['A','B'])for label, content in df.iteritems(): print(label) print(content) 输出： 12345678A0 231 25Name: A, dtype: int64B0 241 26Name: B, dtype: int64 添加行添加行可以使用DataFrame的append()方法，该方法将返回一个新的DataFrame对象。 123456import pandas as pddf = pd.DataFrame([[23,24]],columns=['A','B'])print(df)df = df.append(pd.DataFrame([[33,44]],columns=('A','B')),ignore_index=True)print(df) 输出： 12345 A B0 23 24 A B0 23 241 33 44 删除行/列删除行/列，可以使用DataFrame的drop()方法，该方法将返回一个新的DataFrame对象。 drop()包含一个叫axis的参数： axis : {0 or ‘index’, 1 or ‘columns’}, default 0 Whether to drop labels from the index (0 or ‘index’) or columns (1 or ‘columns’). 读取CSV文件使用read_csv()方法，可以读取CSV文件，并返回一个DataFrame对象。 123import pandas as pddf = pd.read_csv('./test.csv') 生成CSV文件使用DataFrame对象的to_csv()方法，可以方便地生成CSV文件。 123import pandas as pd...df.to_csv('./test.csv') 读取Excel文件读取Excel可以使用read_excel()（使用前需要先安装xlrd）。 123import pandas as pddf = pd.read_excel('./test.xlsx') 生成Excel文件使用DataFrame对象的to_excel()方法，可以方便地生成Excel文件（使用前需要先安装xlwt）。 123import pandas as pd...df.to_excel('./test.xlsx')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201709-3.JSON查询]]></title>
    <url>%2F2019%2F09%2F12%2Fccf-csp-20170903%2F</url>
    <content type="text"><![CDATA[问题描述 JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式，可以用来描述半结构化的数据。JSON 格式中的基本单元是值 (value)，出于简化的目的本题只涉及 2 种类型的值： 字符串 (string)：字符串是由双引号 “ 括起来的一组字符（可以为空）。如果字符串的内容中出现双引号 “，在双引号前面加反斜杠，也就是用 \&quot; 表示；如果出现反斜杠 \，则用两个反斜杠 \\ 表示。反斜杠后面不能出现 “ 和 \ 以外的字符。例如：&quot;&quot;、&quot;hello&quot;、&quot;\&quot;\\&quot;。 对象 (object)：对象是一组键值对的无序集合（可以为空）。键值对表示对象的属性，键是属性名，值是属性的内容。对象以左花括号 { 开始，右花括号 } 结束，键值对之间以逗号 , 分隔。一个键值对的键和值之间以冒号 : 分隔。键必须是字符串，同一个对象所有键值对的键必须两两都不相同；值可以是字符串，也可以是另一个对象。例如：{}、{“foo”: “bar”}、{“Mon”: “weekday”, “Tue”: “weekday”, “Sun”: “weekend”}。 除了字符串内部的位置，其他位置都可以插入一个或多个空格使得 JSON 的呈现更加美观，也可以在一些地方换行，不会影响所表示的数据内容。例如，上面举例的最后一个 JSON 数据也可以写成如下形式。 { “Mon”: “weekday”, “Tue”: “weekday”, “Sun”: “weekend” } 给出一个 JSON 格式描述的数据，以及若干查询，编程返回这些查询的结果。 输入格式 第一行是两个正整数 n 和 m，分别表示 JSON 数据的行数和查询的个数。 接下来 n 行，描述一个 JSON 数据，保证输入是一个合法的 JSON 对象。 接下来 m 行，每行描述一个查询。给出要查询的属性名，要求返回对应属性的内容。需要支持多层查询，各层的属性名之间用小数点 . 连接。保证查询的格式都是合法的。 输出格式 对于输入的每一个查询，按顺序输出查询结果，每个结果占一行。 如果查询结果是一个字符串，则输出 STRING &lt;string&gt;，其中 &lt;string&gt; 是字符串的值，中间用一个空格分隔。 如果查询结果是一个对象，则输出 OBJECT，不需要输出对象的内容。 如果查询结果不存在，则输出 NOTEXIST。 样例输入 1234567891011121314151610 5&#123;&quot;firstName&quot;: &quot;John&quot;,&quot;lastName&quot;: &quot;Smith&quot;,&quot;address&quot;: &#123;&quot;streetAddress&quot;: &quot;2ndStreet&quot;,&quot;city&quot;: &quot;NewYork&quot;,&quot;state&quot;: &quot;NY&quot;&#125;,&quot;esc\\aped&quot;: &quot;\&quot;hello\&quot;&quot;&#125;firstNameaddressaddress.cityaddress.postalesc\aped 样例输出 12345STRING JohnOBJECTSTRING NewYorkNOTEXISTSTRING &quot;hello&quot; 评测用例规模与约定 n ≤ 100，每行不超过 80 个字符。 m ≤ 100，每个查询的长度不超过 80 个字符。 字符串中的字符均为 ASCII 码 33-126 的可打印字符，不会出现空格。所有字符串都不是空串。 所有作为键的字符串不会包含小数点 .。查询时键的大小写敏感。 50%的评测用例输入的对象只有 1 层结构，80%的评测用例输入的对象结构层数不超过 2 层。举例来说，{“a”: “b”} 是一层结构的对象，{“a”: {“b”: “c”}} 是二层结构的对象，以此类推。 分析： 使用map&lt;string,string&gt;存储解析后的JSON字符串。 遇到对象，键值用{}表示。对象parent中的子对象或者字符串的属性名key，使用parent + &#39;.&#39; + key 作键名。 解析字符串的过程如下： 遇到右花括号}，则表示当前需要处理的json串已经结束； 遇到空格或者逗号,，则直接跳过； 遇到引号&quot;，则获取键名； 遇到冒号:，则先去掉可能存在的空格，然后判断值是字符串，还是对象。 若为字符串，则获取键值；若为对象，则去掉左花括号{后面可能存在的空格，继续解析JSON子串。 注意： 1.键的大小写敏感。 2.键名和键值中可能存在转义字符，需要将\&quot;转换为&quot;，将\\转换为\。 C++版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;map&lt;string, string&gt; json;// 从下标i开始，寻找键名或者键值，并去掉首尾的引号、中间的转义符号'\'string get(int &amp;i, string str) &#123; string key; i++; while (i &lt; str.size() &amp;&amp; str[i] != '"') &#123; // 若遇到转义符号，则跳过一位 if (str[i] == '\\') &#123; key += str[++i]; &#125; else &#123; key += str[i]; &#125; i++; &#125; return key;&#125;// 解析json字符串，parent表示当前处理的json串是哪个键的值，// str为尚未解析的字符串，返回值为本次解析的json串的长度int parseJSON(string parent, string str) &#123; string key; for (int i = 0; i &lt; str.size(); i++) &#123; // 遇到右花括号&#125;，表示当前需要处理的json串已经结束 if (str[i] == '&#125;') &#123; return i; &#125; if (str[i] == ' ' || str[i] == ',') &#123; continue; &#125; // 获取键名 if (str[i] == '"') &#123; key = get(i, str); continue; &#125; // 获取键值 if (str[i] == ':') &#123; // 去掉可能存在的空格 while (str[++i] == ' ') &#123;&#125; // 若值为字符串 if (str[i] == '"') &#123; string value = get(i, str); if (!parent.empty()) &#123; json[parent + '.' + key] = value; &#125; else &#123; json[key] = value; &#125; continue; &#125; // 若值为对象 // 去掉左花括号&#123;后面可能存在的空格 while (str[++i] == ' ') &#123;&#125; string newParent; if (!parent.empty()) &#123; newParent = parent + '.' + key; &#125; else &#123; newParent = key; &#125; // 用&#123;&#125;标记newParent的值为对象 json[newParent] = "&#123;&#125;"; // 解析子串 i += parseJSON(newParent, str.substr(i)); &#125; &#125; return str.size();&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; getchar(); string str = ""; string line; while (n--) &#123; getline(cin, line); str += line; &#125; parseJSON("", str); while (m--) &#123; cin &gt;&gt; line; if (!json.count(line)) &#123; cout &lt;&lt; "NOTEXIST" &lt;&lt; endl; &#125; else if (json[line] == "&#123;&#125;") &#123; cout &lt;&lt; "OBJECT" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "STRING " &lt;&lt; json[line] &lt;&lt; endl; &#125; &#125; return 0;&#125; Java版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Main &#123; public static Map&lt;String, String&gt; json = new HashMap&lt;&gt;(); // 返回键名或键值最后一个字符的索引号 public static int offset(int i, String str) &#123; i++; while (i &lt; str.length() &amp;&amp; str.charAt(i) != '"') &#123; if (str.charAt(i) == '\\') &#123; i++; &#125; i++; &#125; return i; &#125; // 解析json字符串，parent表示当前处理的json串是哪个键的值， // str为尚未解析的字符串，返回值为本次解析的json串的长度 public static int parseJSON(String parent, String str) &#123; String key = null; for (int i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) == '&#125;') &#123; return i; &#125; if (str.charAt(i) == ' ' || str.charAt(i) == ',') &#123; continue; &#125; // 获取键名 if (str.charAt(i) == '"') &#123; int index = offset(i, str); // 将键名中的\\替换为\，\"替换为" key = str.substring(i + 1, index).replace("\\\\", "\\").replace("\\\"", "\""); i = index; continue; &#125; // 获取键值 if (str.charAt(i) == ':') &#123; // 去掉可能存在的空格 while (str.charAt(++i) == ' ') &#123;&#125; // 若值为字符串 if (str.charAt(i) == '"') &#123; int index = offset(i, str); String value = str.substring(i + 1, index).replace("\\\\", "\\").replace("\\\"", "\""); i = index; if (parent.isEmpty()) &#123; json.put(key, value); &#125; else &#123; json.put(parent + '.' + key, value); &#125; continue; &#125; // 若值为对象 // 去掉左花括号&#123;后面可能存在的空格 while (str.charAt(++i) == ' ') &#123;&#125; String newParent; if (parent.isEmpty()) &#123; newParent = key; &#125; else &#123; newParent = parent + '.' + key; &#125; // 用&#123;&#125;标记newParent的值为对象 json.put(newParent, "&#123;&#125;"); // 解析子串 i += parseJSON(newParent, str.substring(i)); &#125; &#125; return str.length(); &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int m = scan.nextInt(); scan.nextLine(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) &#123; sb.append(scan.nextLine().trim()); &#125; parseJSON("", sb.toString()); StringBuilder out = new StringBuilder(); for (int i = 0; i &lt; m; i++) &#123; String key = scan.nextLine().trim(); if (!json.containsKey(key)) &#123; out.append("NOTEXIST\n"); &#125; else if (json.get(key) == "&#123;&#125;") &#123; out.append("OBJECT\n"); &#125; else &#123; out.append("STRING ").append(json.get(key)).append('\n'); &#125; &#125; scan.close(); System.out.println(out.toString()); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201809-3.元素选择器]]></title>
    <url>%2F2019%2F09%2F12%2Fccf-csp-20180903%2F</url>
    <content type="text"><![CDATA[分析： 定义结构体（类）存储每一个元素节点 12345typedef struct Node &#123; // 当前节点位于文档树中第几层 int level; string label, id;&#125; Element; 使用C++中的vector&lt;Element&gt;（Java中使用List&lt;Element&gt;）存储整个文档。 在文档中，元素e的父节点就是e前面第一个level小于e的元素。 查询分为以下三种情况： （1）id选择器。题目告诉我们，文档中不同的元素不会有相同的id属性。 （2）标签选择器。匹配的标签可能有很多个。 （3）后代选择器。题目提示我们：除最后一级外，前面的部分都可以尽量匹配层级小的元素。 因此，我们可以从后代选择器的最后一个选择器selector开始，在文档中寻找匹配的元素。如果能找到这样的元素e，则在e的祖先元素中，寻找与selector的前一个选择器相匹配的元素。当遍历到根结点或者已经找到与后代选择器相匹配的元素时，循环结束。 注意： 1.id属性区分大小写，而标签不区分大小写。 2.后代选择器：A B，其中A和B均为标签选择器或者id选择器，表示选择满足选择器B的所有元素，且满足这些元素有祖先元素满足选择器A。因此，只要有祖先元素满足选择器A即可，父元素并不一定要满足选择器A。 C++版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;vector&gt;using namespace std;typedef struct Node &#123; // 当前节点位于文档树中第几层 int level; string label, id;&#125; Element;// 将字符串转换为小写形式string to_lower(string tag) &#123; for (int i = 0; i &lt; tag.size(); i++) &#123; if ('A' &lt;= tag[i] &amp;&amp; tag[i] &lt;= 'Z') &#123; tag[i] += 32; &#125; &#125; return tag;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; getchar(); vector&lt;Element&gt; doc; string line; int parent = 1; while (n--) &#123; getline(cin, line); Element e; // 计算当前节点在文档树中的层级 int count = 0; while (line[count] == '.') &#123; count++; &#125; e.level = count / 2; // 处理标签和id int index = line.find(" "); if (index != string::npos) &#123; e.label = to_lower(line.substr(count, index - count)); e.id = line.substr(index + 1, line.size() - index - 1); &#125; else &#123; e.label = to_lower(line.substr(count)); e.id = ""; &#125; doc.push_back(e); &#125; while (m--) &#123; getline(cin, line); vector&lt;int&gt; pos; // 若为id选择器或者标签选择器 if (line.find(" ") == string::npos) &#123; for (int i = 0; i &lt; doc.size(); i++) &#123; if (doc[i].id == line || doc[i].label == to_lower(line)) &#123; pos.push_back(i + 1); &#125; &#125; &#125; else &#123; stringstream ss; ss &lt;&lt; line; // 存储后代选择器中的所有选择器 vector&lt;string&gt; selectors; while (ss &gt;&gt; line) &#123; // 若为标签，则转换为小写形式 if (line[0] != '#') &#123; line = to_lower(line); &#125; selectors.push_back(line); &#125; string last = selectors[selectors.size() - 1]; for (int i = 0; i &lt; doc.size(); i++) &#123; // 如果当前元素与后代选择器的最后一个选择器不匹配，则继续循环 if (last != doc[i].id &amp;&amp; last != doc[i].label) &#123; continue; &#125; int index = selectors.size() - 2; int level = doc[i].level; for (int k = i; k &gt;= 0 &amp;&amp; index &gt;= 0; k--) &#123; Element e = doc[k]; string selector = selectors[index]; // 寻找父节点（level比当前节点小的第一个节点） if (e.level &lt; level) &#123; level = e.level; // 若父节点匹配当前选择器，则继续匹配；否则，继续向上寻找祖先节点 if (selector == e.id || selector == e.label) &#123; index--; &#125; &#125; &#125; // 如果完全匹配后代选择器 if (index &lt; 0) &#123; pos.push_back(i + 1); &#125; &#125; &#125; cout &lt;&lt; pos.size(); for (int i = 0; i &lt; pos.size(); i++) &#123; cout &lt;&lt; ' ' &lt;&lt; pos[i]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Java版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Main &#123; static class Element &#123; int level; String label, id; public Element(int level, String label, String id) &#123; this.level = level; this.label = label; this.id = id; &#125; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int m = scan.nextInt(); scan.nextLine(); List&lt;Element&gt; doc = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; String line = scan.nextLine(); int level = 0; String label, id; // 计算当前节点在文档树中的层级 int count = 0; while (line.charAt(count) == '.') &#123; count++; &#125; level = count / 2; // 处理标签和id int index = line.indexOf(" "); if (index == -1) &#123; label = line.substring(count); id = ""; &#125; else &#123; label = line.substring(count, index); id = line.substring(index + 1, line.length()); &#125; doc.add(new Element(level, label, id)); &#125; for (int i = 0; i &lt; m; i++) &#123; String selector = scan.nextLine(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); // 若为id选择器或者标签选择器 if (!selector.contains(" ")) &#123; for (int j = 0; j &lt; doc.size(); j++) &#123; Element e = doc.get(j); if (selector.equalsIgnoreCase(e.label) || selector.equals(e.id)) &#123; list.add(j + 1); &#125; &#125; &#125; else &#123; String[] selectors = selector.split(" "); String last = selectors[selectors.length - 1]; for (int j = 0; j &lt; doc.size(); j++) &#123; // 如果当前元素与后代选择器的最后一个选择器不匹配，则继续循环 if (!last.equalsIgnoreCase(doc.get(j).label) &amp;&amp; !last.equals(doc.get(j).id)) &#123; continue; &#125; int index = selectors.length - 2; int level = doc.get(j).level; for (int k = j; k &gt;= 0 &amp;&amp; index &gt;= 0; k--) &#123; Element e = doc.get(k); String str = selectors[index]; // 寻找父节点（level比当前节点小的第一个节点） if (e.level &lt; level) &#123; level = e.level; // 若父节点匹配当前选择器，则继续匹配；否则，向上寻找祖先节点 if (str.equalsIgnoreCase(e.label) || str.equals(e.id)) &#123; index--; &#125; &#125; &#125; // 如果完全匹配后代选择器 if (index &lt; 0) &#123; list.add(j + 1); &#125; &#125; &#125; System.out.print(list.size()); for (Integer line : list) &#123; System.out.print(" " + line); &#125; System.out.println(); &#125; scan.close(); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201412-3.集合竞价]]></title>
    <url>%2F2019%2F09%2F10%2Fccf-csp-20141203%2F</url>
    <content type="text"><![CDATA[问题描述 某股票交易所请你编写一个程序，根据开盘前客户提交的订单来确定某特定股票的开盘价和开盘成交量。 该程序的输入由很多行构成，每一行为一条记录，记录可能有以下几种： 1. buy p s 表示一个购买股票的买单，每手出价为p，购买股数为s。 2. sell p s 表示一个出售股票的卖单，每手出价为p，出售股数为s。 3. cancel i表示撤销第i行的记录。 如果开盘价为p0，则系统可以将所有出价至少为p0的买单和所有出价至多为p0的卖单进行匹配。因此，此时的开盘成交量为出价至少为p0的买单的总股数和所有出价至多为p0的卖单的总股数之间的较小值。 你的程序需要确定一个开盘价，使得开盘成交量尽可能地大。如果有多个符合条件的开盘价，你的程序应当输出最高的那一个。 输入格式 输入数据有任意多行，每一行是一条记录。保证输入合法。股数为不超过$10^8$的正整数，出价为精确到恰好小数点后两位的正实数，且不超过10000.00。 输出格式 你需要输出一行，包含两个数，以一个空格分隔。第一个数是开盘价，第二个是此开盘价下的成交量。开盘价需要精确到小数点后恰好两位。 样例输入 buy 9.25 100buy 8.88 175sell 9.00 1000buy 9.00 400sell 8.92 400cancel 1buy 100.00 50 样例输出 9.00 450 评测用例规模与约定 对于100%的数据，输入的行数不超过5000。 分析： 定义类（结构体）表示每行的交易记录 12345678910typedef struct Node &#123; // 交易类型，0-buy,1-sell,2-cancel int type; // 出价 float price; // 交易的股数 int amount; // 交易是否被取消 bool cancel;&#125; Transaction; 用vector&lt;Transaction&gt;（Java中用List&lt;Transaction&gt;）存储输入的所有交易记录。 按照交易记录的类型，分为买单和卖单。买单和卖单均按照价格从小到大的顺序排列。 设使得成交量最大的开盘价为price，最大成交量为maxAmount，二者均初始化为0。 遍历所有的买单（开盘价一定会在买单中出现，证明见2），以当前交易的出价p为开盘价，计算成交量dealAmount。 若dealAmount &gt; maxAmount 或者 dealAmount == maxAmount &amp;&amp; p &gt; price，则更新price和maxAmount。 1.成交量最高将达到$2500 \times 10^8 = 2.5 \times 10^{11}​$，超出了int的存储范围。 因此，在C++中，成交量、买单和卖单的总股数，要用long long存储；Java中使用long存储。 2.开盘价p0一定会在买单中出现。 证明：（反证法）假设开盘价p0只在卖单中出现： 设出价至少为p0的买单的总股数为s1，出价至多为p0的卖单的总股数为s2。 此时的成交量$sale0 = min(s1,s2)$ $\exists p \in 买单, 使得p \gt p0成立$，$p1 = \min p \gt p0$。 设出价至少为p1的买单的总股数为s3，出价至多为p1的卖单的总股数为s4。 从而，$s1 =s3,s2 \le s4 $ , $sale1=min(s1,s4) \ge sale0$，应选择p1为开盘价，这与假设矛盾。 故，开盘价一定会在买单中出现。 C++版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef struct Node &#123; // 交易类型，0-buy,1-sell,2-cancel int type; // 出价 float price; // 交易的股数 int amount; // 交易是否被取消 bool cancel;&#125; Transaction;bool cmp(Transaction a, Transaction b) &#123; return a.price &lt; b.price;&#125;int main() &#123; char status[7]; vector&lt;Transaction&gt; arr; while (scanf("%s", status) != EOF) &#123; Transaction t; // 若为撤销 if (strcmp(status, "cancel") == 0) &#123; int line; scanf("%d", &amp;line); t.type = 2; t.cancel = true; arr.push_back(t); // 撤销第line行的交易记录 arr[line - 1].cancel = true; continue; &#125; if (strcmp(status, "buy") == 0) &#123; // 若为买单 t.type = 0; &#125; else &#123; // 若为卖单 t.type = 1; &#125; t.cancel = false; scanf("%f %d", &amp;t.price, &amp;t.amount); arr.push_back(t); &#125; // 分割为买单和卖单 vector&lt;Transaction&gt; buys; vector&lt;Transaction&gt; sells; for (int i = 0; i &lt; arr.size(); i++) &#123; // 忽略被撤销的交易记录（或者撤销命令本身） if (arr[i].cancel) &#123; continue; &#125; if (arr[i].type == 0) &#123; buys.push_back(arr[i]); &#125; else &#123; sells.push_back(arr[i]); &#125; &#125; // 按照价格从小到大排序 sort(buys.begin(), buys.end(), cmp); sort(sells.begin(), sells.end(), cmp); // 开盘价 float price; // 最大成交量 long long maxAmount = 0; for (int i = 0; i &lt; buys.size(); i++) &#123; Transaction t = buys[i]; long long buyAmount = 0, sellAmount = 0; for (int j = i; j &lt; buys.size(); j++) &#123; buyAmount += buys[j].amount; &#125; for (int j = 0; j &lt; sells.size() &amp;&amp; sells[j].price &lt;= t.price; j++) &#123; sellAmount += sells[j].amount; &#125; long long dealAmount = min(buyAmount, sellAmount); // 选择最大的成交量；若成交量相等，则选择最高的开盘价 if ((dealAmount &gt; maxAmount) || (dealAmount == maxAmount &amp;&amp; t.price &gt; price)) &#123; maxAmount = dealAmount; price = t.price; &#125; &#125; printf("%.2f %lld\n", price, maxAmount); return 0;&#125; Java版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Scanner;public class Main &#123; static class Transaction implements Comparable&lt;Transaction&gt; &#123; // 交易类型，0-buy,1-sell,2-cancel int type; // 出价 double price; // 交易的股数 long amount; // 交易是否被取消 boolean cancel; @Override public int compareTo(Transaction o) &#123; if (this.price &gt; o.price) &#123; return 1; &#125; if (this.price == o.price) &#123; return 0; &#125; return -1; &#125; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); List&lt;Transaction&gt; list = new ArrayList&lt;&gt;(); while (scan.hasNextLine()) &#123; String line = scan.nextLine(); String[] sArr = line.split(" "); Transaction t = new Transaction(); // 若为撤销 if ("cancel".equals(sArr[0])) &#123; t.type = 2; t.cancel = true; list.add(t); // 撤销第index行的交易记录 int index = Integer.parseInt(sArr[1]); list.get(index - 1).cancel = true; continue; &#125; // 若为买单 if ("buy".equals(sArr[0])) &#123; t.type = 0; &#125; else &#123; // 若为卖单 t.type = 1; &#125; t.price = Float.parseFloat(sArr[1]); t.amount = Long.parseLong(sArr[2]); list.add(t); &#125; scan.close(); // 分割为买单和卖单 List&lt;Transaction&gt; buys = new ArrayList&lt;&gt;(list.size()); List&lt;Transaction&gt; sells = new ArrayList&lt;&gt;(list.size()); for (Transaction t : list) &#123; // 忽略被撤销的交易记录（或者撤销命令本身） if (t.cancel) &#123; continue; &#125; if (t.type == 0) &#123; buys.add(t); &#125; else &#123; sells.add(t); &#125; &#125; // 按照价格从小到大排序 Collections.sort(buys); Collections.sort(sells); long maxAmount = 0L; double price = 0d; for (int i = 0; i &lt; buys.size(); i++) &#123; Transaction t = buys.get(i); long buyAmount = 0L, sellAmount = 0L; for (int j = i; j &lt; buys.size(); j++) &#123; buyAmount += buys.get(j).amount; &#125; for (Transaction t2 : sells) &#123; // 出价最多为t.price if (t2.price &gt; t.price) &#123; break; &#125; sellAmount += t2.amount; &#125; long dealAmount = Math.min(buyAmount, sellAmount); // 选择最大的成交量；若成交量相等，则选择最高的开盘价 if (maxAmount &lt; dealAmount || (maxAmount == dealAmount &amp;&amp; price &lt; t.price)) &#123; maxAmount = dealAmount; price = t.price; &#125; &#125; System.out.printf("%.2f %d\n", price, maxAmount); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201712-3.Crontab]]></title>
    <url>%2F2019%2F09%2F08%2Fccf-csp-20171203%2F</url>
    <content type="text"><![CDATA[样例输入 12343 201711170032 2017112223520 7 * * 1,3-5 get_up30 23 * * Sat,Sun go_to_bed15 12,18 * * * have_dinner 样例输出 201711170700 get_up201711171215 have_dinner201711171815 have_dinner201711181215 have_dinner201711181815 have_dinner201711182330 go_to_bed201711191215 have_dinner201711191815 have_dinner201711192330 go_to_bed201711200700 get_up201711201215 have_dinner201711201815 have_dinner201711211215 have_dinner201711211815 have_dinner201711220700 get_up201711221215 have_dinner201711221815 have_dinner 分析： 解析输入的配置信息，将符号（星号、减号以及逗号）和英文缩写转换为对应的数字。 求解算法如下： 1234567891011遍历从开始时间y1年到结束时间y2年中的所有年份y： 遍历所有符合配置信息的月份m: 遍历所有符合配置信息的日期d（m月的第d天）: 若d超过了y年m月的最大天数: continue 若y年m月d日的星期在day of week中: 遍历所有符合配置信息的小时h: 遍历所有符合配置信息的分钟min: 计算任务调度的时间date 若 s &lt;= date &lt; t: 以date为键，执行的命令cmd为值，存入哈希表中 1.1970年1月1日是星期四。 2.星号只能单独出现，减号和逗号可以配合出现。 3.英文缩写不区分大小写。英文缩写和数值可以混合使用。 4.包含系统运行的开始时间s，但不包含结束时间t，即[s,t)。 5.按照时间先后顺序输出。如果同一时刻有多条命令满足调度条件，则按照输入给出的顺序输出。 因此，哈希表必须是有序的。在C++中，可以使用map；Java中，可以使用TreeMap。 6.&lt;minutes&gt;、&lt;hours&gt;、&lt;day of month&gt;、&lt;month&gt;和&lt;day of week&gt;中的值可能会重复出现，注意去重。 C++版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;regex&gt;using namespace std;const long long HUNDRED_MILLION = 100000000, MILLION = 1000000;int months[2][13] = &#123; &#123; 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &#125;, &#123; 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &#125; &#125;;// 将字符串形式的月份（星期）映射为数字形式map&lt;string, int&gt; monthAndWeekMap = &#123; &#123; "jan", 1 &#125;, &#123; "feb", 2 &#125;, &#123; "mar", 3 &#125;, &#123; "apr", 4 &#125;, &#123; "may", 5 &#125;, &#123; "jun", 6 &#125;, &#123; "jul", 7 &#125;, &#123; "aug", 8 &#125;, &#123; "sep", 9 &#125;, &#123; "oct", 10 &#125;, &#123; "nov", 11 &#125;, &#123; "dec", 12 &#125;, &#123; "sun", 0 &#125;, &#123; "mon", 1 &#125;, &#123; "tue", 2 &#125;, &#123; "wed", 3 &#125;, &#123; "thu", 4 &#125;, &#123; "fri", 5 &#125;, &#123; "sat", 6 &#125; &#125;;// 存储输入的配置信息，0-minutes,1-hours,2-day of month,3-month,4-day of weekset&lt;int&gt; cfg[5];map&lt;long long, vector&lt;string&gt; &gt; dict;// 是否为闰年bool isLeapYear(int year) &#123; return year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0);&#125;// 判断字符串是否为数字bool isDigit(string str) &#123; for (int i = 0; i &lt; str.size(); i++) &#123; if (str[i] &lt; '0' || str[i] &gt; '9') &#123; return false; &#125; &#125; return true;&#125;// 将字符串转换为小写形式string toLowerCase(string str) &#123; for (int i = 0; i &lt; str.size(); i++) &#123; if ('A' &lt;= str[i] &amp;&amp; str[i] &lt;= 'Z') &#123; str[i] += 32; &#125; &#125; return str;&#125;// 计算y年m月d日是星期几，已知1970年1月1日是星期四int dayOfWeek(int y, int m, int d) &#123; int days = 0; for (int i = 1970; i &lt; y; i++) &#123; days += 365; if (isLeapYear(i)) &#123; days += 1; &#125; &#125; bool isLeap = isLeapYear(y); for (int i = 1; i &lt; m; i++) &#123; days += months[isLeap][i]; &#125; days += d; return (days % 7 + 4 - 1) % 7;&#125;// 解析月份和星期，将字符串形式转换为数字形式int parseMonthAndWeek(string str) &#123; if (isDigit(str)) &#123; return stoi(str); &#125; return monthAndWeekMap[toLowerCase(str)];&#125;// 解析输入的配置信息void parseConfig(string crontab[]) &#123; for (int i = 0; i &lt; 5; i++) &#123; // 当前类型的上下界 int low = 0, high = 0; // 清空已有信息 cfg[i].clear(); // 处理星号(星号只能单独出现) if (crontab[i] == "*") &#123; if (i == 0) &#123; // 分钟 high = 59; &#125; else if (i == 1) &#123; // 小时 high = 23; &#125; else if (i == 2) &#123; // 月份中的天数 low = 1; high = 31; &#125; else if (i == 3) &#123; // 月份 low = 1; high = 12; &#125; else &#123; // 星期 high = 6; &#125; for (int j = low; j &lt;= high; j++) &#123; cfg[i].insert(j); &#125; continue; &#125; // 处理-和, string str = crontab[i]; str = regex_replace(str, regex(","), " "); stringstream ss; ss &lt;&lt; str; while (ss &gt;&gt; str) &#123; int index = str.find("-"); // 若不包含- if (index == string::npos) &#123; cfg[i].insert(parseMonthAndWeek(str)); &#125; else &#123; int start = parseMonthAndWeek(str.substr(0, index)); int end = parseMonthAndWeek(str.substr(index + 1)); while (start &lt;= end) &#123; cfg[i].insert(start++); &#125; &#125; &#125; &#125;&#125;int main() &#123; int n; long long s, t; cin &gt;&gt; n &gt;&gt; s &gt;&gt; t; string cmd, crontab[5]; while (n--) &#123; for (int i = 0; i &lt; 5; i++) &#123; cin &gt;&gt; crontab[i]; &#125; cin &gt;&gt; cmd; // 解析配置信息 parseConfig(crontab); // 存储任务调度 for (int y = s / HUNDRED_MILLION; y &lt;= t / HUNDRED_MILLION; y++) &#123; for (int m : cfg[3]) &#123; for (int d : cfg[2]) &#123; // 若d超过了y年m月的最大天数 if (d &gt; months[isLeapYear(y)][m]) &#123; continue; &#125; // 若y年m月d日的星期在day of week中 if (find(cfg[4].begin(), cfg[4].end(), dayOfWeek(y, m, d)) != cfg[4].end()) &#123; for (int h : cfg[1]) &#123; for (int min : cfg[0]) &#123; // 计算任务调度的时间 long long date = (long long)y * HUNDRED_MILLION + m * MILLION + d * 10000 + h * 100 + min; // 包含开始时间，不包含结束时间 if (s &lt;= date &amp;&amp; date &lt; t) &#123; dict[date].push_back(cmd); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; // 输出 for (map&lt;long long, vector&lt;string&gt; &gt;::iterator iter = dict.begin(); iter != dict.end(); iter++) &#123; for (string cmd : iter-&gt;second) &#123; cout &lt;&lt; iter-&gt;first &lt;&lt; ' ' &lt;&lt; cmd &lt;&lt; endl; &#125; &#125; return 0;&#125; Java版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;import java.util.List;import java.util.Map;import java.util.Scanner;import java.util.Set;import java.util.TreeMap;public class Main &#123; // 1亿 public static final long HUNDRED_MILLION = 100000000L; // 1百万 public static final long MILLION = 1000000L; public static final int[][] MONTHS = &#123; &#123; 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &#125;, &#123; 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &#125; &#125;; // 将字符串形式的月份（星期）映射为数字形式 public static Map&lt;String, Integer&gt; monthAndWeekMap = new HashMap&lt;&gt;(); public static Map&lt;Long, List&lt;String&gt;&gt; resultMap = new TreeMap&lt;&gt;(); static &#123; monthAndWeekMap.put("jan", 1); monthAndWeekMap.put("feb", 2); monthAndWeekMap.put("mar", 3); monthAndWeekMap.put("apr", 4); monthAndWeekMap.put("may", 5); monthAndWeekMap.put("jun", 6); monthAndWeekMap.put("jul", 7); monthAndWeekMap.put("aug", 8); monthAndWeekMap.put("sep", 9); monthAndWeekMap.put("oct", 10); monthAndWeekMap.put("nov", 11); monthAndWeekMap.put("dec", 12); monthAndWeekMap.put("sun", 0); monthAndWeekMap.put("mon", 1); monthAndWeekMap.put("tue", 2); monthAndWeekMap.put("wed", 3); monthAndWeekMap.put("thu", 4); monthAndWeekMap.put("fri", 5); monthAndWeekMap.put("sat", 6); &#125; // 一行配置 static class Config &#123; Set&lt;Integer&gt; minutes; Set&lt;Integer&gt; hours; Set&lt;Integer&gt; dayOfMonth; Set&lt;Integer&gt; month; Set&lt;Integer&gt; command; Set&lt;Integer&gt; dayOfWeek; &#125; // 是否为闰年 public static boolean isLeapYear(int year) &#123; return year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0); &#125; // 计算y年m月d日是星期几，已知1970年1月1日是星期四 public static int dayOfWeek(int y, int m, int d) &#123; int days = 0; for (int i = 1970; i &lt; y; i++) &#123; days += 365; if (isLeapYear(i)) &#123; days += 1; &#125; &#125; boolean isLeap = isLeapYear(y); for (int i = 1; i &lt; m; i++) &#123; days += MONTHS[isLeap ? 1 : 0][i]; &#125; days += d; return (days % 7 + 4 - 1) % 7; &#125; // 判断字符串是否为数字 public static boolean isDigit(String str) &#123; for (int i = 0; i &lt; str.length(); i++) &#123; if (str.charAt(i) &lt; '0' || str.charAt(i) &gt; '9') &#123; return false; &#125; &#125; return true; &#125; // 解析月份和星期，将字符串形式转换为数字形式 public static int parseMonthAndWeek(String str) &#123; if (isDigit(str)) &#123; return Integer.parseInt(str); &#125; return monthAndWeekMap.get(str.toLowerCase()); &#125; // 解析输入的配置信息 public static Config parseConfig(String[] crontab) &#123; Config cfg = new Config(); cfg.minutes = parseConfig0(crontab, 0); cfg.hours = parseConfig0(crontab, 1); cfg.dayOfMonth = parseConfig0(crontab, 2); cfg.month = parseConfig0(crontab, 3); cfg.dayOfWeek = parseConfig0(crontab, 4); return cfg; &#125; private static Set&lt;Integer&gt; parseConfig0(String[] crontab, int i) &#123; // 当前类型的上下界 int low = 0, high = 0; Set&lt;Integer&gt; list = new HashSet&lt;&gt;(); // 处理星号(星号只能单独出现) if ("*".equals(crontab[i])) &#123; if (i == 0) &#123; // 分钟 high = 59; &#125; else if (i == 1) &#123; // 小时 high = 23; &#125; else if (i == 2) &#123; // 月份中的天数 low = 1; high = 31; &#125; else if (i == 3) &#123; // 月份 low = 1; high = 12; &#125; else &#123; // 星期 high = 6; &#125; for (int j = low; j &lt;= high; j++) &#123; list.add(j); &#125; return list; &#125; // 处理-和, String[] sArr = crontab[i].split(","); for (int j = 0; j &lt; sArr.length; j++) &#123; int index = sArr[j].indexOf("-"); // 若不包含- if (index == -1) &#123; list.add(parseMonthAndWeek(sArr[j])); &#125; else &#123; int start = parseMonthAndWeek(sArr[j].substring(0, index)); int end = parseMonthAndWeek(sArr[j].substring(index + 1)); while (start &lt;= end) &#123; list.add(start++); &#125; &#125; &#125; return list; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); long s = scan.nextLong(); long t = scan.nextLong(); String[] crontab = new String[5]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; crontab.length; j++) &#123; crontab[j] = scan.next(); &#125; String cmd = scan.next(); // 解析配置信息 Config cfg = parseConfig(crontab); for (int y = (int) (s / HUNDRED_MILLION); y &lt;= t / HUNDRED_MILLION; y++) &#123; for (int m : cfg.month) &#123; for (int d : cfg.dayOfMonth) &#123; // 若d超过了y年m月的最大天数 if (d &gt; MONTHS[isLeapYear(y) ? 1 : 0][m]) &#123; continue; &#125; // 若y年m月d日的星期在day of week中 if (cfg.dayOfWeek.contains(dayOfWeek(y, m, d))) &#123; for (int h : cfg.hours) &#123; for (int min : cfg.minutes) &#123; // 计算任务调度的时间 long date = (long) y * HUNDRED_MILLION + m * MILLION + d * 10000 + h * 100 + min; // 包含开始时间，不包含结束时间 if (s &lt;= date &amp;&amp; date &lt; t) &#123; if (!resultMap.containsKey(date)) &#123; List&lt;String&gt; cmds = new ArrayList&lt;&gt;(); cmds.add(cmd); resultMap.put(date, cmds); &#125; else &#123; resultMap.get(date).add(cmd); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; scan.close(); // 输出 resultMap.forEach((date, cmds) -&gt; &#123; for (String cmd : cmds) &#123; System.out.println(date + " " + cmd); &#125; &#125;); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201903-3.损坏的RAID5]]></title>
    <url>%2F2019%2F09%2F06%2Fccf-csp-20190303%2F</url>
    <content type="text"><![CDATA[分析： 本题的难点在于读懂题目&gt;_&lt;。 定义哈希表disks，用于存储输入的磁盘信息。disks以磁盘的顺序号为键，以该磁盘上存储的数据为值。 阵列中的条带大小为s（单位：块），现存的硬盘数目为l。 1.块、条带、磁盘均从0开始连续编号。 2.块的大小是4个字节，而输入的是16进制数字。1个字节需要用2个16进制数字表示，因此，1个块中的数据需要用8个16进制数字表示。 3.编号为b的块，在阵列中的条带编号band为$$band = \left \lfloor \frac {b}{s} \right \rfloor$$4.编号为band的条带，所在的磁盘编号diskId为$$diskId = band \ \% \ 磁盘数量$$5.“对于有(n+1)块硬盘的RAID5存储，我们利用每块硬盘上编号为k的条带，存储编号为[kn, (k+1)n)的条带（共n个）。”编号为band的条带，在磁盘diskId上的条带编号k为$$k = \frac{band}{n} = \frac{条带编号}{磁盘数量-1}$$6.阵列中编号为b的块，在磁盘diskId上的块号block为$$block = k \times s + b \ \% \ s$$7.如果读操作由于下列情形之一无法进行，则输出一个减号（-）： （1）阵列不完整，且被读取的块所在的硬盘缺失，且该数据无法由现存的硬盘数据推算出来，即 disks不包含diskId &amp;&amp; n - l &gt; 1； （2）指定的块超出阵列总长度，即(block + 1) * 8 &gt; diskId上存储的数据的长度 8.如果disks包含块b所在的磁盘编号diskId，则直接输出块block中存储的数据；否则，需要对其他磁盘上第block块中存储的数据进行异或运算。 9.由于磁盘数量n的最大值为$10^3$，而每块硬盘上的数据长度小于40KB（$40 \times 1024 \times 2 \approx 8 \times 10^4$个字符）。因此，输入的磁盘数据将多达$8 \times 10^4 \times 10^3 = 8 \times 10^7$个字符。因此，在C++中使用scanf或者cin（Java中使用Scanner）读取数据，都将会出现运行超时。 实践发现：在C++中，使用fgets读入磁盘存储的数据；在Java中，使用BufferedReader，能够正确通过所有的测试用例。 C++版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;// 将十六进制字符串转换为十进制整数int toDecimal(string s) &#123; int result = 0; for (int i = 0; i &lt; s.size(); i++) &#123; result *= 16; if ('A' &lt;= s[i] &amp;&amp; s[i] &lt;= 'Z') &#123; result += s[i] - 'A' + 10; &#125; else &#123; result += s[i] - '0'; &#125; &#125; return result;&#125;const int MAX = 40 * 1024 * 2 + 1;char str[MAX];int main() &#123; int n, s, l, m, b; scanf("%d %d %d", &amp;n, &amp;s, &amp;l); map&lt;int, string&gt; disks; int index; string content; for (int i = 0; i &lt; l; i++) &#123; scanf("%d", &amp;index); getchar(); // 最大输入为40kb，如果使用scanf或者cin，会超时 fgets(str, MAX, stdin); content = str; disks[index] = content; &#125; scanf("%d", &amp;m); while (m--) &#123; // 读取的块编号 scanf("%d", &amp;b); // 块b所在的条带编号 int band = b / s; // 块b所在的磁盘编号（编号从0开始） int diskId = band % n; // 条带band，在磁盘diskId上的条带编号（编号从0开始） int k = band / (n - 1); // 块b，在磁盘diskId上的块号（编号从0开始） int block = k * s + b % s; // 1.被读取的块所在的硬盘缺失，且该数据无法由现存的硬盘数据推算出来;指定的块超出阵列总长度。 if ((!disks.count(diskId) &amp;&amp; n - l &gt; 1) || (block + 1) * 8 &gt; disks[diskId].size()) &#123; printf("-\n"); continue; &#125; // 2.磁盘数据完好 if (disks.count(diskId)) &#123; printf("%s\n", disks[diskId].substr(8 * block, 8).c_str()); continue; &#125; // 3.磁盘数据缺失，但可以由现存的磁盘数据推算出来 int result = 0; for (map&lt;int, string&gt;::iterator iter = disks.begin(); iter != disks.end(); iter++) &#123; string str = iter-&gt;second.substr(8 * block, 8); if (iter == disks.begin()) &#123; result = toDecimal(str); &#125; else &#123; result ^= toDecimal(str); &#125; &#125; printf("%08X\n", result); &#125; return 0;&#125; Java版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.HashMap;import java.util.Map;import java.util.Map.Entry;public class Main &#123; public static void main(String[] args) throws IOException &#123; // 读入的字符数量过大，使用Scanner会超时 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] sArr = br.readLine().split(" "); int n = Integer.parseInt(sArr[0]); int s = Integer.parseInt(sArr[1]); int l = Integer.parseInt(sArr[2]); Map&lt;Integer, String&gt; disks = new HashMap&lt;&gt;(); for (int i = 0; i &lt; l; i++) &#123; String[] sArr2 = br.readLine().split(" "); int index = Integer.parseInt(sArr2[0]); String content = sArr2[1]; disks.put(index, content); &#125; int m = Integer.parseInt(br.readLine()); for (int i = 0; i &lt; m; i++) &#123; // 读取的块编号 int b = Integer.parseInt(br.readLine()); // 块b所在的条带编号 int band = b / s; // 块b所在的磁盘编号（编号从0开始） int diskId = band % n; // 条带band，在磁盘diskId上的条带编号（编号从0开始） int k = band / (n - 1); // 块b，在磁盘diskId上的块号（编号从0开始） int block = k * s + b % s; // 1.被读取的块所在的硬盘缺失，且该数据无法由现存的硬盘数据推算出来;指定的块超出阵列总长度。 if ((block + 1) * 8 &gt; disks.get(diskId).length() || (!disks.containsKey(diskId) &amp;&amp; n - l &gt; 1)) &#123; System.out.println('-'); continue; &#125; // 2.磁盘数据完好 if (disks.containsKey(diskId)) &#123; System.out.println(disks.get(diskId).substring(8 * block, 8 * (block + 1))); continue; &#125; // 3.磁盘数据缺失，但可以由现存的磁盘数据推算出来 int result = 0; boolean flag = false; for (Entry&lt;Integer, String&gt; entry : disks.entrySet()) &#123; String str = entry.getValue().substring(8 * block, 8 * (block + 1)); if (!flag) &#123; result = Integer.parseInt(str, 16); flag = true; &#125; else &#123; result ^= Integer.parseInt(str, 16); &#125; &#125; System.out.printf("%08X\n", result); &#125; br.close(); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201812-3.CIDR合并]]></title>
    <url>%2F2019%2F09%2F03%2Fccf-csp-20181203%2F</url>
    <content type="text"><![CDATA[样例输入 212 样例输出 1.0.0.0/82.0.0.0/8 样例输入 210/910.128/9 样例输出 10.0.0.0/8 样例输入 20/1128/1 样例输出 0.0.0.0/0 分析： 按照题目给定的算法求解即可。 1.定义一个类型表示IP前缀： 123456789101112typedef struct Node &#123; // 表示ip地址的32位无符号整数 string ip; // ip地址的点分十进制表示 int data[4]; // 前缀长度 int len; Node() &#123; this-&gt;ip = ""; this-&gt;len = 0; &#125;&#125; IP; 2.在第二步：从小到大合并中，如何判断b的匹配集是否为a的匹配集的子集？ 根据匹配的定义可知，前缀长度越大，该IP前缀匹配的IP地址越少。 因此，若a的前缀长度大于b的前缀长度，则b的匹配集不可能是a的匹配集的子集。 如果a.len &lt;= b.len，则判断它们IP地址的前a.len位是否相同。若有一位不同，则b的匹配集不是a的匹配集的子集。 123456789101112// 判断b是否为a的子集bool isSubset(IP a, IP b) &#123; if (a.len &gt; b.len) &#123; return false; &#125; for (int i = 0; i &lt; a.len; i++) &#123; if (b.ip[i] != a.ip[i]) &#123; return false; &#125; &#125; return true;&#125; 3.在第三步：同级合并中，如何判断$a^{’}​$是否合法，以及a的匹配集与b的匹配集的并集是否等于$a^{’}​$的匹配集？ （1）判断$a^{’}$是否合法：根据IP前缀的定义，前缀长度 $len \in [0,32]$，且ip的低(32-len)二进制位为0。 （2）判断a的匹配集与b的匹配集的并集是否等于$a^{’}​$的匹配集： 若a和b的ip地址前a.len-1位均相同，且a.len位不相同，则a的匹配集与b的匹配集的并集等于$a^{’}$的匹配集。 1234567891011121314151617// 判断是否能进行同级合并bool canMerge(IP a, IP b) &#123; if (a.len != b.len) &#123; return false; &#125; a.len -= 1; // 若不合法 if (a.len &lt; 0 || a.ip[a.len] != '0') &#123; return false; &#125; for (int i = 0; i &lt; a.len; i++) &#123; if (a.ip[i] != b.ip[i]) &#123; return false; &#125; &#125; return a.ip[a.len] != b.ip[a.len];&#125; C++版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;string&gt;using namespace std;typedef struct Node &#123; // 表示ip地址的32位无符号整数 string ip; // ip地址的点分十进制表示 int data[4]; // 前缀长度 int len; Node() &#123; this-&gt;ip = ""; this-&gt;len = 0; &#125;&#125; IP;// 升序排序bool cmp(IP a, IP b) &#123; if (a.ip != b.ip) &#123; return a.ip &lt; b.ip; &#125; return a.len &lt; b.len;&#125;// 判断b是否为a的子集bool isSubset(IP a, IP b) &#123; if (a.len &gt; b.len) &#123; return false; &#125; for (int i = 0; i &lt; a.len; i++) &#123; if (b.ip[i] != a.ip[i]) &#123; return false; &#125; &#125; return true;&#125;// 从小到大合并void merge1(list&lt;IP&gt; &amp;ls) &#123; list&lt;IP&gt;::iterator i = ls.begin(), j = ls.begin(); j++; while (j != ls.end()) &#123; if (isSubset(*i, *j)) &#123; j = ls.erase(j); &#125; else &#123; i++; j++; &#125; &#125;&#125;// 判断是否能进行同级合并bool canMerge(IP a, IP b) &#123; if (a.len != b.len) &#123; return false; &#125; a.len -= 1; // 若不合法 if (a.len &lt; 0 || a.ip[a.len] != '0') &#123; return false; &#125; for (int i = 0; i &lt; a.len; i++) &#123; if (a.ip[i] != b.ip[i]) &#123; return false; &#125; &#125; return a.ip[a.len] != b.ip[a.len];&#125;// 同级合并void merge2(list&lt;IP&gt; &amp;ls) &#123; list&lt;IP&gt;::iterator i = ls.begin(), j = ls.begin(); j++; while (j != ls.end()) &#123; if (canMerge(*i, *j)) &#123; i-&gt;len -= 1; j = ls.erase(j); if (i != ls.begin()) &#123; i--; j--; &#125; &#125; else &#123; i++; j++; &#125; &#125;&#125;// 转换为8位二进制数string toBinaryString(int data) &#123; string result = ""; int arr[8] = &#123; 1, 2, 4, 8, 16, 32, 64, 128 &#125;; for (int i = 7; i &gt;= 0; i--) &#123; if (data &gt;= arr[i]) &#123; result += '1'; data -= arr[i]; &#125; else &#123; result += '0'; &#125; &#125; return result;&#125;int main() &#123; int n; cin &gt;&gt; n; list&lt;IP&gt; ls; string line; while (n--) &#123; IP ip; cin &gt;&gt; line; // 统计.的个数 int count = 0; int start = 0, end = 0; // 是否包含/ bool hasSeparator = false; for (int i = 0; i &lt; line.size(); i++) &#123; if (line[i] == '.') &#123; end = i; ip.data[count] = stoi(line.substr(start, end - start)); ip.ip += toBinaryString(ip.data[count]); count++; start = i + 1; &#125; else if (line[i] == '/') &#123; hasSeparator = true; ip.len = stoi(line.substr(i + 1)); ip.data[count] = stoi(line.substr(start, i - start)); ip.ip += toBinaryString(ip.data[count]); &#125; &#125; // 若为省略长度型 if (!hasSeparator) &#123; ip.len = 8 * (count + 1); ip.data[count] = stoi(line.substr(start)); ip.ip += toBinaryString(ip.data[count]); &#125; // 补全省略的后缀 for (int i = 0; i &lt; 3 - count; i++) &#123; ip.data[count + 1 + i] = 0; ip.ip += "00000000"; &#125; ls.push_back(ip); &#125; // 1.排序 ls.sort(cmp); // 2.从小到大合并 merge1(ls); // 3.同级合并 merge2(ls); for (list&lt;IP&gt;::iterator iter = ls.begin(); iter != ls.end(); iter++) &#123; for (int i = 0; i &lt; 4; i++) &#123; if (i &gt; 0) &#123; cout &lt;&lt; '.'; &#125; cout &lt;&lt; iter-&gt;data[i]; &#125; cout &lt;&lt; '/' &lt;&lt; iter-&gt;len &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201703-3.Markdown]]></title>
    <url>%2F2019%2F08%2F25%2Fccf-csp-20170303%2F</url>
    <content type="text"><![CDATA[问题描述 Markdown 是一种很流行的轻量级标记语言（lightweight markup language），广泛用于撰写带格式的文档。例如以下这段文本就是用 Markdown 的语法写成的： 12345678910111213141516# Heading## Sub-headingParagraphs are separatedby a blank line.Text attribute _italic_.Bullet list:* apples* oranges* pearsA [link](http://example.com). ​ 这些用 Markdown 写成的文本，尽管本身是纯文本格式，然而读者可以很容易地看出它的文档结构。同时，还有很多工具可以自动把 Markdown 文本转换成 HTML 甚至 Word、PDF 等格式，取得更好的排版效果。例如上面这段文本通过转化得到的 HTML 代码如下所示： 123456789101112131415161718&lt;h1&gt;Heading&lt;/h1&gt;&lt;h2&gt;Sub-heading&lt;/h2&gt;&lt;p&gt;Paragraphs are separatedby a blank line.&lt;/p&gt;&lt;p&gt;Text attribute &lt;em&gt;italic&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;Bullet list:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;apples&lt;/li&gt;&lt;li&gt;oranges&lt;/li&gt;&lt;li&gt;pears&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;A &lt;a href="http://example.com"&gt;link&lt;/a&gt;.&lt;/p&gt; ​ 本题要求由你来编写一个 Markdown 的转换工具，完成 Markdown 文本到 HTML 代码的转换工作。简化起见，本题定义的 Markdown 语法规则和转换规则描述如下： ●区块：区块是文档的顶级结构。本题的 Markdown 语法有 3 种区块格式。在输入中，相邻两个区块之间用一个或多个空行分隔。输出时删除所有分隔区块的空行。 ○段落：一般情况下，连续多行输入构成一个段落。段落的转换规则是在段落的第一行行首插入 &lt;p&gt;，在最后一行行末插入 &lt;/p&gt;。 ○标题：每个标题区块只有一行，由若干个 # 开头，接着一个或多个空格，然后是标题内容，直到行末。# 的个数决定了标题的等级。转换时，# Heading 转换为 &lt;h1&gt;Heading&lt;/h1&gt;，## Heading 转换为 &lt;h2&gt;Heading&lt;/h2&gt;，以此类推。标题等级最深为 6。 ○无序列表：无序列表由若干行组成，每行由 * 开头，接着一个或多个空格，然后是列表项目的文字，直到行末。转换时，在最开始插入一行 &lt;ul&gt;，最后插入一行 &lt;/ul&gt;；对于每行，* Item 转换为 &lt;li&gt;Item&lt;/li&gt;。本题中的无序列表只有一层，不会出现缩进的情况。 ●行内：对于区块中的内容，有以下两种行内结构。 ○强调：_Text_ 转换为 &lt;em&gt;Text&lt;/em&gt;。强调不会出现嵌套，每行中 _ 的个数一定是偶数，且不会连续相邻。注意 _Text_ 的前后不一定是空格字符。 ○超级链接：[Text](Link) 转换为 &lt;a href=&quot;Link&quot;&gt;Text&lt;/a&gt;。超级链接和强调可以相互嵌套，但每种格式不会超过一层。 输入格式 输入由若干行组成，表示一个用本题规定的 Markdown 语法撰写的文档。 输出格式 输出由若干行组成，表示输入的 Markdown 文档转换成产生的 HTML 代码。 样例输入 123# HelloHello, world! 样例输出 12&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;Hello, world!&lt;/p&gt; 评测用例规模与约定 本题的测试点满足以下条件： ●本题每个测试点的输入数据所包含的行数都不超过100，每行字符的个数（包括行末换行符）都不超过100。 ●除了换行符之外，所有字符都是 ASCII 码 32 至 126 的可打印字符。 ●每行行首和行末都不会出现空格字符。 ●输入数据除了 Markdown 语法所需，内容中不会出现 #、*、_、[、]、(、)、&lt;、&gt;、&amp; 这些字符。 ●所有测试点均符合题目所规定的 Markdown 语法，你的程序不需要考虑语法错误的情况。 每个测试点包含的语法规则如下表所示，其中“√”表示包含，“×”表示不包含。 测试点编号 段落 标题 无序列表 强调 超级链接 1 √ × × × × 2 √ √ × × × 3 √ × √ × × 4 √ × × √ × 5 √ × × × √ 6 √ √ √ × × 7 √ × × √ √ 8 √ √ × √ × 9 √ × √ × √ 10 √ √ √ √ √ 提示 由于本题要将输入数据当做一个文本文件来处理，要逐行读取直到文件结束，C/C++、Java 语言的用户可以参考以下代码片段来读取输入内容。 C++语言 123456789#include &lt;iostream&gt;#include &lt;string&gt;int main() &#123; std::string line; while(std::getline(std::cin, line)) &#123; ... &#125;&#125; C语言 1234567891011#include &lt;stdio.h&gt;#define BUF_SS 101int main(void) &#123; char buf[101]; while(fgets(buf, BUF_SS, stdin)) &#123; /* Processing code here */ &#125; return 0;&#125; Java语言 123456789101112import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String line = null; while (sc.hasNextLine()) &#123; line = sc.nextLine(); ... &#125; &#125;&#125; 分析： 需要注意的地方： 1.在输入中，相邻两个区块之间用一个或多个空行分隔。输出时删除所有分隔区块的空行。 2.每行行首和行末都不会出现空格字符。因此，我们只需要处理标题#和无序列表*后的空格。 3.本题中的无序列表只有一层，不会出现缩进的情况。 4.强调不会出现嵌套，每行中 _ 的个数一定是偶数，且不会连续相邻。 5.超级链接和强调可以相互嵌套，但每种格式不会超过一层。 6.行内结构（超级链接和强调）在标题、无序列表和段落中均可以存在。 C++版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 去掉开头的空格string trim(string str) &#123; int index = 0; while (str[index] == ' ') &#123; index++; &#125; return str.substr(index, str.size() - index);&#125;// 处理强调string parseEm(string str) &#123; while (true) &#123; int start = str.find("_"); if (start == string::npos) &#123; break; &#125; str = str.replace(start, 1, "&lt;em&gt;"); int end = str.find("_"); str = str.replace(end, 1, "&lt;/em&gt;"); &#125; return str;&#125;// 处理超级链接string parseLink(string str) &#123; while (true) &#123; int start = str.find("["); if (start == string::npos) &#123; break; &#125; int end = str.find("](", start + 1); int brace = str.find(")", end + 2); string text = str.substr(start + 1, end - start - 1); string link = str.substr(end + 2, brace - end - 2); str = str.substr(0, start) + "&lt;a href=\"" + link + "\"&gt;" + text + "&lt;/a&gt;" + str.substr(brace + 1, str.size() - brace - 1); &#125; return str;&#125;// 处理行内结构（强调和超级链接）string parseInline(string line) &#123; return parseLink(parseEm(line));&#125;int main() &#123; string line; while (getline(cin, line)) &#123; if (line.empty()) &#123; continue; &#125; // 处理标题 if (line[0] == '#') &#123; // 计算标题的等级 int level = 0; while (level &lt; line.size() &amp;&amp; line[level] == '#') &#123; level++; &#125; // 去掉开头的空格 line = trim(line.substr(level, line.size() - level)); // 生成标题 cout &lt;&lt; "&lt;h" &lt;&lt; level &lt;&lt; "&gt;" &lt;&lt; parseInline(line) &lt;&lt; "&lt;/h" &lt;&lt; level &lt;&lt; "&gt;" &lt;&lt; endl; continue; &#125; // 处理无序列表 if (line[0] == '*') &#123; cout &lt;&lt; "&lt;ul&gt;" &lt;&lt; endl; // 去掉开头的空格 line = trim(line.substr(1, line.size() - 1)); // 生成列表中的项 cout &lt;&lt; "&lt;li&gt;" &lt;&lt; parseInline(line) &lt;&lt; "&lt;/li&gt;" &lt;&lt; endl; while (getline(cin, line) &amp;&amp; !line.empty()) &#123; line = trim(line.substr(1, line.size() - 1)); cout &lt;&lt; "&lt;li&gt;" &lt;&lt; parseInline(line) &lt;&lt; "&lt;/li&gt;" &lt;&lt; endl; &#125; cout &lt;&lt; "&lt;/ul&gt;" &lt;&lt; endl; continue; &#125; // 处理段落 cout &lt;&lt; "&lt;p&gt;" &lt;&lt; parseInline(line); while (getline(cin, line) &amp;&amp; !line.empty()) &#123; cout &lt;&lt; endl; cout &lt;&lt; parseInline(line); &#125; cout &lt;&lt; "&lt;/p&gt;" &lt;&lt; endl; &#125; return 0;&#125; Java版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import java.util.Scanner;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); StringBuilder sb = new StringBuilder(); String line = null; while (scan.hasNextLine()) &#123; line = scan.nextLine(); if (line.isEmpty()) &#123; continue; &#125; // 处理标题 if (line.charAt(0) == '#') &#123; // 计算标题的等级 int level = 0; while (level &lt; line.length() &amp;&amp; line.charAt(level) == '#') &#123; level++; &#125; sb.append(String.format("&lt;h%d&gt;%s&lt;/h%d&gt;\n", level, parseInline(line.substring(level).trim()), level)); continue; &#125; // 处理无序列表 if (line.charAt(0) == '*') &#123; sb.append("&lt;ul&gt;\n"); sb.append("&lt;li&gt;").append(parseInline(line.substring(1).trim())).append("&lt;/li&gt;\n"); while (scan.hasNextLine() &amp;&amp; !(line = scan.nextLine()).isEmpty()) &#123; sb.append("&lt;li&gt;").append(parseInline(line.substring(1).trim())).append("&lt;/li&gt;\n"); &#125; sb.append("&lt;/ul&gt;\n"); continue; &#125; // 处理段落 sb.append("&lt;p&gt;").append(parseInline(line)); while (scan.hasNextLine() &amp;&amp; !(line = scan.nextLine()).isEmpty()) &#123; sb.append('\n').append(parseInline(line)); &#125; sb.append("&lt;/p&gt;\n"); &#125; scan.close(); System.out.println(sb.toString()); &#125; // 处理行内结构（强调和超级链接） public static String parseInline(String line) &#123; return parseLink(parseEm(line)); &#125; // 处理强调 public static String parseEm(String line) &#123; StringBuffer sb = new StringBuffer(); Pattern p = Pattern.compile("_[^_]+_"); Matcher m = p.matcher(line); while (m.find()) &#123; String str = m.group(); m.appendReplacement(sb, "&lt;em&gt;" + str.substring(1, str.length() - 1) + "&lt;/em&gt;"); &#125; m.appendTail(sb); return sb.toString(); &#125; // 处理超级链接 public static String parseLink(String line) &#123; StringBuffer sb = new StringBuffer(); Pattern p = Pattern.compile("\\[[^\\]]+\\]\\([^\\)]+\\)"); Matcher m = p.matcher(line); while (m.find()) &#123; String str = m.group(); int index = str.indexOf(']'); String text = str.substring(1, index); String link = str.substring(index + 2, str.length() - 1); m.appendReplacement(sb, "&lt;a href=\"" + link + "\"&gt;" + text + "&lt;/a&gt;"); &#125; m.appendTail(sb); return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201612-3.权限查询]]></title>
    <url>%2F2019%2F08%2F24%2Fccf-csp-20161203%2F</url>
    <content type="text"><![CDATA[问题描述 授权 (authorization) 是各类业务系统不可缺少的组成部分，系统用户通过授权机制获得系统中各个模块的操作权限。 本题中的授权机制是这样设计的：每位用户具有若干角色，每种角色具有若干权限。例如，用户 david 具有 manager 角色，manager 角色有 crm:2 权限，则用户 david 具有 crm:2 权限，也就是 crm 类权限的第 2 等级的权限。 具体地，用户名和角色名称都是由小写字母组成的字符串，长度不超过 32。权限分为分等级权限和不分等级权限两大类。分等级权限由权限类名和权限等级构成，中间用冒号“:”分隔。其中权限类名也是由小写字母组成的字符串，长度不超过 32。权限等级是一位数字，从 0 到 9，数字越大表示权限等级越高。系统规定如果用户具有某类某一等级的权限，那么他也将自动具有该类更低等级的权限。例如在上面的例子中，除 crm:2 外，用户 david 也具有 crm:1 和 crm:0 权限。不分等级权限在描述权限时只有权限类名，没有权限等级（也没有用于分隔的冒号）。 给出系统中用户、角色和权限的描述信息，你的程序需要回答多个关于用户和权限的查询。查询可分为以下几类： 不分等级权限的查询：如果权限本身是不分等级的，则查询时不指定等级，返回是否具有该权限； 分等级权限的带等级查询：如果权限本身分等级，查询也带等级，则返回是否具有该类的该等级权限； 分等级权限的不带等级查询：如果权限本身分等级，查询不带等级，则返回具有该类权限的等级；如果不具有该类的任何等级权限，则返回“否”。 输入格式 输入第一行是一个正整数 p，表示不同的权限类别的数量。紧接着的 p 行被称为 P 段，每行一个字符串，描述各个权限。对于分等级权限，格式为 &lt;category&gt;:&lt;level&gt;，其中&lt;category&gt; 是权限类名，&lt;level&gt; 是该类权限的最高等级。对于不分等级权限，字符串只包含权限类名。 接下来一行是一个正整数 r，表示不同的角色数量。紧接着的 r 行被称为 R 段，每行描述一种角色，格式为 &lt;role&gt; &lt;s&gt; &lt;privilege 1&gt; &lt;privilege 2&gt; ... &lt;privilege s&gt; 其中 &lt;role&gt; 是角色名称，&lt;s&gt; 表示该角色具有多少种权限。后面 &lt;s&gt; 个字符串描述该角色具有的权限，格式同 P 段。 接下来一行是一个正整数 u，表示用户数量。紧接着的 u 行被称为 U 段，每行描述一个用户，格式为 &lt;user&gt; &lt;t&gt; &lt;role 1&gt; &lt;role 2&gt; ... &lt;role t&gt; 其中 &lt;user&gt; 是用户名，&lt;t&gt; 表示该用户具有多少种角色。后面 &lt;t&gt; 个字符串描述该用户具有的角色。 接下来一行是一个正整数 q，表示权限查询的数量。紧接着的 q 行被称为 Q 段，每行描述一个授权查询，格式为 &lt;user&gt; &lt;privilege&gt;，表示查询用户 &lt;user&gt; 是否具有 &lt;privilege&gt; 权限。如果查询的权限是分等级权限，则查询中的 &lt;privilege&gt; 可指定等级，表示查询该用户是否具有该等级的权限；也可以不指定等级，表示查询该用户具有该权限的等级。对于不分等级权限，只能查询该用户是否具有该权限，查询中不能指定等级。 输出格式 输出共 q 行，每行为 false、true，或者一个数字。false 表示相应的用户不具有相应的权限，true 表示相应的用户具有相应的权限。对于分等级权限的不带等级查询，如果具有权限，则结果是一个数字，表示该用户具有该权限的（最高）等级。如果用户不存在，或者查询的权限没有定义，则应该返回 false。 样例输入 3crm:2git:3game4hr 1 crm:2it 3 crm:1 git:1 gamedev 2 git:3 gameqa 1 git:23alice 1 hrbob 2 it qacharlie 1 dev9alice gamealice crm:2alice git:0bob gitbob poweroffcharlie gamecharlie crmcharlie git:3malice game 样例输出 falsetruefalse2falsetruefalsetruefalse 样例说明 样例输入描述的场景中，各个用户实际的权限如下： 用户 alice 具有 crm:2 权限 用户 bob 具有 crm:1、git:2 和 game 权限 用户 charlie 具有 git:3 和 game 权限 用户 malice 未描述，因此不具有任何权限 评测用例规模与约定 评测用例规模： 1 ≤ p, r, u ≤ 100 1 ≤ q ≤ 10 000 每个用户具有的角色数不超过 10，每种角色具有的权限种类不超过 10 约定： 输入保证合法性，包括： 1) 角色对应的权限列表（R 段）中的权限都是之前（P 段）出现过的，权限可以重复出现，如果带等级的权限重复出现，以等级最高的为准 2) 用户对应的角色列表（U 段）中的角色都是之前（R 段）出现过的，如果多个角色都具有某一分等级权限，以等级最高的为准 3) 查询（Q 段）中的用户名和权限类名不保证在之前（U 段和 P 段）出现过 前 20% 的评测用例只有一种角色 前 50% 的评测用例权限都是不分等级的，查询也都不带等级 分析： 本题较为简单，主要考察哈希表的应用。 权限分为分等级权限和不分等级权限两大类。权限等级是一位数字，从 0 到 9。 为了便于处理，对于不分等级的权限，可以为其等级赋值-1。 需要注意的是： 1.由于输入保证合法性，因此，本题可以不对第2至p+1行的权限做任何处理； 2.如果用户具有某类某一等级的权限，那么他也将自动具有该类更低等级的权限； 3.角色的权限可以重复出现，如果带等级的权限重复出现，以等级最高的为准； 4.用户的多个角色，可能都具有某一分等级权限，应以等级最高的为准。 C++版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;cstdlib&gt;using namespace std;// 按照冒号:分割权限字符串，得到权限等级level。若privilege中不包含等级，则level设为-1int split(string &amp;privilege) &#123; int index = privilege.find(":"); int level = -1; if (index != string::npos) &#123; // stoi是C++11新增的方法，包含在string中 //level = stoi(privilege.substr(index + 1, 1)); level = atoi(privilege.substr(index + 1, 1).c_str()); privilege = privilege.substr(0, index); &#125; return level;&#125;int main() &#123; int p, r, u, q; cin &gt;&gt; p; // 由于输入保证合法性，因此，本题可以不对第2至p+1行的权限做任何处理 //map&lt;string, int&gt; privileges; while (p--) &#123; string name; cin &gt;&gt; name; /*int level = split(privilege); privileges[name] = level;*/ &#125; // 存储所有角色及其具有的所有权限 map&lt;string, map&lt;string, int&gt; &gt; roles; cin &gt;&gt; r; while (r--) &#123; int s; string role; cin &gt;&gt; role &gt;&gt; s; string privilege; // 存储角色role具有的所有权限 map&lt;string, int&gt; privileges2; while (s--) &#123; cin &gt;&gt; privilege; int level = split(privilege); // 权限可以重复出现，如果带等级的权限重复出现，以等级最高的为准 if (!privileges2.count(privilege) || privileges2[privilege] &lt; level) &#123; privileges2[privilege] = level; &#125; &#125; roles[role] = privileges2; &#125; // 存储所有用户及其具有的所有权限 map&lt;string, map&lt;string, int&gt; &gt; dict; cin &gt;&gt; u; while (u--) &#123; int t; string user; cin &gt;&gt; user &gt;&gt; t; while (t--) &#123; string role; cin &gt;&gt; role; for (map&lt;string, int&gt;::iterator iter = roles[role].begin(); iter != roles[role].end(); iter++) &#123; // 若user尚不具有iter-&gt;first该类权限，或者user具有的权限等级低于iter-&gt;second if (!dict[user].count(iter-&gt;first) || dict[user][iter-&gt;first] &lt; iter-&gt;second) &#123; dict[user][iter-&gt;first] = iter-&gt;second; &#125; &#125; &#125; &#125; // 权限查询 cin &gt;&gt; q; while (q--) &#123; string user; string privilege; cin &gt;&gt; user &gt;&gt; privilege; int level = split(privilege); // 如果用户不存在，或者用户不具有该类权限，或者用户该类权限的等级不够 if (!dict.count(user) || !dict[user].count(privilege) || dict[user][privilege] &lt; level) &#123; cout &lt;&lt; "false" &lt;&lt; endl; &#125; else if (dict[user][privilege] != -1 &amp;&amp; level == -1) &#123; // 若为分等级权限的不带等级查询，则输出用户具有该权限的最高等级 cout &lt;&lt; dict[user][privilege] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "true" &lt;&lt; endl; &#125; &#125; return 0;&#125; Java版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Main &#123; static class Privilege &#123; // 权限名 String name; // 权限等级 Integer level; public Privilege(String name, Integer level) &#123; this.name = name; this.level = level; &#125; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int categoryCount = scan.nextInt(); // 由于输入保证合法性，因此，本题可以不对第2至p+1行的权限做任何处理 for (int i = 0; i &lt; categoryCount; i++) &#123; scan.next(); &#125; // 存储所有角色及其具有的所有权限 Map&lt;String, Map&lt;String, Integer&gt;&gt; roles = new HashMap&lt;&gt;(); int roleCount = scan.nextInt(); for (int i = 0; i &lt; roleCount; i++) &#123; String role = scan.next(); // 存储角色role具有的所有权限 Map&lt;String, Integer&gt; privileges = new HashMap&lt;&gt;(); int s = scan.nextInt(); for (int j = 0; j &lt; s; j++) &#123; Privilege p = split(scan.next()); // 权限可以重复出现，如果带等级的权限重复出现，以等级最高的为准 if (!privileges.containsKey(p.name) || privileges.get(p.name) &lt; p.level) &#123; privileges.put(p.name, p.level); &#125; &#125; roles.put(role, privileges); &#125; // 存储所有用户及其具有的所有权限 Map&lt;String, Map&lt;String, Integer&gt;&gt; users = new HashMap&lt;&gt;(); int userCount = scan.nextInt(); for (int i = 0; i &lt; userCount; i++) &#123; String user = scan.next(); // 存储用户user及其具有的所有权限 Map&lt;String, Integer&gt; privileges = new HashMap&lt;&gt;(); int t = scan.nextInt(); for (int j = 0; j &lt; t; j++) &#123; String role = scan.next(); roles.get(role).forEach((privilegeName, level) -&gt; &#123; // 若user尚不具有privilegeName该类权限，或者user具有的权限等级低于level if (!privileges.containsKey(privilegeName) || privileges.get(privilegeName) &lt; level) &#123; privileges.put(privilegeName, level); &#125; &#125;); users.put(user, privileges); &#125; &#125; // 权限查询 StringBuilder sb = new StringBuilder(); int queryCount = scan.nextInt(); for (int i = 0; i &lt; queryCount; i++) &#123; String user = scan.next(); Privilege p = split(scan.next()); // 如果用户不存在，或者用户不具有该类权限，或者用户该类权限的等级不够 Map&lt;String, Integer&gt; privileges = users.get(user); if (privileges == null || !privileges.containsKey(p.name) || privileges.get(p.name) &lt; p.level) &#123; sb.append("false"); &#125; else if (p.level == -1 &amp;&amp; privileges.get(p.name) != -1) &#123; // 若为分等级权限的不带等级查询，则输出用户具有该权限的最高等级 sb.append(privileges.get(p.name)); &#125; else &#123; sb.append("true"); &#125; sb.append('\n'); &#125; scan.close(); System.out.println(sb.toString()); &#125; // 按照冒号:分割权限字符串，得到权限等级level。若权限字符串中不包含等级，则level设为-1 public static Privilege split(String name) &#123; int level = -1; int index = name.indexOf(":"); if (index &gt;= 0) &#123; level = Integer.parseInt(name.substring(index + 1)); name = name.substring(0, index); &#125; return new Privilege(name, level); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201609-3.炉石传说]]></title>
    <url>%2F2019%2F08%2F23%2Fccf-csp-20160903%2F</url>
    <content type="text"><![CDATA[问题描述 《炉石传说：魔兽英雄传》（Hearthstone: Heroes of Warcraft，简称炉石传说）是暴雪娱乐开发的一款集换式卡牌游戏（如下图所示）。游戏在一个战斗棋盘上进行，由两名玩家轮流进行操作，本题所使用的炉石传说游戏的简化规则如下： 玩家会控制一些角色，每个角色有自己的生命值和攻击力。当生命值小于等于 0 时，该角色死亡。角色分为英雄和随从。 玩家各控制一个英雄，游戏开始时，英雄的生命值为 30，攻击力为 0。当英雄死亡时，游戏结束，英雄未死亡的一方获胜。 玩家可在游戏过程中召唤随从。棋盘上每方都有 7 个可用于放置随从的空位，从左到右一字排开，被称为战场。当随从死亡时，它将被从战场上移除。 游戏开始后，两位玩家轮流进行操作，每个玩家的连续一组操作称为一个回合。 每个回合中，当前玩家可进行零个或者多个以下操作：1) 召唤随从：玩家召唤一个随从进入战场，随从具有指定的生命值和攻击力。2) 随从攻击：玩家控制自己的某个随从攻击对手的英雄或者某个随从。3) 结束回合：玩家声明自己的当前回合结束，游戏将进入对手的回合。该操作一定是一个回合的最后一个操作。 当随从攻击时，攻击方和被攻击方会同时对彼此造成等同于自己攻击力的伤害。受到伤害的角色的生命值将会减少，数值等同于受到的伤害。例如，随从 X 的生命值为 HX、攻击力为 AX，随从 Y 的生命值为 HY、攻击力为 AY，如果随从 X 攻击随从 Y，则攻击发生后随从 X 的生命值变为 HX - AY，随从 Y 的生命值变为 HY - AX。攻击发生后，角色的生命值可以为负数。 本题将给出一个游戏的过程，要求编写程序模拟该游戏过程并输出最后的局面。 输入格式 输入第一行是一个整数 n，表示操作的个数。接下来 n 行，每行描述一个操作，格式如下： &lt;action&gt; &lt;arg1&gt; &lt;arg2&gt; ... 其中&lt;action&gt;表示操作类型，是一个字符串，共有 3 种：summon表示召唤随从，attack表示随从攻击，end表示结束回合。这 3 种操作的具体格式如下： summon &lt;position&gt; &lt;attack&gt; &lt;health&gt;：当前玩家在位置&lt;position&gt;召唤一个生命值为&lt;health&gt;、攻击力为&lt;attack&gt;的随从。其中&lt;position&gt;是一个 1 到 7 的整数，表示召唤的随从出现在战场上的位置，原来该位置及右边的随从都将顺次向右移动一位。 attack &lt;attacker&gt; &lt;defender&gt;：当前玩家的角色&lt;attacker&gt;攻击对方的角色 &lt;defender&gt;。&lt;attacker&gt;是 1 到 7 的整数，表示发起攻击的本方随从编号，&lt;defender&gt;是 0 到 7 的整数，表示被攻击的对方角色，0 表示攻击对方英雄，1 到 7 表示攻击对方随从的编号。 end：当前玩家结束本回合。注意：随从的编号会随着游戏的进程发生变化，当召唤一个随从时，玩家指定召唤该随从放入战场的位置，此时，原来该位置及右边的所有随从编号都会增加 1。而当一个随从死亡时，它右边的所有随从编号都会减少 1。任意时刻，战场上的随从总是从1开始连续编号。 输出格式 输出共 5 行。 第 1 行包含一个整数，表示这 n 次操作后（以下称为 T 时刻）游戏的胜负结果，1 表示先手玩家获胜，-1 表示后手玩家获胜，0 表示游戏尚未结束，还没有人获胜。 第 2 行包含一个整数，表示 T 时刻先手玩家的英雄的生命值。 第 3 行包含若干个整数，第一个整数 p 表示 T 时刻先手玩家在战场上存活的随从个数，之后 p 个整数，分别表示这些随从在 T 时刻的生命值（按照从左往右的顺序）。 第 4 行和第 5 行与第 2 行和第 3 行类似，只是将玩家从先手玩家换为后手玩家。 样例输入 8summon 1 3 6summon 2 4 2endsummon 1 4 5summon 1 2 1attack 1 2endattack 1 1 样例输出 0301 2301 2 样例说明 按照样例输入从第 2 行开始逐行的解释如下： 1. 先手玩家在位置 1 召唤一个生命值为 6、攻击力为 3 的随从 A，是本方战场上唯一的随从。 2. 先手玩家在位置 2 召唤一个生命值为 2、攻击力为 4 的随从 B，出现在随从 A 的右边。 3. 先手玩家回合结束。 4. 后手玩家在位置 1 召唤一个生命值为 5、攻击力为 4 的随从 C，是本方战场上唯一的随从。 5. 后手玩家在位置 1 召唤一个生命值为 1、攻击力为 2 的随从 D，出现在随从 C 的左边。 6. 随从 D 攻击随从 B，双方均死亡。 7. 后手玩家回合结束。 8. 随从 A 攻击随从 C，双方的生命值都降低至 2。 评测用例规模与约定 操作的个数0 ≤ n ≤ 1000。 随从的初始生命值为 1 到 100 的整数，攻击力为 0 到 100 的整数。 保证所有操作均合法，包括但不限于： 1) 召唤随从的位置一定是合法的，即如果当前本方战场上有 m 个随从，则召唤随从的位置一定在 1 到 m + 1 之间，其中 1 表示战场最左边的位置，m + 1 表示战场最右边的位置。 2) 当本方战场有 7 个随从时，不会再召唤新的随从。 3) 发起攻击和被攻击的角色一定存在，发起攻击的角色攻击力大于 0。 4) 一方英雄如果死亡，就不再会有后续操作。 数据约定： 前 20% 的评测用例召唤随从的位置都是战场的最右边。 前 40% 的评测用例没有 attack 操作。 前 60% 的评测用例不会出现随从死亡的情况。 分析： 定义角色类Role，包含角色的生命值health和攻击力attack。 申明一个长度为2的vector&lt;Role&gt;（Java中使用ArrayList&lt;Role&gt;，下同）型数组player，存储两位玩家控制的所有角色（英雄和随从），vector中的下标表示该角色的编号。 先对player进行初始化操作，将两位玩家的英雄（攻击力为0，生命值为30）存储到所属的vector&lt;Role&gt;中。 1.若当前操作为summon，则将输入的attack和health存储到一个Role中，然后将Role插入到当前玩家vector下标为position的位置。 2.若当前操作为attack，表示当前玩家向对手发起攻击，当前玩家的随从attacker将减少等同于对手角色defender攻击力的生命值，对手的角色defender也将减少等同于attacker攻击力的生命值。 若attacker已死亡，则将其从当前玩家的随从列表中删除；若defender是随从且已死亡，则从对手的随从列表中删除。需要注意的是，attacker一定是随从，但defender可以是英雄。 3.若当前操作为end，表示该回合结束，攻守双方互换。 n 次操作后，如果后手玩家的英雄已死亡，则先手玩家胜；如果先手玩家的英雄已死亡，则后手玩家胜；否则，游戏尚未结束。 任意时刻，战场上的随从总是从1开始连续编号。因此，随从的增加，只有两种情况： 第一，放到某个被其他随从占据的位置上。此时，原来该位置及右边的所有随从编号都会增加 1。 第二，放到当前随从列表的最后面。 不可能出现前面还有空位，跳过这些空位，放到其他位置上的情况。 C++版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef struct Node &#123; int attack, health; Node(int _attack, int _health) &#123; attack = _attack; health = _health; &#125;&#125; Role;int main() &#123; int n; cin &gt;&gt; n; vector&lt;Role&gt; player[2]; player[0].push_back(Role(0, 30)); player[1].push_back(Role(0, 30)); string operation; // 当前玩家 int current = 0; // 对手 int rival = 1; while (n--) &#123; cin &gt;&gt; operation; // 结束该回合，攻守双方互换 if (operation == "end") &#123; swap(current, rival); continue; &#125; // 召唤随从 if (operation == "summon") &#123; int position, attack, health; cin &gt;&gt; position &gt;&gt; attack &gt;&gt; health; player[current].insert(player[current].begin() + position, Role(attack, health)); continue; &#125; // 随从攻击 if (operation == "attack") &#123; int attacker, defender; cin &gt;&gt; attacker &gt;&gt; defender; // 模拟攻击操作 player[current][attacker].health -= player[rival][defender].attack; player[rival][defender].health -= player[current][attacker].attack; // 若attacker已死亡，则从当前玩家的随从列表中删除 if (player[current][attacker].health &lt;= 0) &#123; player[current].erase(player[current].begin() + attacker); &#125; // 若defender是随从且已死亡，则从对手的随从列表中删除 if (player[rival][defender].health &lt;= 0 &amp;&amp; defender != 0) &#123; player[rival].erase(player[rival].begin() + defender); &#125; &#125; &#125; // 判断游戏的胜负结果 if (player[1][0].health &lt;= 0) &#123; cout &lt;&lt; 1 &lt;&lt; endl; &#125; else if (player[0][0].health &lt;= 0) &#123; cout &lt;&lt; -1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; 0 &lt;&lt; endl; &#125; for (int i = 0; i &lt; 2; i++) &#123; // 玩家英雄的生命值 cout &lt;&lt; player[i][0].health &lt;&lt; endl; // 玩家在战场上存活的随从个数、各随从剩余生命值 cout &lt;&lt; player[i].size() - 1; for (int j = 1; j &lt; player[i].size(); j++) &#123; cout &lt;&lt; ' ' &lt;&lt; player[i][j].health; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Java版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Main &#123; static class Role &#123; int attack; int health; public Role(int attack, int health) &#123; this.attack = attack; this.health = health; &#125; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); @SuppressWarnings("unchecked") List&lt;Role&gt;[] players = new ArrayList[2]; for (int i = 0; i &lt; players.length; i++) &#123; players[i] = new ArrayList&lt;&gt;(); players[i].add(new Role(0, 30)); &#125; // 当前玩家 int current = 0; // 对手 int rival = 1; for (int i = 0; i &lt; n; i++) &#123; String operation = scan.next(); // 结束该回合，攻守双方互换 if (operation.equals("end")) &#123; rival = current; current = 1 - current; continue; &#125; // 召唤随从 if (operation.equals("summon")) &#123; int position = scan.nextInt(); players[current].add(position, new Role(scan.nextInt(), scan.nextInt())); continue; &#125; // 随从攻击 if (operation.equals("attack")) &#123; int attacker = scan.nextInt(); int defender = scan.nextInt(); // 模拟攻击操作 players[current].get(attacker).health -= players[rival].get(defender).attack; players[rival].get(defender).health -= players[current].get(attacker).attack; // 若attacker已死亡，则从当前玩家的随从列表中删除 if (players[current].get(attacker).health &lt;= 0) &#123; players[current].remove(attacker); &#125; // 若defender是随从且已死亡，则从对手的随从列表中删除 if (players[rival].get(defender).health &lt;= 0 &amp;&amp; defender != 0) &#123; players[rival].remove(defender); &#125; &#125; &#125; scan.close(); StringBuilder sb = new StringBuilder(); // 判断游戏的胜负结果 if (players[1].get(0).health &lt;= 0) &#123; sb.append(1); &#125; else if (players[0].get(0).health &lt;= 0) &#123; sb.append(-1); &#125; else &#123; sb.append(0); &#125; sb.append('\n'); for (List&lt;Role&gt; player : players) &#123; // 玩家英雄的生命值 sb.append(player.get(0).health).append('\n'); // 玩家在战场上存活的随从个数、各随从剩余生命值 sb.append(player.size() - 1); for (int i = 1; i &lt; player.size(); i++) &#123; sb.append(' ').append(player.get(i).health); &#125; sb.append('\n'); &#125; System.out.println(sb.toString()); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201604-3.路径解析]]></title>
    <url>%2F2019%2F08%2F23%2Fccf-csp-20160403%2F</url>
    <content type="text"><![CDATA[问题描述 在操作系统中，数据通常以文件的形式存储在文件系统中。文件系统一般采用层次化的组织形式，由目录（或者文件夹）和文件构成，形成一棵树的形状。文件有内容，用于存储数据。目录是容器，可包含文件或其他目录。同一个目录下的所有文件和目录的名字各不相同，不同目录下可以有名字相同的文件或目录。 为了指定文件系统中的某个文件，需要用路径来定位。在类 Unix 系统（Linux、Mac OS X、FreeBSD等）中，路径由若干部分构成，每个部分是一个目录或者文件的名字，相邻两个部分之间用 / 符号分隔。 有一个特殊的目录被称为根目录，是整个文件系统形成的这棵树的根节点，用一个单独的 / 符号表示。在操作系统中，有当前目录的概念，表示用户目前正在工作的目录。根据出发点可以把路径分为两类：  绝对路径：以 / 符号开头，表示从根目录开始构建的路径。  相对路径：不以 / 符号开头，表示从当前目录开始构建的路径。 例如，有一个文件系统的结构如下图所示。在这个文件系统中，有根目录 / 和其他普通目录 d1、d2、d3、d4，以及文件 f1、f2、f3、f1、f4。其中，两个 f1 是同名文件，但在不同的目录下。 对于 d4 目录下的 f1 文件，可以用绝对路径 /d2/d4/f1 来指定。如果当前目录是 /d2/d3，这个文件也可以用相对路径 ../d4/f1 来指定，这里 .. 表示上一级目录（注意，根目录的上一级目录是它本身）。还有 . 表示本目录，例如 /d1/./f1 指定的就是 /d1/f1。注意，如果有多个连续的 / 出现，其效果等同于一个 /，例如 /d1///f1 指定的也是 /d1/f1。 本题会给出一些路径，要求对于每个路径，给出正规化以后的形式。一个路径经过正规化操作后，其指定的文件不变，但是会变成一个不包含 . 和 .. 的绝对路径，且不包含连续多个 / 符号。如果一个路径以 / 结尾，那么它代表的一定是一个目录，正规化操作要去掉结尾的 /。若这个路径代表根目录，则正规化操作的结果是 /。若路径为空字符串，则正规化操作的结果是当前目录。 输入格式 第一行包含一个整数 P，表示需要进行正规化操作的路径个数。 第二行包含一个字符串，表示当前目录。 以下 P 行，每行包含一个字符串，表示需要进行正规化操作的路径。 输出格式 共 P 行，每行一个字符串，表示经过正规化操作后的路径，顺序与输入对应。 样例输入 7/d2/d3/d2/d4/f1../d4/f1/d1/./f1/d1///f1/d1/////d1/../../d2 样例输出 /d2/d4/f1/d2/d4/f1/d1/f1/d1/f1/d1//d2 评测用例规模与约定 1 ≤ P ≤ 10。 文件和目录的名字只包含大小写字母、数字和小数点 .、减号 - 以及下划线 _。 不会有文件或目录的名字是 . 或 .. ，它们具有题目描述中给出的特殊含义。 输入的所有路径每个长度不超过 1000 个字符。 输入的当前目录保证是一个经过正规化操作后的路径。 对于前 30% 的测试用例，需要正规化的路径的组成部分不包含 . 和 .. 。 对于前 60% 的测试用例，需要正规化的路径都是绝对路径。 分析： 定义字符串currentDir，用于表示当前目录。 首先，判断路径dir是否为空字符串。若路径dir为空字符串，则正规化操作的结果就是currentDir。 接着，判断路径dir是否为相对路径。若路径dir属于相对路径，则将currentDir与dir通过路径分隔符/拼接起来，得到的绝对路径赋给dir。 1dir = currentDir + '/' + dir 然后，按照路径分隔符/分割路径dir，分割完以后，遍历分割操作得到字符串数组： 若当前字符串为.，则直接跳过； 若当前字符串为..，且用于存储正规化操作结果的链表list不为空，则删除list的最后一个元素（进入上一级目录）； 否则，将当前字符串加入到list的末尾。 遍历操作结束后，如果list为空，则表示dir经过正规化操作的结果就是根目录/； 否则，将list中的各段路径用路径分隔符/拼接起来，得到的绝对路径即为dir经过正规化操作后的路径。 C++版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;list&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;int main() &#123; int p; string currentDir; cin &gt;&gt; p; getchar(); getline(cin, currentDir); string dir, temp; while (p--) &#123; getline(cin, dir); // 若dir为空字符串，则正规化操作的结果就是当前目录 if (dir.empty()) &#123; cout &lt;&lt; currentDir &lt;&lt; endl; continue; &#125; // 若dir为相对路径，则将currentDir与dir通过路径分隔符/拼接起来 if (dir[0] != '/') &#123; dir = currentDir + '/' + dir; &#125; // 将/替换为空格，便于分割 for (int i = 0; i &lt; dir.size(); i++) &#123; if (dir[i] == '/') &#123; dir[i] = ' '; &#125; &#125; list&lt;string&gt; ls; string str; stringstream ss; ss &lt;&lt; dir; // 处理.和.. while (ss &gt;&gt; str) &#123; if (str == ".") &#123; continue; &#125; if (str == "..") &#123; if (!ls.empty()) &#123; ls.pop_back(); &#125; &#125; else &#123; ls.push_back(str); &#125; &#125; // 若为根目录 if (ls.empty()) &#123; cout &lt;&lt; '/' &lt;&lt; endl; continue; &#125; // 输出目录 while(!ls.empty()) &#123; cout &lt;&lt; '/' &lt;&lt; ls.front(); ls.pop_front(); &#125; /*for (list&lt;string&gt;::iterator iter = ls.begin(); iter != ls.end(); iter++) &#123; cout &lt;&lt; '/' &lt;&lt; (*iter); &#125;*/ cout &lt;&lt; endl; &#125; return 0;&#125; Java版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.LinkedList;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int p = Integer.parseInt(scan.nextLine()); String currentDir = scan.nextLine(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; p; i++) &#123; String dir = scan.nextLine(); // 若dir为空字符串，则正规化操作的结果就是当前目录 if (dir.isEmpty()) &#123; sb.append(currentDir).append('\n'); continue; &#125; // 若dir为相对路径，则将currentDir与dir通过路径分隔符/拼接起来 if (dir.charAt(0) != '/') &#123; dir = currentDir + '/' + dir; &#125; // 处理.和.. LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); for (String str : dir.split("/")) &#123; if (str.equals(".") || str.isEmpty()) &#123; continue; &#125; if (str.equals("..")) &#123; if (!list.isEmpty()) &#123; list.removeLast(); &#125; &#125; else &#123; list.add(str); &#125; &#125; // 若为根目录 if (list.isEmpty()) &#123; sb.append('/'); &#125; else &#123; // 输出目录 for (String str : list) &#123; sb.append('/').append(str); &#125; &#125; sb.append('\n'); &#125; scan.close(); System.out.println(sb.toString()); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201512-3.画图]]></title>
    <url>%2F2019%2F08%2F21%2Fccf-csp-20151203%2F</url>
    <content type="text"><![CDATA[问题描述 用 ASCII 字符来画图是一件有趣的事情，并形成了一门被称为 ASCII Art 的艺术。例如，下图是用 ASCII 字符画出来的 CSPRO 字样。 12345..____.____..____..____...___.../.___/.___||.._.\|.._.\./._.\.|.|...\___.\|.|_).|.|_).|.|.|.||.|___.___).|..__/|.._.&lt;|.|_|.|.\____|____/|_|...|_|.\_\\___/. ​ 本题要求编程实现一个用 ASCII 字符来画图的程序，支持以下两种操作：  画线：给出两个端点的坐标，画一条连接这两个端点的线段。简便起见题目保证要画的每条线段都是水平或者竖直的。水平线段用字符 - 来画，竖直线段用字符 | 来画。如果一条水平线段和一条竖直线段在某个位置相交，则相交位置用字符 + 代替。  填充：给出填充的起始位置坐标和需要填充的字符，从起始位置开始，用该字符填充相邻位置，直到遇到画布边缘或已经画好的线段。注意这里的相邻位置只需要考虑上下左右 4 个方向，如下图所示，字符 @ 只和 4 个字符 * 相邻。 123.*.*@*.*. 输入格式 第1行有三个整数m, n和q。m和n分别表示画布的宽度和高度，以字符为单位。q表示画图操作的个数。 第2行至第q + 1行，每行是以下两种形式之一：  0 x1 y1 x2 y2：表示画线段的操作，(x1, y1)和(x2, y2)分别是线段的两端，满足要么x1 = x2 且y1 ≠ y2，要么 y1 = y2 且 x1 ≠ x2。  1 x y c：表示填充操作，(x, y)是起始位置，保证不会落在任何已有的线段上；c 为填充字符，是大小写字母。 画布的左下角是坐标为 (0, 0) 的位置，向右为x坐标增大的方向，向上为y坐标增大的方向。这q个操作按照数据给出的顺序依次执行。画布最初时所有位置都是字符 .（小数点）。 输出格式 输出有n行，每行m个字符，表示依次执行这q个操作后得到的画图结果。 样例输入 4 2 31 0 0 B0 1 0 2 01 0 0 A 样例输出 12AAAAA--A 样例输入 16 13 90 3 1 12 10 12 1 12 30 12 3 6 30 6 3 6 90 6 9 12 90 12 9 12 110 12 11 3 110 3 11 3 11 4 2 C 样例输出 12345678910111213...................+--------+......|CCCCCCCC|......|CC+-----+......|CC|............|CC|............|CC|............|CC|............|CC|............|CC+-----+......|CCCCCCCC|......+--------+................... 评测用例规模与约定 所有的评测用例满足：2 ≤ m, n ≤ 100，0 ≤ q ≤ 100，0 ≤ x &lt; m（x表示输入数据中所有位置的x坐标），0 ≤ y&lt; n（y表示输入数据中所有位置的y坐标）。 分析： 定义一个nxm的二维char型数组graph，存储宽度为m、高度为n的画布。 题目告诉我们，“画布的左下角是坐标为 (0, 0) 的位置，向右为x坐标增大的方向，向上为y坐标增大的方向”。 然而，graph的第0行第0列在左上角，因此需要对给定的画布坐标进行转换。graph的第i行第j列与画布中的点(x,y)的转换关系如下： 12i = n - 1 - y;j = x; 1.若当前操作为画线段 ——0 x1 y1 x2 y2： (1)当x1 = x2时，表示画一条从(x1,y1)到(x2,y2)的垂直线，用字符|来画。当遇到字符-或者+时，对应位置的字符变为+；否则，变为字符|。 (2)当y1 = y2时，表示画一条从(x1,y1)到(x2,y2)的水平线，用字符-来画。当遇到字符|或者+时，对应位置的字符变为+；否则，变为字符-。 2.若当前操作为填充——1 x y c： 从起始位置(x,y)开始，用字符c填充上下左右 4 个方向的相邻位置，直到遇到画布边缘，或者已经画好的线段，或者该位置已经用字符c填充过了。 填充操作可以采用递归，或者队列来实现。 注意到样例2中0 12 3 6 3，y1 = y2 = 3，而x1 &gt; x2。因此，在画线时，需要比较两个坐标的大小，而不能认为x1 &lt; x2或者y1 &lt; y2一定成立。 C++版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAX = 100;char picture[MAX][MAX];int m, n, q;// 从起始位置(x,y)开始，用字符c填充相邻位置void dfs(int x, int y, int c) &#123; int i = n - 1 - y, j = x; //如果遇到画布边缘，或者已经画好的线段，或者该位置已经填充过了 if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || picture[i][j] == '-' || picture[i][j] == '|' || picture[i][j] == '+' || picture[i][j] == c) &#123; return; &#125; picture[i][j] = c; // 填充相邻位置，上下左右 dfs(x, y + 1, c); dfs(x, y - 1, c); dfs(x - 1, y, c); dfs(x + 1, y, c);&#125;int main() &#123; scanf("%d %d %d", &amp;m, &amp;n, &amp;q); fill(picture[0], picture[0] + MAX * MAX, '.'); int status, x, y; while (q--) &#123; scanf("%d", &amp;status); // 填充 if (status == 1) &#123; char c; scanf("%d %d %c", &amp;x, &amp;y, &amp;c); dfs(x, y, c); continue; &#125; // 画线段 int x2, y2, i, j; scanf("%d %d %d %d", &amp;x, &amp;y, &amp;x2, &amp;y2); // 竖直线段 if (x == x2) &#123; if (y &gt; y2) &#123; swap(y, y2); &#125; for (; y &lt;= y2; y++) &#123; i = n - 1 - y; j = x; if (picture[i][j] == '-' || picture[i][j] == '+') &#123; picture[i][j] = '+'; &#125; else &#123; picture[i][j] = '|'; &#125; &#125; &#125; else &#123; // 水平线段 if (x &gt; x2) &#123; swap(x, x2); &#125; for (; x &lt;= x2; x++) &#123; i = n - 1 - y; j = x; if (picture[i][j] == '|' || picture[i][j] == '+') &#123; picture[i][j] = '+'; &#125; else &#123; picture[i][j] = '-'; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; printf("%c", picture[i][j]); &#125; printf("\n"); &#125; return 0;&#125; Java版 使用递归实现填充操作时，系统报运行错误，得分为90分，可能是出现了栈溢出。 故下面的代码，采用队列实现填充操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int m = scan.nextInt(); int n = scan.nextInt(); int q = scan.nextInt(); char[][] graph = new char[n][m]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; graph[i][j] = '.'; &#125; &#125; for (int k = 0; k &lt; q; k++) &#123; int status = scan.nextInt(); // 填充 if (status == 1) &#123; int x = scan.nextInt(); int y = scan.nextInt(); char c = scan.next().charAt(0); //dfs(graph, x, y, c, m, n); Queue&lt;Point&gt; qu = new LinkedList&lt;&gt;(); qu.add(new Point(x,y)); while(!qu.isEmpty()) &#123; Point p = qu.poll(); x = p.x; y = p.y; int i = n - 1 - y, j = x; // 如果遇到画布边缘，或者已经画好的线段，或者该位置已经填充过了 if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || graph[i][j] == '-' || graph[i][j] == '|' || graph[i][j] == '+' || graph[i][j] == c) &#123; continue; &#125; graph[i][j] = c; qu.add(new Point(p.x,y+1)); qu.add(new Point(x,y-1)); qu.add(new Point(x-1,y)); qu.add(new Point(x+1,y)); &#125; continue; &#125; // 画线段 int x1 = scan.nextInt(); int y1 = scan.nextInt(); int x2 = scan.nextInt(); int y2 = scan.nextInt(); int i, j, temp; // 竖直线段 if (x1 == x2) &#123; if (y1 &gt; y2) &#123; temp = y1; y1 = y2; y2 = temp; &#125; for (; y1 &lt;= y2; y1++) &#123; i = n - 1 - y1; j = x1; if (graph[i][j] == '-' || graph[i][j] == '+') &#123; graph[i][j] = '+'; &#125; else &#123; graph[i][j] = '|'; &#125; &#125; &#125; else &#123; // 水平线段 if (x1 &gt; x2) &#123; temp = x1; x1 = x2; x2 = temp; &#125; for (; x1 &lt;= x2; x1++) &#123; i = n - 1 - y1; j = x1; if (graph[i][j] == '|' || graph[i][j] == '+') &#123; graph[i][j] = '+'; &#125; else &#123; graph[i][j] = '-'; &#125; &#125; &#125; &#125; scan.close(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; sb.append(graph[i][j]); &#125; sb.append('\n'); &#125; System.out.println(sb.toString()); &#125; // 使用递归，得分90，显示运行错误，可能是递归层数过深，导致栈溢出 /*public static void dfs(char[][] graph, int x, int y, char c, int m, int n) &#123; int i = n - 1 - y, j = x; // 如果遇到画布边缘，或者已经画好的线段，或者该位置已经填充过了 if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || graph[i][j] == '-' || graph[i][j] == '|' || graph[i][j] == '+' || graph[i][j] == c) &#123; return; &#125; graph[i][j] = c; // 填充相邻位置，上下左右 dfs(graph, x, y + 1, c, m, n); dfs(graph, x, y - 1, c, m, n); dfs(graph, x - 1, y, c, m, n); dfs(graph, x + 1, y, c, m, n); &#125;*/&#125;class Point &#123; int x,y; public Point(int x, int y) &#123; super(); this.x = x; this.y = y; &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201509-3.模板生成系统]]></title>
    <url>%2F2019%2F08%2F20%2Fccf-csp-20150903%2F</url>
    <content type="text"><![CDATA[问题描述 成成最近在搭建一个网站，其中一些页面的部分内容来自数据库中不同的数据记录，但是页面的基本结构是相同的。例如，对于展示用户信息的页面，当用户为 Tom 时，网页的源代码是 而当用户为 Jerry 时，网页的源代码是 这样的例子在包含动态内容的网站中还有很多。为了简化生成网页的工作，成成觉得他需要引入一套模板生成系统。 模板是包含特殊标记的文本。成成用到的模板只包含一种特殊标记，格式为 {{ VAR }}，其中 VAR 是一个变量。该标记在模板生成时会被变量 VAR 的值所替代。例如，如果变量 name = “Tom”，则 {{ name }} 会生成 Tom。具体的规则如下： ·变量名由大小写字母、数字和下划线 (_) 构成，且第一个字符不是数字，长度不超过 16 个字符。 ·变量名是大小写敏感的，Name 和 name 是两个不同的变量。 ·变量的值是字符串。 ·如果标记中的变量没有定义，则生成空串，相当于把标记从模板中删除。 ·模板不递归生成。也就是说，如果变量的值中包含形如 {{ VAR }} 的内容，不再做进一步的替换。 输入格式 输入的第一行包含两个整数 m, n，分别表示模板的行数和模板生成时给出的变量个数。 接下来 m 行，每行是一个字符串，表示模板。 接下来 n 行，每行表示一个变量和它的值，中间用一个空格分隔。值是字符串，用双引号 (“) 括起来，内容可包含除双引号以外的任意可打印 ASCII 字符（ASCII 码范围 32, 33, 35-126）。 输出格式 输出包含若干行，表示模板生成的结果。 样例输入 123456789101112131411 2&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;User &#123;&#123; name &#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&#123;&#123; name &#125;&#125;&lt;/h1&gt;&lt;p&gt;Email: &lt;a href="mailto:&#123;&#123; email &#125;&#125;"&gt;&#123;&#123; email &#125;&#125;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Address: &#123;&#123; address &#125;&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;name "David Beckham"email "david@beckham.com" 样例输出 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;User David Beckham&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;David Beckham&lt;/h1&gt;&lt;p&gt;Email: &lt;a href="mailto:david@beckham.com"&gt;david@beckham.com&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Address: &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 评测用例规模与约定 0 ≤ m ≤ 100 0 ≤ n ≤ 100 输入的模板每行长度不超过 80 个字符（不包含换行符）。 输入保证模板中所有以{{ 开始的子串都是合法的标记，开始是两个左大括号和一个空格，然后是变量名，结尾是一个空格和两个右大括号。 输入中所有变量的值字符串长度不超过 100 个字符（不包括双引号）。 保证输入的所有变量的名字各不相同。 分析： 本题可以采用正则表达式或者子串查找两种方式求解。这里主要采用子串查找来求解。 C++版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;map&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; int m, n; cin &gt;&gt; m &gt;&gt; n; // 吸收末尾的换行符 getchar(); // 存储模板内容 string tpl; string line; for (int i = 0; i &lt; m; i++) &#123; getline(cin, line); tpl += line + '\n'; &#125; // 使用map存储变量名和变量的值 map&lt;string, string&gt; dict; string key, value, str; while (n--) &#123; getline(cin, str); int index = str.find(' '); key = str.substr(0, index); // 去掉首尾的双引号 dict[key] = str.substr(index + 2, str.size() - (index + 2) - 1); &#125; for (int i = 0; i &lt; tpl.size();) &#123; // 从第i个位置开始，向后寻找子串第一次出现的位置，若未找到该子串，则返回string::npos int start = tpl.find("&#123;&#123; ", i); if (start == string::npos) &#123; break; &#125; int end = tpl.find(" &#125;&#125;", start + 3); if (end == string::npos) &#123; break; &#125; // 获取变量名 key = tpl.substr(start + 3, end - start - 3); // 若变量为定义，则生成空串 value = dict.count(key) ? dict[key] : ""; // 替换模板变量 tpl = tpl.replace(start, end - start + 3, value); // 因为模板不递归生成，故跳过替换后的那段字符串 i = start + value.size(); &#125; cout &lt;&lt; tpl &lt;&lt; endl; return 0;&#125; Java版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.HashMap;import java.util.Map;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 保存输入的数据 String[] sArr = scan.nextLine().split(" "); int m = Integer.parseInt(sArr[0]); int n = Integer.parseInt(sArr[1]); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; m; i++) &#123; sb.append(scan.nextLine()).append("\n"); &#125; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; String line = scan.nextLine(); int index = line.indexOf(' '); String key = line.substring(0, index); // 去掉首尾的双引号 String value = line.substring(index + 2, line.length() - 1); map.put(key, value); &#125; scan.close(); for (int i = 0; i &lt; sb.length();) &#123; // 从第i个位置开始，向后寻找子串第一次出现的位置 int start = sb.indexOf("&#123;&#123; ", i); if (start == -1) &#123; break; &#125; int end = sb.indexOf(" &#125;&#125;", start + 3); if (end == -1) &#123; break; &#125; // 获取变量名 String key = sb.substring(start + 3, end); // 若变量为定义，则生成空串 String value = map.containsKey(key) ? map.get(key) : ""; // 替换模板变量 sb.replace(start, end + 3, value); // 因为模板不递归生成，故跳过替换后的那段字符串 i = start + value.length(); &#125; System.out.println(sb.toString()); /*//正则表达式的解法，得分为90，显示运行错误 // 使用正则表达式替换模板变量 Pattern p = Pattern.compile("\\&#123;\\&#123; \\D\\w&#123;0,15&#125; \\&#125;\\&#125;"); Matcher matcher = p.matcher(sb); StringBuffer sbuff = new StringBuffer(); while (matcher.find()) &#123; String var = matcher.group(); String key = var.substring(3, var.length() - 3); matcher.appendReplacement(sbuff, map.containsKey(key) ? map.get(key) : ""); &#125; matcher.appendTail(sbuff); System.out.println(sbuff.toString());*/ &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201503-3.节日]]></title>
    <url>%2F2019%2F08%2F19%2Fccf-csp-20150303%2F</url>
    <content type="text"><![CDATA[问题描述 有一类节日的日期并不是固定的，而是以“a月的第b个星期c”的形式定下来的，比如说母亲节就定为每年的五月的第二个星期日。 现在，给你a，b，c和y1, y2(1850 ≤ y1, y2 ≤ 2050)，希望你输出从公元y1年到公元y2年间的每年的a月的第b个星期c的日期。 提示：关于闰年的规则：年份是400的整数倍时是闰年，否则年份是4的倍数并且不是100的倍数时是闰年，其他年份都不是闰年。例如1900年就不是闰年，而2000年是闰年。 为了方便你推算，已知1850年1月1日是星期二。 输入格式 输入包含恰好一行，有五个整数a, b, c, y1, y2。其中c=1, 2, ……, 6, 7分别表示星期一、二、……、六、日。 输出格式 对于y1和y2之间的每一个年份，包括y1和y2，按照年份从小到大的顺序输出一行。 如果该年的a月第b个星期c确实存在，则以”yyyy/mm/dd”的格式输出，即输出四位数的年份，两位数的月份，两位数的日期，中间用斜杠“/”分隔，位数不足时前补零。 如果该年的a月第b个星期c并不存在，则输出”none”（不包含双引号)。 样例输入 5 2 7 2014 2015 样例输出 2014/05/112015/05/10 评测用例规模与约定 所有评测用例都满足：1 ≤ a ≤ 12，1 ≤ b ≤ 5，1 ≤ c ≤ 7，1850 ≤ y1, y2 ≤ 2050。 分析： 本题考察日期处理。 需要注意的是，题目要求的是从y1年到y2年，每年的a月第b个星期c的日期，而不是a月第b个星期的星期c的日期。 首先，计算出1850年1月1日到i年a月1日的总天数day； 然后，计算出i年a月1日的星期w = (day % 7 + 2) % 7，当w = 0时，表示星期日，应重新赋值7； 最后，计算出i年a月第b个星期c的日期号d，此时存在以下两种情况（为了便于描述，我们以星期一为一周的第一天）： 1.当c ≥ w时，第b个星期c位于日历表的第b行，d = 7 * (b - 1) - (w - 1) + c； 2.当c &lt; w时，第b个星期c位于日历表的第b + 1行，d = 7 * (b - 1) + 7 - (w - 1) + c。 C++版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;bool isLeap(int y) &#123; return y % 400 == 0 || (y % 4 == 0 &amp;&amp; y % 100 != 0);&#125;int month[2][13] = &#123; &#123; 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &#125;, &#123; 0,31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &#125; &#125;;int main() &#123; int a, b, c, y1, y2; scanf("%d %d %d %d %d", &amp;a, &amp;b, &amp;c, &amp;y1, &amp;y2); int count = 0; // 计算1850年到y1-1年年底有多少天 for (int i = 1850; i &lt; y1; i++) &#123; count += 365; if (isLeap(i)) &#123; count += 1; &#125; &#125; for (int i = y1; i &lt;= y2; i++) &#123; int index = 0; // 计算1850年1月1日到i年a月1日共有多少天 int day = count; count += 365; if (isLeap(i)) &#123; count += 1; index = 1; &#125; for (int m = 1; m &lt; a; m++) &#123; day += month[index][m]; &#125; // w表示i年a月1日是星期几 int w = (day % 7 + 2) % 7; if (w == 0) &#123; w = 7; &#125; // d表示i年a月第b个星期c是几号 // 若c &gt;= w，则第b个星期c位于第b行，d = 7 * (b - 1) - (w - 1) + c； // 若c &lt; w，则第b个星期c位于第b+1行，d = 7 * (b - 1) + 7 - (w - 1) + c。 int d = 7 * (b - 1) - (w - 1) + c; if (c &lt; w) &#123; d += 7; &#125; if (d &gt; month[index][a]) &#123; printf("none\n"); &#125; else &#123; printf("%04d/%02d/%02d\n", i, a, d); &#125; &#125; return 0;&#125; Java版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Scanner;public class Main &#123; public static int[][] MONTH = &#123; &#123; 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &#125;, &#123; 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &#125; &#125;; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int a = scan.nextInt(); int b = scan.nextInt(); int c = scan.nextInt(); int y1 = scan.nextInt(); int y2 = scan.nextInt(); scan.close(); // 计算1850年到y1-1年年底有多少天 int count = 0; for (int i = 1850; i &lt; y1; i++) &#123; count += 365; if (isLeap(i)) &#123; count += 1; &#125; &#125; for (int i = y1; i &lt;= y2; i++) &#123; int index = 0; // 计算1850年1月1日到i年a月1日共有多少天 int day = count; count += 365; if (isLeap(i)) &#123; count += 1; index = 1; &#125; for (int m = 1; m &lt; a; m++) &#123; day += MONTH[index][m]; &#125; // w表示i年a月1日是星期几 int w = (day % 7 + 2) % 7; if (w == 0) &#123; w = 7; &#125; // d表示i年a月第b个星期c是几号 // 若c &gt;= w，则第b个星期c位于第b行，此时，d = 7 * (b - 1) - (w - 1) + c； // 若c &lt; w，则第b个星期c位于第b+1行，此时，d = 7 * (b - 1) + 7 - (w - 1) + c。 int d = 7 * (b - 1) - (w - 1) + c; if (c &lt; w) &#123; d += 7; &#125; if (d &gt; MONTH[index][a]) &#123; System.out.println("none"); &#125; else &#123; System.out.printf("%04d/%02d/%02d\n", i, a, d); &#125; &#125; &#125; public static boolean isLeap(int y) &#123; return y % 400 == 0 || (y % 4 == 0 &amp;&amp; y % 100 != 0); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201312-3.最大的矩形]]></title>
    <url>%2F2019%2F08%2F18%2Fccf-csp-20131203%2F</url>
    <content type="text"><![CDATA[问题描述 在横轴上放了n个相邻的矩形，每个矩形的宽度是1，而第i（1 ≤ i ≤ n）个矩形的高度是hi。这n个矩形构成了一个直方图。例如，下图中六个矩形的高度就分别是3, 1, 6, 5, 2, 3。 请找出能放在给定直方图里面积最大的矩形，它的边要与坐标轴平行。对于上面给出的例子，最大矩形如下图所示的阴影部分，面积是10。 输入格式 第一行包含一个整数n，即矩形的数量(1 ≤ n ≤ 1000)。 第二行包含n 个整数h1, h2, … , hn，相邻的数之间由空格分隔。(1 ≤ hi ≤ 10000)。hi是第i个矩形的高度。 输出格式 输出一行，包含一个整数，即给定直方图内的最大矩形的面积。 样例输入 63 1 6 5 2 3 样例输出 10 分析： 定义一维int型数组h，用于存储所有的矩形高度；int型变量maxArea表示最大矩形的面积； int型变量minHeight，表示从第i个矩形到第j个矩形中的最小高度。 遍历给定的n个矩形：从矩形i出发，向后寻找， 计算从第i个矩形到第j个矩形中，能够容纳的矩形面积area = minHeight * (j - i + 1) 。 若area &gt; maxArea，则令maxArea = area。 C++版 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n; scanf("%d", &amp;n); int h[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;h[i]); &#125; int area, maxArea = 0, minHeight; for (int i = 0; i &lt; n; i++) &#123; minHeight = h[i]; for (int j = i; j &lt; n; j++) &#123; minHeight = min(minHeight, h[j]); area = (j - i + 1) * minHeight; if (area &gt; maxArea) &#123; maxArea = area; &#125; &#125; &#125; printf("%d\n", maxArea); return 0;&#125; Java版 1234567891011121314151617181920212223242526import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int[] h = new int[n]; for (int i = 0; i &lt; h.length; i++) &#123; h[i] = scan.nextInt(); &#125; scan.close(); int area, maxArea = 0, minHeight; for (int i = 0; i &lt; h.length; i++) &#123; minHeight = h[i]; for (int j = i; j &lt; h.length; j++) &#123; minHeight = Math.min(minHeight, h[j]); area = (j - i + 1) * minHeight; if (area &gt; maxArea) &#123; maxArea = area; &#125; &#125; &#125; System.out.println(maxArea); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201403-3.命令行选项]]></title>
    <url>%2F2019%2F08%2F17%2Fccf-csp-20140303%2F</url>
    <content type="text"><![CDATA[问题描述 请你写一个命令行分析程序,用以分析给定的命令行里包含哪些选项。每个命令行由若干个字符串组成,它们之间恰好由一个空格分隔。这些字符串中的第一个为该命令行工具的名字,由小写字母组成,你的程序不用对它进行处理。在工具名字之后可能会包含若干选项,然后可能会包含一 些不是选项的参数。 选项有两类:带参数的选项和不带参数的选项。一个合法的无参数选项的形式是一个减号后面跟单个小写字母,如”-a” 或”-b”。而带参数选项则由两个由空格分隔的字符串构成,前者的格式要求与无参数选项相同,后者则是该选项的参数,是由小写字母,数字和减号组成的非空字符串。 该命令行工具的作者提供给你一个格式字符串以指定他的命令行工具需要接受哪些选项。这个字符串由若干小写字母和冒号组成,其中的每个小写字母表示一个该程序接受的选项。如果该小写字母后面紧跟了一个冒号,它就表示一个带参数的选项,否则则为不带参数的选项。例如, “ab​:m:​” 表示该程序接受三种选项,即”-a”(不带参数),”-b”(带参数), 以及”-m”(带参数)。 命令行工具的作者准备了若干条命令行用以测试你的程序。对于每个命令行,你的工具应当一直向后分析。当你的工具遇到某个字符串既不是合法的选项,又不是某个合法选项的参数时,分析就停止。命令行剩余的未分析部分不构成该命令的选项,因此你的程序应当忽略它们。 输入格式 输入的第一行是一个格式字符串,它至少包含一个字符,且长度不超过 52。格式字符串只包含小写字母和冒号,保证每个小写字母至多出现一次,不会有两个相邻的冒号,也不会以冒号开头。 输入的第二行是一个正整数 N(1 ≤ N ≤ 20),表示你需要处理的命令行的个数。 接下来有 N 行,每行是一个待处理的命令行,它包括不超过 256 个字符。该命令行一定是若干个由单个空格分隔的字符串构成,每个字符串里只包含小写字母,数字和减号。 输出格式 输出有 N 行。其中第 i 行以”Case i:” 开始,然后应当有恰好一个空格,然后应当按照字母升序输出该命令行中用到的所有选项的名称,对于带参数的选项,在输出它的名称之后还要输出它的参数。如果一个选项在命令行中出现了多次,只输出一次。如果一个带参数的选项在命令行中出 现了多次,只输出最后一次出现时所带的参数。 样例输入 albw:x4ls -a -l -a documents -blsls -w 10 -x -w 15ls -a -b -c -d -e -l 样例输出 Case 1: -a -lCase 2:Case 3: -w 15 -xCase 4: -a -b 分析： 定义长度为123的一维数组type（z的ASCII值为122），用于表示命令行选项的类型。 当值为0时，表示选项不属于该命令；当值为1时，表示带参数的选项；当值为2时，表示不带参数的选项。 题目要求按照字母升序输出命令行中用到的所有选项，因此可以使用C++中的map（Java中的TreeMap）存储选项及参数。 处理输入的命令行时，直接跳过命令名，只处理后面的选项。 若当前选项不合法（不是一个减号后面跟单个小写字母），或者不属于该命令，则分析停止； 若为带参数的选项，且存在参数，则将其存储在map中; 若为不带参数的选项，则为其参数赋空字符串&quot;&quot;。 C++中，可以使用stringstream处理命令行中的空格；Java中，直接使用String类的split方法，按照空格分割字符串。 C++版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;int main() &#123; string args, cmd; int n; // 吸收换行符 char c; cin &gt;&gt; args &gt;&gt; n &gt;&gt; c; // 处理给定的命令行选项，0表示不属于该命令，1表示带参数的选项，2表示不带参数的选项 int type[123] = &#123; 0 &#125;; for (int i = 0; i &lt; args.size(); i++) &#123; if (i &lt;= args.size() - 2 &amp;&amp; args[i + 1] == ':') &#123; type[args[i++]] = 1; &#125; else &#123; type[args[i]] = 2; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; map&lt;char, string&gt; dict; stringstream ss; getline(cin, cmd); ss &lt;&lt; cmd; // 跳过命令名 ss &gt;&gt; cmd; while (ss &gt;&gt; cmd) &#123; // 若当前选项不合法，或者不属于该命令，分析停止 if (!(cmd.size() == 2 &amp;&amp; cmd[0] == '-') || type[cmd[1]] == 0) &#123; break; &#125; // 若为带参数选项 if (type[cmd[1]] == 1) &#123; // 若存在参数，则存储到map中；否则，循环结束 if (ss &gt;&gt; args) &#123; dict[cmd[1]] = args; &#125; &#125; else &#123; // 不带参数的选项，赋空字符串 dict[cmd[1]] = ""; &#125; &#125; cout &lt;&lt; "Case " &lt;&lt; i + 1 &lt;&lt; ":"; for (map&lt;char, string&gt;::iterator iter = dict.begin(); iter != dict.end(); iter++) &#123; cout &lt;&lt; " -" &lt;&lt; iter-&gt;first; if (!iter-&gt;second.empty()) &#123; cout &lt;&lt; " " &lt;&lt; iter-&gt;second; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Java版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Map;import java.util.Scanner;import java.util.TreeMap;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); String arguments = scan.nextLine(); int n = Integer.parseInt(scan.nextLine()); // 处理给定的命令行选项，0表示不属于该命令，1表示带参数的选项，2表示不带参数的选项 int[] type = new int[123]; for (int i = 0; i &lt; arguments.length(); i++) &#123; if (i &lt;= arguments.length() - 2 &amp;&amp; arguments.charAt(i + 1) == ':') &#123; type[arguments.charAt(i++)] = 1; &#125; else &#123; type[arguments.charAt(i)] = 2; &#125; &#125; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; n; i++) &#123; Map&lt;Character, String&gt; map = new TreeMap&lt;&gt;(); String[] sArr = scan.nextLine().split(" "); for (int j = 1; j &lt; sArr.length; j++) &#123; char[] cmd = sArr[j].toCharArray(); // 若当前选项不合法，或者不属于该命令，分析停止 if (!(cmd.length == 2 &amp;&amp; cmd[0] == '-') || type[cmd[1]] == 0) &#123; break; &#125; // 若为带参数选项 if (type[cmd[1]] == 1) &#123; // 若存在参数，则存储到map中；否则，循环结束 if (j &lt; sArr.length - 1) &#123; map.put(cmd[1], sArr[++j]); &#125; &#125; else &#123; // 不带参数的选项，赋空字符串 map.put(cmd[1], ""); &#125; &#125; sb.append("Case ").append(i + 1).append(':'); map.forEach((k, v) -&gt; &#123; sb.append(" -").append(k); if (!v.isEmpty()) &#123; sb.append(' ').append(v); &#125; &#125;); sb.append("\n"); &#125; scan.close(); System.out.println(sb.toString()); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201409-3.字符串匹配]]></title>
    <url>%2F2019%2F08%2F16%2Fccf-csp-20140903%2F</url>
    <content type="text"><![CDATA[问题描述 给出一个字符串和多行文字，在这些文字中找到字符串出现的那些行。你的程序还需支持大小写敏感选项：当选项打开时，表示同一个字母的大写和小写看作不同的字符；当选项关闭时，表示同一个字母的大写和小写看作相同的字符。 输入格式 输入的第一行包含一个字符串S，由大小写英文字母组成。 第二行包含一个数字，表示大小写敏感的选项，当数字为0时表示大小写不敏感，当数字为1时表示大小写敏感。 第三行包含一个整数n，表示给出的文字的行数。 接下来n行，每行包含一个字符串，字符串由大小写英文字母组成，不含空格和其他字符。 输出格式 输出多行，每行包含一个字符串，按出现的顺序依次给出那些包含了字符串S的行。 样例输入 Hello15HelloWorldHiHiHelloHiHiGrepIsAGreatToolHELLOHELLOisNOTHello 样例输出 HelloWorldHiHiHelloHiHiHELLOisNOTHello 样例说明 在上面的样例中，第四个字符串虽然也是Hello，但是大小写不正确。如果将输入的第二行改为0，则第四个字符串应该输出。 评测用例规模与约定 1&lt;=n&lt;=100，每个字符串的长度不超过100。 分析： 这是一道简单的字符串模拟题。 当大小写敏感时，本题变为判断字符串是否包含某一子串； 当大小写不敏感时，可以先将字符串和子串都转换为小写（或者大写）形式，接下来的操作，与大小写敏感时一致。 在C/C++中，判断字符串是否包含某一子串，可以使用strstr()或者字符串的find()；在Java中，可以使用字符串的contains()。 C++版 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;// 将source转换为小写字符串resultvoid to_lower_case(char source[], char result[]) &#123; int size = strlen(source); for (int i = 0; i &lt; size; i++) &#123; if ('A' &lt;= source[i] &amp;&amp; source[i] &lt;= 'Z') &#123; result[i] = source[i] + 32; &#125; else &#123; result[i] = source[i]; &#125; &#125; result[size] = '\0';&#125;int main() &#123; char pattern[101], str[101]; scanf("%s", pattern); int ignore, n; scanf("%d %d", &amp;ignore, &amp;n); char * position; char pattern2[101], str2[101]; for (int i = 0; i &lt; n; i++) &#123; scanf("%s", str); if (ignore == 0) &#123; to_lower_case(pattern, pattern2); to_lower_case(str, str2); position = strstr(str2, pattern2); &#125; else &#123; position = strstr(str, pattern); &#125; if (position != NULL) &#123; printf("%s\n", str); &#125; &#125; return 0;&#125; Java版 12345678910111213141516171819202122232425import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; // 1.输入 Scanner scan = new Scanner(System.in); String pattern = scan.nextLine(); boolean ignoreCase = Integer.parseInt(scan.nextLine().trim()) == 0 ? true : false; int line = Integer.parseInt(scan.nextLine().trim()); // 2.处理并输出 StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; line; i++) &#123; String str = scan.nextLine(); if ((ignoreCase &amp;&amp; str.toLowerCase().contains(pattern.toLowerCase())) || (!ignoreCase &amp;&amp; str.contains(pattern))) &#123; sb.append(str).append("\n"); &#125; &#125; scan.close(); System.out.println(sb.toString()); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201509-4.高速公路]]></title>
    <url>%2F2019%2F08%2F15%2Fccf-csp-20150904%2F</url>
    <content type="text"><![CDATA[问题描述 某国有n个城市，为了使得城市间的交通更便利，该国国王打算在城市之间修一些高速公路，由于经费限制，国王打算第一阶段先在部分城市之间修一些单向的高速公路。 现在，大臣们帮国王拟了一个修高速公路的计划。看了计划后，国王发现，有些城市之间可以通过高速公路直接（不经过其他城市）或间接（经过一个或多个其他城市）到达，而有的却不能。如果城市A可以通过高速公路到达城市B，而且城市B也可以通过高速公路到达城市A，则这两个城市被称为便利城市对。 国王想知道，在大臣们给他的计划中，有多少个便利城市对。 输入格式 输入的第一行包含两个整数n, m，分别表示城市和单向高速公路的数量。 接下来m行，每行两个整数a, b，表示城市a有一条单向的高速公路连向城市b。 输出格式 输出一行，包含一个整数，表示便利城市对的数量。 样例输入 5 51 22 33 44 23 5 样例输出 3 样例说明 城市间的连接如图所示。有3个便利城市对，它们分别是(2, 3), (2, 4), (3, 4)，请注意(2, 3)和(3, 2)看成同一个便利城市对。 评测用例规模与约定 前30%的评测用例满足1 ≤ n ≤ 100, 1 ≤ m ≤ 1000； 前60%的评测用例满足1 ≤ n ≤ 1000, 1 ≤ m ≤ 10000； 所有评测用例满足1 ≤ n ≤ 10000, 1 ≤ m ≤ 100000。 分析： 本题考察图的强连通分量。 我们只需要统计出在n个城市组成的图中，有多少个强连通分量，每个强连通分量有多少个城市，然后使用高中数学的组合公式，就能够计算出便利城市对的数量。$$C_n^2 = \frac{n \times (n-1)}{2 \times 1}$$求解有向图中的强连通分量，可以采用tarjan（塔扬）算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int MAX = 10001;int deep = 0, result = 0;int low[MAX], dfn[MAX];bool visited[MAX];stack&lt;int&gt; st;vector&lt;int&gt; graph[MAX];void tarjan(int u) &#123; low[u] = dfn[u] = ++deep; visited[u] = true; st.push(u); for (int i = 0; i &lt; graph[u].size(); i++) &#123; int v = graph[u][i]; // v未访问 if (dfn[v] == 0) &#123; tarjan(v); low[u] = min(low[u], low[v]); &#125; else if (visited[v]) &#123; // v已被访问，且尚在栈中 low[u] = min(low[u], dfn[v]); &#125; &#125; if (dfn[u] == low[u]) &#123; int x, count = 0; do &#123; x = st.top(); st.pop(); count++; visited[x] = false; &#125; while (u != x); result += count * (count - 1) / 2; &#125;&#125;int main() &#123; int n, m, a, b; scanf("%d %d", &amp;n, &amp;m); while (m--) &#123; scanf("%d %d", &amp;a, &amp;b); graph[a].push_back(b); &#125; fill(low, low + n + 1, 0); fill(dfn, dfn + n + 1, 0); fill(visited, visited + n + 1, false); for (int i = 1; i &lt;= n; i++) &#123; if (dfn[i] == 0) &#123; tarjan(i); &#125; &#125; printf("%d\n", result); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201709-4.通信网络]]></title>
    <url>%2F2019%2F08%2F14%2Fccf-csp-20170904%2F</url>
    <content type="text"><![CDATA[问题描述 某国的军队由N个部门组成，为了提高安全性，部门之间建立了M条通路，每条通路只能单向传递信息，即一条从部门a到部门b的通路只能由a向b传递信息。信息可以通过中转的方式进行传递，即如果a能将信息传递到b，b又能将信息传递到c，则a能将信息传递到c。一条信息可能通过多次中转最终到达目的地。 由于保密工作做得很好，并不是所有部门之间都互相知道彼此的存在。只有当两个部门之间可以直接或间接传递信息时，他们才彼此知道对方的存在。部门之间不会把自己知道哪些部门告诉其他部门。 上图中给了一个4个部门的例子，图中的单向边表示通路。部门1可以将消息发送给所有部门，部门4可以接收所有部门的消息，所以部门1和部门4知道所有其他部门的存在。部门2和部门3之间没有任何方式可以发送消息，所以部门2和部门3互相不知道彼此的存在。 现在请问，有多少个部门知道所有N个部门的存在。或者说，有多少个部门所知道的部门数量（包括自己）正好是N。 输入格式 输入的第一行包含两个整数N, M，分别表示部门的数量和单向通路的数量。所有部门从1到N标号。 接下来M行，每行两个整数a, b，表示部门a到部门b有一条单向通路。 输出格式 输出一行，包含一个整数，表示答案。 样例输入 4 41 21 32 43 4 样例输出 2 样例说明 部门1和部门4知道所有其他部门的存在。 评测用例规模与约定 对于30%的评测用例，1 ≤ N ≤ 10，1 ≤ M ≤ 20； 对于60%的评测用例，1 ≤ N ≤ 100，1 ≤ M ≤ 1000； 对于100%的评测用例，1 ≤ N ≤ 1000，1 ≤ M ≤ 10000。 分析： 本题考察图的遍历算法。这里采用深度优先遍历。 设置一个bool型二维数组hasPath，表示任意两个部门之间是否能够传递消息（两个顶点是否相连），初始值均为false，表示不能够传递消息。 以各部门为起点，均进行一次深度优先遍历。遍历的同时，记录下与当前部门current相连的所有部门u，更新对应的hasPath值，即hashPath[current][u] = hasPath[u][current] = true。 最后，遍历数组hashPath，统计与所有部门都相连的部门个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;// 采用邻接表存储图vector&lt;int&gt; graph[1001];// 两个部门是否能传递消息bool hasPath[1001][1001] = &#123; false &#125;;bool visited[1001];// 深度优先遍历，记录与当前部门current相连的所有部门u(包括current自己)void dfs(int u, int current) &#123; visited[u] = true; hasPath[u][current] = hasPath[current][u] = true; for (int i = 0; i &lt; graph[u].size(); i++) &#123; if (!visited[graph[u][i]]) &#123; dfs(graph[u][i], current); &#125; &#125;&#125;int main() &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); int u, v; while (m--) &#123; scanf("%d %d", &amp;u, &amp;v); graph[u].push_back(v); &#125; // 对所有的部门进行深度优先遍历，并更新数组hasPath for (int i = 1; i &lt;= n; i++) &#123; fill(visited, visited + n + 1, false); dfs(i, i); &#125; int count = 0; for (int i = 1; i &lt;= n; i++) &#123; // 若i能和所有的部门传递消息，则count加一 bool flag = true; for (int j = 1; j &lt;= n; j++) &#123; if (!hasPath[i][j]) &#123; flag = false; &#125; &#125; if (flag) &#123; count++; &#125; &#125; printf("%d\n", count); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201609-4.交通规划]]></title>
    <url>%2F2019%2F08%2F09%2Fccf-csp-20160904%2F</url>
    <content type="text"><![CDATA[问题描述 G国国王来中国参观后，被中国的高速铁路深深的震撼，决定为自己的国家也建设一个高速铁路系统。 建设高速铁路投入非常大，为了节约建设成本，G国国王决定不新建铁路，而是将已有的铁路改造成高速铁路。现在，请你为G国国王提供一个方案，将现有的一部分铁路改造成高速铁路，使得任何两个城市间都可以通过高速铁路到达，而且从所有城市乘坐高速铁路到首都的最短路程和原来一样长。请你告诉G国国王在这些条件下最少要改造多长的铁路。 输入格式 输入的第一行包含两个整数n, m，分别表示G国城市的数量和城市间铁路的数量。所有的城市由1到n编号，首都为1号。 接下来m行，每行三个整数a, b, c，表示城市a和城市b之间有一条长度为c的双向铁路。这条铁路不会经过a和b以外的城市。 输出格式 输出一行，表示在满足条件的情况下最少要改造的铁路长度。 样例输入 4 51 2 41 3 52 3 22 4 33 4 2 样例输出 11 评测用例规模与约定 对于20%的评测用例，1 ≤ n ≤ 10，1 ≤ m ≤ 50； 对于50%的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 5000； 对于80%的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 50000； 对于100%的评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000，1 ≤ a, b ≤ n，1 ≤ c ≤ 1000。输入保证每个城市都可以通过铁路达到首都。 分析： 本题考察单源最短路径问题，可以采用dijkstra算法求解。 本题要求的是最少要改造的铁路长度，当出现多条最短路径时，应该选择较短的边。 例如，在样例中，1-3-4和1-2-4均为1和4之间的最短路径，但是2-4的长度为3，而3-4的长度为2，故应选择3-4。 1234567 1———————(4)——————2 | / | | / |(5) --——(2)——- (3) | / | | / | 3———————(2)-—————4 使用数组cost存储点u与其前一个点之间的长度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef struct Node &#123; int v, dist; Node(int _v, int _dist) &#123; v = _v; dist = _dist; &#125;&#125; Edge;const int MAXN = 10001;// 使用邻接表存储的图vector&lt;Edge&gt; graph[MAXN];int cost[MAXN];int n;int d[MAXN];bool visited[MAXN] = &#123; false &#125;;int dijkstra(int s) &#123; fill(d, d + n + 1, INT_MAX); fill(cost, cost + n + 1, INT_MAX); d[s] = 0; cost[s] = 0; // 最少要改造的铁路长度 int result = 0; for (int i = 0; i &lt; n; i++) &#123; int u = -1, min = INT_MAX; for (int j = 1; j &lt;= n; j++) &#123; if (!visited[j] &amp;&amp; d[j] &lt; min) &#123; u = j; min = d[j]; &#125; &#125; result += cost[u]; visited[u] = true; for (int j = 0; j &lt; graph[u].size(); j++) &#123; int v = graph[u][j].v; if (!visited[v] &amp;&amp; d[u] + graph[u][j].dist &lt; d[v]) &#123; d[v] = d[u] + graph[u][j].dist; cost[v] = graph[u][j].dist; &#125; else if (d[u] + graph[u][j].dist == d[v] &amp;&amp; graph[u][j].dist &lt; cost[v]) &#123; // 最短路径相同时，长度较小的边对总长度的影响更小 cost[v] = graph[u][j].dist; &#125; &#125; &#125; return result;&#125;int main() &#123; int m; scanf("%d %d", &amp;n, &amp;m); int u, v, dist; while (m--) &#123; scanf("%d %d %d", &amp;u, &amp;v, &amp;dist); graph[u].push_back(Edge(v, dist)); graph[v].push_back(Edge(u, dist)); &#125; dist = dijkstra(1); printf("%d\n", dist); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201412-4.最优灌溉]]></title>
    <url>%2F2019%2F08%2F06%2Fccf-csp-20141204%2F</url>
    <content type="text"><![CDATA[问题描述 雷雷承包了很多片麦田，为了灌溉这些麦田，雷雷在第一个麦田挖了一口很深的水井，所有的麦田都从这口井来引水灌溉。 为了灌溉，雷雷需要建立一些水渠，以连接水井和麦田，雷雷也可以利用部分麦田作为“中转站”，利用水渠连接不同的麦田，这样只要一片麦田能被灌溉，则与其连接的麦田也能被灌溉。 现在雷雷知道哪些麦田之间可以建设水渠和建设每个水渠所需要的费用（注意不是所有麦田之间都可以建立水渠）。请问灌溉所有麦田最少需要多少费用来修建水渠。 输入格式 输入的第一行包含两个正整数n, m，分别表示麦田的片数和雷雷可以建立的水渠的数量。麦田使用1, 2, 3, ……依次标号。 接下来m行，每行包含三个整数ai, bi, ci，表示第ai片麦田与第bi片麦田之间可以建立一条水渠，所需要的费用为ci。 输出格式 输出一行，包含一个整数，表示灌溉所有麦田所需要的最小费用。 样例输入 4 41 2 12 3 42 4 23 4 3 样例输出 6 样例说明 建立以下三条水渠：麦田1与麦田2、麦田2与麦田4、麦田4与麦田3。 评测用例规模与约定 前20%的评测用例满足：n≤5。 前40%的评测用例满足：n≤20。 前60%的评测用例满足：n≤100。 所有评测用例都满足：1≤n≤1000，1≤m≤100,000，1≤ci≤10,000。 分析： 本题考察最小生成树，题目要求的是最小生成树中的权值之和。可以采用kruskal算法求解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef struct Node &#123; // 边的两个端点 int u, v; // 边的权值(所需的费用) int w;&#125; Edge;Edge edge[100000];// 并查集int usf[1001];bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w;&#125;int find(int x) &#123; int a = x; while (x != usf[x]) &#123; x = usf[x]; &#125; // 路径压缩 while (a != usf[a]) &#123; int z = a; a = usf[a]; usf[z] = x; &#125; return x;&#125;int kruskal(int n, int m) &#123; for (int i = 1; i &lt;= n; i++) &#123; usf[i] = i; &#125; sort(edge, edge + m, cmp); int count = 0, result = 0; for (int i = 0; i &lt; m; i++) &#123; int u = find(edge[i].u); int v = find(edge[i].v); if (u != v) &#123; usf[u] = v; // 最小生成树中的权值之和 result += edge[i].w; count++; &#125; if (count == n - 1) &#123; break; &#125; &#125; return result;&#125;int main() &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; scanf("%d %d %d", &amp;edge[i].u, &amp;edge[i].v, &amp;edge[i].w); &#125; int result = kruskal(n, m); printf("%d\n", result); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201703-4.地铁修建]]></title>
    <url>%2F2019%2F08%2F06%2Fccf-csp-20170304%2F</url>
    <content type="text"><![CDATA[问题描述 A市有n个交通枢纽，其中1号和n号非常重要，为了加强运输能力，A市决定在1号到n号枢纽间修建一条地铁。 地铁由很多段隧道组成，每段隧道连接两个交通枢纽。经过勘探，有m段隧道作为候选，两个交通枢纽之间最多只有一条候选的隧道，没有隧道两端连接着同一个交通枢纽。 现在有n家隧道施工的公司，每段候选的隧道只能由一个公司施工，每家公司施工需要的天数一致。而每家公司最多只能修建一条候选隧道。所有公司同时开始施工。 作为项目负责人，你获得了候选隧道的信息，现在你可以按自己的想法选择一部分隧道进行施工，请问修建整条地铁最少需要多少天。 输入格式 输入的第一行包含两个整数n, m，用一个空格分隔，分别表示交通枢纽的数量和候选隧道的数量。 第2行到第m+1行，每行包含三个整数a, b, c，表示枢纽a和枢纽b之间可以修建一条隧道，需要的时间为c天。 输出格式 输出一个整数，修建整条地铁线路最少需要的天数。 样例输入 6 61 2 42 3 43 6 71 4 24 5 55 6 6 样例输出 6 样例说明 可以修建的线路有两种。 第一种经过的枢纽依次为1, 2, 3, 6，所需要的时间分别是4, 4, 7，则整条地铁线需要7天修完； 第二种经过的枢纽依次为1, 4, 5, 6，所需要的时间分别是2, 5, 6，则整条地铁线需要6天修完。 第二种方案所用的天数更少。 评测用例规模与约定 对于20%的评测用例，1 ≤ n ≤ 10，1 ≤ m ≤ 20； 对于40%的评测用例，1 ≤ n ≤ 100，1 ≤ m ≤ 1000； 对于60%的评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 10000，1 ≤ c ≤ 1000； 对于80%的评测用例，1 ≤ n ≤ 10000，1 ≤ m ≤ 100000； 对于100%的评测用例，1 ≤ n ≤ 100000，1 ≤ m ≤ 200000，1 ≤ a, b ≤ n，1 ≤ c ≤ 1000000。 所有评测用例保证在所有候选隧道都修通时1号枢纽可以通过隧道到达其他所有枢纽。 分析： “所有公司同时开始施工。”因此，本题可认为是求最小生成树中的最大边权。 可以采用kruskal算法求解。当1和n连通时，结束kruskal算法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef struct Node &#123; // 边的两个端点 int u, v; // 需要的时间 int w;&#125; Edge;Edge edge[200000];// 并查集int usf[100001];bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w;&#125;int find(int x) &#123; int a = x; while (x != usf[x]) &#123; x = usf[x]; &#125; // 路径压缩 while (a != usf[a]) &#123; int z = a; a = usf[a]; usf[z] = x; &#125; return x;&#125;int kruskal(int n, int m) &#123; for (int i = 1; i &lt;= n; i++) &#123; usf[i] = i; &#125; sort(edge, edge + m, cmp); int result = 0; for (int i = 0; i &lt; m; i++) &#123; int u = find(edge[i].u); int v = find(edge[i].v); if (u != v) &#123; usf[u] = v; // 最小生成树中的最大边权 result = max(result, edge[i].w); &#125; // 当1和n连通时，结束循环 if (find(1) == find(n)) &#123; break; &#125; &#125; return result;&#125;int main() &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; scanf("%d %d %d", &amp;edge[i].u, &amp;edge[i].v, &amp;edge[i].w); &#125; int result = kruskal(n, m); printf("%d\n", result); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201812-4.数据中心]]></title>
    <url>%2F2019%2F08%2F05%2Fccf-csp-20181204%2F</url>
    <content type="text"><![CDATA[样例输入 4511 2 31 3 41 4 52 3 83 4 2 样例输出 4 样例说明 下图是样例说明。 分析： 本题考察最小生成树，题目要求的是最小生成树中，最大的边权。可以采用kruskal算法求解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef struct Node &#123; int u, v; // 两个端点的编号 int w; //权重&#125; Edge;// 10^5过大，应该在main函数之外定义Edge edge[100000];// 并查集int ufs[500001];int find(int x) &#123; int a = x; while (x != ufs[x]) &#123; x = ufs[x]; &#125; // 路径压缩 while (a != ufs[a]) &#123; int z = a; a = ufs[a]; ufs[z] = x; &#125; return x;&#125;bool cmp(Edge a, Edge b) &#123; return a.w &lt; b.w;&#125;int kruskal(int n, int m) &#123; for (int i = 1; i &lt;= n; i++) &#123; ufs[i] = i; &#125; sort(edge, edge + m, cmp); int count = 0, result = 0; for (int i = 0; i &lt; m; i++) &#123; int u = find(edge[i].u); int v = find(edge[i].v); if (u != v) &#123; // 寻找最小生成树中的最大边权 result = max(result, edge[i].w); ufs[u] = v; count++; &#125; if (count == n - 1) &#123; break; &#125; &#125; return result;&#125;int main() &#123; int n, m, root; scanf("%d %d %d", &amp;n, &amp;m, &amp;root); for (int i = 0; i &lt; m; i++) &#123; scanf("%d %d %d", &amp;edge[i].u, &amp;edge[i].v, &amp;edge[i].w); &#125; int result = kruskal(n, m); printf("%d\n", result);&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201903-4.消息传递接口]]></title>
    <url>%2F2019%2F08%2F05%2Fccf-csp-20190304%2F</url>
    <content type="text"><![CDATA[分析： 1.定义结构体类型Command 123456typedef struct Node &#123; // 0表示发送S,1表示接收R int status; // 目标进程 int target;&#125; Command; 2.处理输入 使用stringstream处理空格，得到各收发指令。每个进程的收发指令，使用queue&lt;Command&gt;存储；每份样例代码，使用vector&lt;queue&lt;Command&gt; &gt; arr存储。 3.执行模拟操作 执行如下循环： 遍历arr，若当前进程arr[i]不为空，此时，如果队首指令cmd的目标进程arr[cmd.target]为空，则循环结束，出现死锁； 否则，判断目标进程队首指令cmd2的状态与cmd的状态是否相符，以及cmd2的目标进程是否为当前进程，即cmd.status + cmd2.status == 1 &amp;&amp; cmd2.target == i， 若上述条件满足，则对当前进程和目标进程执行出队操作，继续遍历当前进程的下一个指令。 当遍历arr，没有出队操作时，循环结束。 此时，若arr中任一进程不为空，则表示出现了死锁；否则，表示程序顺利执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;typedef struct Node &#123; // 0表示发送S,1表示接收R int status; // 目标进程 int target;&#125; Command;int main() &#123; int t, n; cin &gt;&gt; t &gt;&gt; n; getchar(); // 处理某份代码 while (t--) &#123; vector&lt;queue&lt;Command&gt; &gt; arr; string str; // 处理某个进程 for (int i = 0; i &lt; n; i++) &#123; queue&lt;Command&gt; qu; getline(cin, str); stringstream ss; ss &lt;&lt; str; while (ss &gt;&gt; str) &#123; Command cmd; if (str[0] == 'S') &#123; cmd.status = 0; &#125; else &#123; cmd.status = 1; &#125; int num = atoi(str.substr(1, str.size()).c_str()); cmd.target = num; qu.push(cmd); &#125; arr.push_back(qu); &#125; bool flag = true; while (flag) &#123; flag = false; for (int i = 0; i &lt; arr.size(); i++) &#123; if (arr[i].empty()) &#123; continue; &#125; Command cmd = arr[i].front(); if (arr[cmd.target].empty()) &#123; flag = false; break; &#125; Command cmd2 = arr[cmd.target].front(); if (cmd.status + cmd2.status == 1 &amp;&amp; cmd2.target == i) &#123; arr[i].pop(); arr[cmd.target].pop(); i--; flag = true; &#125; &#125; &#125; bool deadLock = false; for (int i = 0; i &lt; arr.size(); i++) &#123; if (!arr[i].empty()) &#123; cout &lt;&lt; 1 &lt;&lt; endl; deadLock = true; break; &#125; &#125; if (!deadLock) &#123; cout &lt;&lt; 0 &lt;&lt; endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201312-2.ISBN号码]]></title>
    <url>%2F2019%2F08%2F01%2Fccf-csp-20131202%2F</url>
    <content type="text"><![CDATA[问题描述 每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括9位数字、1位识别码和3位分隔符，其规定格式如“x-xxx-xxxxx-x”，其中符号“-”是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如0代表英语；第一个分隔符“-”之后的三位数字代表出版社，例如670代表维京出版社；第二个分隔之后的五位数字代表该书在出版社的编号；最后一位为识别码。 识别码的计算方法如下： 首位数字乘以1加上次位数字乘以2……以此类推，用所得的结果mod 11，所得的余数即为识别码，如果余数为10，则识别码为大写字母X。例如ISBN号码0-670-82162-4中的识别码4是这样得到的：对067082162这9个数字，从左至右，分别乘以1，2，…，9，再求和，即0×1+6×2+……+2×9=158，然后取158 mod 11的结果4作为识别码。 编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出“Right”；如果错误，则输出是正确的ISBN号码。 输入格式 输入只有一行，是一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。 输出格式 输出一行，假如输入的ISBN号码的识别码正确，那么输出“Right”，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符“-”）。 样例输入 0-670-82162-4 样例输出 Right 样例输入 0-670-82162-0 样例输出 0-670-82162-4 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; char isbn[14]; scanf("%s", isbn); int len = strlen(isbn); int count = 0, sum = 0; for (int i = 0; i &lt; len - 2; i++) &#123; if ('0' &lt;= isbn[i] &amp;&amp; isbn[i] &lt;= '9') &#123; count++; sum += (isbn[i] - '0') * count; &#125; &#125; int rear = sum % 11; int checkCode = rear == 10 ? 'X' : rear + '0'; // ISBN号码的识别码是否正确 if (isbn[len - 1] == checkCode) &#123; printf("Right\n"); &#125; else &#123; isbn[len - 1] = checkCode; printf("%s\n", isbn); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201403-2.窗口]]></title>
    <url>%2F2019%2F08%2F01%2Fccf-csp-20140302%2F</url>
    <content type="text"><![CDATA[问题描述 在某图形操作系统中,有 N 个窗口,每个窗口都是一个两边与坐标轴分别平行的矩形区域。窗口的边界上的点也属于该窗口。窗口之间有层次的区别,在多于一个窗口重叠的区域里,只会显示位于顶层的窗口里的内容。 当你点击屏幕上一个点的时候,你就选择了处于被点击位置的最顶层窗口,并且这个窗口就会被移到所有窗口的最顶层,而剩余的窗口的层次顺序不变。如果你点击的位置不属于任何窗口,则系统会忽略你这次点击。 现在我们希望你写一个程序模拟点击窗口的过程。 输入格式 输入的第一行有两个正整数,即 N 和 M。(1 ≤ N ≤ 10,1 ≤ M ≤ 10) 接下来 N 行按照从最下层到最顶层的顺序给出 N 个窗口的位置。 每行包含四个非负整数 x1, y1, x2, y2,表示该窗口的一对顶点坐标分别为 (x1, y1) 和 (x2, y2)。保证 x1 &lt; x2, y1 &lt; y2。 接下来 M 行每行包含两个非负整数 x, y,表示一次鼠标点击的坐标。 题目中涉及到的所有点和矩形的顶点的 x, y 坐标分别不超过 2559 和1439。 输出格式 输出包括 M 行,每一行表示一次鼠标点击的结果。如果该次鼠标点击选择了一个窗口,则输出这个窗口的编号(窗口按照输入中的顺序从 1 编号到 N);如果没有,则输出”IGNORED”(不含双引号)。 样例输入 3 40 0 4 41 1 5 52 2 6 61 10 04 40 5 样例输出 211IGNORED 样例说明 第一次点击的位置同时属于第 1 和第 2 个窗口,但是由于第 2 个窗口在上面,它被选择并且被置于顶层。 第二次点击的位置只属于第 1 个窗口,因此该次点击选择了此窗口并将其置于顶层。现在的三个窗口的层次关系与初始状态恰好相反了。 第三次点击的位置同时属于三个窗口的范围,但是由于现在第 1 个窗口处于顶层,它被选择。 最后点击的 (0, 5) 不属于任何窗口。 分析： 本题考察链表的使用。 定义一个结构体（类）Window，包含窗口的起始坐标以及窗口编号。采用头插法，将所有的窗口添加到链表中。 寻找鼠标点击的窗口时，从前往后遍历链表。若鼠标点击的坐标在当前窗口中，则停止遍历。 若存在这样的窗口，输出其编号。与此同时，先将其从链表中删除，再插入到链表的头部，使其成为置顶窗口。 若不存在这样的窗口，则输出IGNORED。 C++版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;list&gt;using namespace std;typedef struct Node &#123; int startX, startY, endX, endY; int num; Node(int _startX, int _startY, int _endX, int _endY, int _num) &#123; startX = _startX; startY = _startY; endX = _endX; endY = _endY; num = _num; &#125;&#125; Window;int main() &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); list&lt;Window&gt; ls; int x1, y1, x2, y2; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d %d %d %d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); ls.push_front(Window(x1, y1, x2, y2, i)); &#125; while (m--) &#123; scanf("%d %d", &amp;x1, &amp;y1); list&lt;Window&gt;::iterator iter = ls.begin(); while (iter != ls.end()) &#123; if (iter-&gt;startX &lt;= x1 &amp;&amp; x1 &lt;= iter-&gt;endX &amp;&amp; iter-&gt;startY &lt;= y1 &amp;&amp; y1 &lt;= iter-&gt;endY) &#123; break; &#125; iter++; &#125; if (iter != ls.end()) &#123; printf("%d\n", iter-&gt;num); Window w = *iter; ls.erase(iter); ls.push_front(w); &#125; else &#123; printf("IGNORED\n"); &#125; &#125; return 0;&#125; Java版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.LinkedList;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int m = scan.nextInt(); LinkedList&lt;Window&gt; list = new LinkedList&lt;&gt;(); for (int i = 1; i &lt;= n; i++) &#123; Window w = new Window(); w.startX = scan.nextInt(); w.startY = scan.nextInt(); w.endX = scan.nextInt(); w.endY = scan.nextInt(); w.num = i; list.addFirst(w); &#125; int x, y; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; m; i++) &#123; x = scan.nextInt(); y = scan.nextInt(); int j = 0; while (j &lt; list.size()) &#123; Window w = list.get(j); if (w.startX &lt;= x &amp;&amp; x &lt;= w.endX &amp;&amp; w.startY &lt;= y &amp;&amp; y &lt;= w.endY) &#123; break; &#125; j++; &#125; if (j &lt; list.size()) &#123; Window w = list.remove(j); list.addFirst(w); sb.append(w.num).append("\n"); &#125; else &#123; sb.append("IGNORED").append("\n"); &#125; &#125; scan.close(); System.out.println(sb.toString()); &#125; static class Window &#123; int startX; int startY; int endX; int endY; int num; &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201409-2.画图]]></title>
    <url>%2F2019%2F08%2F01%2Fccf-csp-20140902%2F</url>
    <content type="text"><![CDATA[问题描述 在一个定义了直角坐标系的纸上，画一个(x1,y1)到(x2,y2)的矩形指将横坐标范围从x1到x2，纵坐标范围从y1到y2之间的区域涂上颜色。 下图给出了一个画了两个矩形的例子。第一个矩形是(1,1) 到(4, 4)，用绿色和紫色表示。第二个矩形是(2, 3)到(6, 5)，用蓝色和紫色表示。图中，一共有15个单位的面积被涂上颜色，其中紫色部分被涂了两次，但在计算面积时只计算一次。在实际的涂色过程中，所有的矩形都涂成统一的颜色，图中显示不同颜色仅为说明方便。 给出所有要画的矩形，请问总共有多少个单位的面积被涂上颜色。 输入格式 输入的第一行包含一个整数n，表示要画的矩形的个数。 接下来n行，每行4个非负整数，分别表示要画的矩形的左下角的横坐标与纵坐标，以及右上角的横坐标与纵坐标。 输出格式 输出一个整数，表示有多少个单位的面积被涂上颜色。 样例输入 21 1 4 42 3 6 5 样例输出 15 评测用例规模与约定 1&lt;=n&lt;=100，0&lt;=横坐标、纵坐标&lt;=100。 分析： 定义一个101x101的数组arr，用于标记某点所在的单位（以左下角点代表该单位）是否被涂色，1表示该点所在的单位被涂色，0表示未被涂色，默认为0。 最后，遍历数组arr，统计其中值为1的元素个数。 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;int main() &#123; int n; scanf("%d", &amp;n); // 标记某点所在的单位（以左下角点代表该单位）是否被涂色， // 1表示该点所在的单位被涂色，默认为0 int arr[101][101] = &#123; 0 &#125;; int x1, y1, x2, y2; while (n--) &#123; scanf("%d %d %d %d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); for (int i = x1; i &lt; x2; i++) &#123; for (int j = y1; j &lt; y2; j++) &#123; arr[i][j] = 1; &#125; &#125; &#125; int count = 0; for (int i = 0; i &lt; 101; i++) &#123; for (int j = 0; j &lt; 101; j++) &#123; count += arr[i][j]; &#125; &#125; printf("%d\n", count); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201412-2.Z字形扫描]]></title>
    <url>%2F2019%2F08%2F01%2Fccf-csp-20141202%2F</url>
    <content type="text"><![CDATA[问题描述 在图像编码的算法中，需要将一个给定的方形矩阵进行Z字形扫描(Zigzag Scan)。给定一个n×n的矩阵，Z字形扫描的过程如下图所示： 对于下面的4×4的矩阵， 1 5 3 9 3 7 5 6 9 4 6 4 7 3 1 3 对其进行Z字形扫描后得到长度为16的序列： 1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3 请实现一个Z字形扫描的程序，给定一个n×n的矩阵，输出对这个矩阵进行Z字形扫描的结果。 输入格式 输入的第一行包含一个整数n，表示矩阵的大小。 输入的第二行到第n+1行每行包含n个正整数，由空格分隔，表示给定的矩阵。 输出格式 输出一行，包含n×n个整数，由空格分隔，表示输入的矩阵经过Z字形扫描后的结果。 样例输入 41 5 3 93 7 5 69 4 6 47 3 1 3 样例输出 1 5 3 9 7 3 9 5 4 7 3 6 6 4 1 3 评测用例规模与约定 1≤n≤500，矩阵元素为不超过1000的正整数。 分析： 在Z字形扫描中，共有4种移动方向：向右、向左下、向下以及向右上。 扫描的第一步向右走，接下来按照如下规则移动： 1.当前向右移动。若碰到下边界，则下一步向右上方走；否则，下一步向左下方走。 2.当前向左下方移动。若碰到下边界，则下一步向右走；若碰到左边界，则下一步向下走；否则，继续向左下方走。 3.当前向下移动。若碰到右边界，则下一步向左下方走；否则，下一步向右上方走。 4.当前向右上方移动。若碰到右边界，则下一步向下走；若碰到上边界，则下一步向右走；否则，继续向右上方移动。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;int main() &#123; int n; scanf("%d", &amp;n); int matrix[n][n]; int result[n * n]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; scanf("%d", &amp;matrix[i][j]); &#125; &#125; // 下一步的移动方向，1:向右,2:左下方,3:向下,4:右上方 int direction = 1; int index = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) &#123; result[index++] = matrix[i][j]; if (direction == 1) &#123; j++; // 若碰到下边界，则向右上方；否则，向左下方 if (i == n - 1) &#123; direction = 4; &#125; else &#123; direction = 2; &#125; &#125; else if (direction == 2) &#123; i++; j--; // 若碰到下边界，则向右行;若碰到左边界,则向下行 if (i == n - 1) &#123; direction = 1; &#125; else if (j == 0) &#123; direction = 3; &#125; &#125; else if (direction == 3) &#123; i++; // 若碰到右边界，则向左下方;否则，向右上方 if (j == n - 1) &#123; direction = 2; &#125; else &#123; direction = 4; &#125; &#125; else &#123; i--; j++; // 若碰到右边界，则向下；若碰到上边界，向右 if (j == n - 1) &#123; direction = 3; &#125; else if (i == 0) &#123; direction = 1; &#125; &#125; &#125; for (int j = 0; j &lt; n * n; j++) &#123; if (j &gt; 0) &#123; printf(" "); &#125; printf("%d", result[j]); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201503-2.数字排序]]></title>
    <url>%2F2019%2F08%2F01%2Fccf-csp-20150302%2F</url>
    <content type="text"><![CDATA[问题描述 给定n个整数，请统计出每个整数出现的次数，按出现次数从多到少的顺序输出。 输入格式 输入的第一行包含一个整数n，表示给定数字的个数。 第二行包含n个整数，相邻的整数之间用一个空格分隔，表示所给定的整数。 输出格式 输出多行，每行包含两个整数，分别表示一个给定的整数和它出现的次数。按出现次数递减的顺序输出。如果两个整数出现的次数一样多，则先输出值较小的，然后输出值较大的。 样例输入 125 2 3 3 1 3 4 2 5 2 3 5 样例输出 3 42 35 31 14 1 评测用例规模与约定 1 ≤ n ≤ 1000，给出的数都是不超过1000的非负整数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef struct Node &#123; int num; int count; Node(int _num, int _count) &#123; num = _num; count = _count; &#125;&#125; Pair;// 按照出现次数从大到小排序，若次数相同，则按照值从小到大的顺序排列bool cmp(Pair a, Pair b) &#123; if (a.count != b.count) &#123; return a.count &gt; b.count; &#125; return a.num &lt; b.num;&#125;int main() &#123; int n, data; scanf("%d", &amp;n); vector&lt;Pair&gt; arr; while (n--) &#123; scanf("%d", &amp;data); // 判断data是否已经存在 bool flag = false; for (int i = 0; i &lt; arr.size(); i++) &#123; // 若data已经在arr中，则增加出现次数 if (arr[i].num == data) &#123; arr[i].count++; flag = true; break; &#125; &#125; // 若data不在arr中 if (!flag) &#123; arr.push_back(Pair(data, 1)); &#125; &#125; // 排序 sort(arr.begin(), arr.end(), cmp); for (int i = 0; i &lt; arr.size(); i++) &#123; printf("%d %d\n", arr[i].num, arr[i].count); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201509-2.日期计算]]></title>
    <url>%2F2019%2F08%2F01%2Fccf-csp-20150902%2F</url>
    <content type="text"><![CDATA[问题描述 给定一个年份y和一个整数d，问这一年的第d天是几月几日？ 注意闰年的2月有29天。满足下面条件之一的是闰年： 1） 年份是4的整数倍，而且不是100的整数倍； 2） 年份是400的整数倍。 输入格式 输入的第一行包含一个整数y，表示年份，年份在1900到2015之间（包含1900和2015）。 输入的第二行包含一个整数d，d在1至365之间。 输出格式 输出两行，每行一个整数，分别表示答案的月份和日期。 样例输入 201580 样例输出 321 样例输入 200040 样例输出 29 12345678910111213141516171819202122#include &lt;cstdio&gt;int main() &#123; int y, d; scanf("%d %d", &amp;y, &amp;d); int months[13] = &#123; 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 &#125;; // 判断是否为闰年，闰年二月有29天 if ((y % 4 == 0 &amp;&amp; y % 100 != 0) || y % 400 == 0) &#123; months[2] += 1; &#125; // 寻找d所在的月份 for (int i = 1; i &lt;= 12; i++) &#123; if (d - months[i] &lt;= 0) &#123; printf("%d\n%d\n", i, d); break; &#125; d -= months[i]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201512-2.消除类游戏]]></title>
    <url>%2F2019%2F08%2F01%2Fccf-csp-20151202%2F</url>
    <content type="text"><![CDATA[问题描述 消除类游戏是深受大众欢迎的一种游戏，游戏在一个包含有n行m列的游戏棋盘上进行，棋盘的每一行每一列的方格上放着一个有颜色的棋子，当一行或一列上有连续三个或更多的相同颜色的棋子时，这些棋子都被消除。当有多处可以被消除时，这些地方的棋子将同时被消除。 现在给你一个n行m列的棋盘，棋盘中的每一个方格上有一个棋子，请给出经过一次消除后的棋盘。 请注意：一个棋子可能在某一行和某一列同时被消除。 输入格式 输入的第一行包含两个整数n, m，用空格分隔，分别表示棋盘的行数和列数。 接下来n行，每行m个整数，用空格分隔，分别表示每一个方格中的棋子的颜色。颜色使用1至9编号。 输出格式 输出n行，每行m个整数，相邻的整数之间使用一个空格分隔，表示经过一次消除后的棋盘。如果一个方格中的棋子被消除，则对应的方格输出0，否则输出棋子的颜色编号。 样例输入 4 52 2 3 1 23 4 5 1 42 3 2 1 32 2 2 4 4 样例输出 2 2 3 0 23 4 5 0 42 3 2 0 30 0 0 4 4 样例说明 棋盘中第4列的1和第4行的2可以被消除，其他的方格中的棋子均保留。 样例输入 4 52 2 3 1 23 1 1 1 12 3 2 1 32 2 3 3 3 样例输出 2 2 3 0 23 0 0 0 02 3 2 0 32 2 0 0 0 样例说明 棋盘中所有的1以及最后一行的3可以被同时消除，其他的方格中的棋子均保留。 评测用例规模与约定 所有的评测用例满足：1 ≤ n, m ≤ 30。 分析： 添加一个nxm的标记数组mark，所有元素的值均初始化为1。 先从行的角度考虑待消除的棋子，再从列的角度考虑待消除的棋子，并将待消除的方格标记为0。 最后，遍历棋盘，若mark[i][j] == 1，则输出原棋盘上的棋子；否则，输出0，表示该棋子已被消除。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;int main() &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); int data[n][m], mark[n][m]; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; scanf("%d", &amp;data[i][j]); mark[i][j] = 1; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m - 2; j++) &#123; if (data[i][j] == data[i][j + 1] &amp;&amp; data[i][j + 1] == data[i][j + 2]) &#123; mark[i][j] = mark[i][j + 1] = mark[i][j + 2] = 0; &#125; &#125; &#125; for (int i = 0; i &lt; n - 2; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (data[i][j] == data[i + 1][j] &amp;&amp; data[i + 1][j] == data[i + 2][j]) &#123; mark[i][j] = mark[i + 1][j] = mark[i + 2][j] = 0; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; if (j &gt; 0) &#123; printf(" "); &#125; if (mark[i][j] == 1) &#123; printf("%d", data[i][j]); &#125; else &#123; printf("0"); &#125; &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201604-2.俄罗斯方块]]></title>
    <url>%2F2019%2F07%2F31%2Fccf-csp-20160402%2F</url>
    <content type="text"><![CDATA[问题描述 俄罗斯方块是俄罗斯人阿列克谢·帕基特诺夫发明的一款休闲游戏。 游戏在一个15行10列的方格图上进行，方格图上的每一个格子可能已经放置了方块，或者没有放置方块。每一轮，都会有一个新的由4个小方块组成的板块从方格图的上方落下，玩家可以操作板块左右移动放到合适的位置，当板块中某一个方块的下边缘与方格图上的方块上边缘重合或者达到下边界时，板块不再移动，如果此时方格图的某一行全放满了方块，则该行被消除并得分。 在这个问题中，你需要写一个程序来模拟板块下落，你不需要处理玩家的操作，也不需要处理消行和得分。 具体的，给定一个初始的方格图，以及一个板块的形状和它下落的初始位置，你要给出最终的方格图。 输入格式 输入的前15行包含初始的方格图，每行包含10个数字，相邻的数字用空格分隔。如果一个数字是0，表示对应的方格中没有方块，如果数字是1，则表示初始的时候有方块。输入保证前4行中的数字都是0。 输入的第16至第19行包含新加入的板块的形状，每行包含4个数字，组成了板块图案，同样0表示没方块，1表示有方块。输入保证板块的图案中正好包含4个方块，且4个方块是连在一起的（准确的说，4个方块是四连通的，即给定的板块是俄罗斯方块的标准板块）。 第20行包含一个1到7之间的整数，表示板块图案最左边开始的时候是在方格图的哪一列中。注意，这里的板块图案指的是16至19行所输入的板块图案，如果板块图案的最左边一列全是0，则它的左边和实际所表示的板块的左边是不一致的（见样例） 输出格式 输出15行，每行10个数字，相邻的数字之间用一个空格分隔，表示板块下落后的方格图。注意，你不需要处理最终的消行。 样例输入 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 1 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 0 01 1 1 0 0 0 1 1 1 10 0 0 0 1 0 0 0 0 00 0 0 00 1 1 10 0 0 10 0 0 03 样例输出 0 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 0 0 00 0 0 0 0 0 0 1 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 0 1 0 0 01 1 1 1 1 1 1 1 1 10 0 0 0 1 1 0 0 0 0 分析： 用15x10的数组matrix表示整个方格图，用4x2的数组square表示板块中4个方块所在的行和列。 执行如下循环： 循环判断板块中第i（0≤i&lt;4）个方块，在matrix中所处位置的下一行是否存在方块， 即matrix[square[i][0] + 1][square[i][1]] == 1，若存在方块，则循环结束，板块停止移动； 若板块中各方块的下一行均没有方块，则板块整体下移一行。 然后，将板块中4个方块，在matrix中所在的格子设置为1，即matrix[square[j][0]][square[j][1]] = 1，其中，0≤j&lt;4。 最后，输出matrix即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556均#include &lt;cstdio&gt;int main() &#123; // matrix存储15x10的方格图，square存储下落的板块中各方块所在的行和列 int matrix[15][10], square[4][2]; int left, data, num = 0; for (int i = 0; i &lt; 15; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; scanf("%d", &amp;matrix[i][j]); &#125; &#125; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 4; j++) &#123; scanf("%d", &amp;data); if (data == 1) &#123; square[num][0] = i; square[num++][1] = j; &#125; &#125; &#125; // 板块图案最左边为第left列，由于下标从0开始，所以实际下标为left-1 scanf("%d", &amp;left); for (int i = 0; i &lt; 4; i++) &#123; square[i][1] += left - 1; &#125; bool flag = true; while (flag) &#123; // 判断板块中各方块下一行是否存在方块 for (int i = 0; i &lt; 4; i++) &#123; if (matrix[square[i][0] + 1][square[i][1]] == 1) &#123; flag = false; break; &#125; &#125; // 若下一行均没有方块，则板块整体下落一行 for (int i = 0; flag &amp;&amp; i &lt; 4; i++) &#123; square[i][0]++; &#125; &#125; // 板块不再移动，将matrix中板块所在的格子，设置为1 for (int j = 0; j &lt; 4; j++) &#123; matrix[square[j][0]][square[j][1]] = 1; &#125; // 输出 for (int i = 0; i &lt; 15; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; if (j &gt; 0) &#123; printf(" "); &#125; printf("%d", matrix[i][j]); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201609-2.火车购票]]></title>
    <url>%2F2019%2F07%2F27%2Fccf-csp-20160902%2F</url>
    <content type="text"><![CDATA[问题描述 请实现一个铁路购票系统的简单座位分配算法，来处理一节车厢的座位分配。 假设一节车厢有20排、每一排5个座位。为方便起见，我们用1到100来给所有的座位编号，第一排是1到5号，第二排是6到10号，依次类推，第20排是96到100号。 购票时，一个人可能购一张或多张票，最多不超过5张。如果这几张票可以安排在同一排编号相邻的座位，则应该安排在编号最小的相邻座位。否则应该安排在编号最小的几个空座位中（不考虑是否相邻）。 假设初始时车票全部未被购买，现在给了一些购票指令，请你处理这些指令。 输入格式 输入的第一行包含一个整数n，表示购票指令的数量。 第二行包含n个整数，每个整数p在1到5之间，表示要购入的票数，相邻的两个数之间使用一个空格分隔。 输出格式 输出n行，每行对应一条指令的处理结果。 对于购票指令p，输出p张车票的编号，按从小到大排序。 样例输入 42 5 4 2 样例输出 1 26 7 8 9 1011 12 13 143 4 样例说明 1) 购2张票，得到座位1、2。 2) 购5张票，得到座位6至10。 3) 购4张票，得到座位11至14。 4) 购2张票，得到座位3、4。 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 100，所有购票数量之和不超过100。 分析： 用int型数组seat表示各排剩下的座位数，下标从0开始。 购票时有以下两种情况： 1.第i排存在p个相邻的空座位。此时，找到空座位的起始编号start =i * 5 + 5 - seat[i] + 1，依次输出p个座位的编号即可； 2.车厢中不存在相邻的p个空座位。此时，从小到大，依次遍历各排，寻找空座位，输出p个座位的编号（若存在p个空座位）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;int main() &#123; int n, p; scanf("%d", &amp;n); // 存储每排剩余的座位数 int seat[20]; for (int i = 0; i &lt; 20; i++) &#123; seat[i] = 5; &#125; while (n--) &#123; scanf("%d", &amp;p); int i = 0; while (i &lt; 20 &amp;&amp; seat[i] &lt; p) &#123; i++; &#125; // 若第i排存在相邻的p个空座位 if (i &lt; 20) &#123; // 起始座位号 int start = i * 5 + 5 - seat[i] + 1; seat[i] -= p; for (int i = 0; i &lt; p; i++) &#123; printf("%d", start + i); if (i &lt; p - 1) &#123; printf(" "); &#125; &#125; &#125; else &#123; // 若不存在相邻的p个空座位，则寻找编号最小的p个座位 for (i = 0; i &lt; 20 &amp;&amp; p &gt; 0; i++) &#123; if (seat[i] == 0) &#123; continue; &#125; // 起始座位号 int start = i * 5 + 5 - seat[i] + 1; int j = 0; while (j &lt; seat[i] &amp;&amp; j &lt; p) &#123; printf("%d", start + j); if (p &gt; 0) &#123; printf(" "); &#125; j++; &#125; p -= j; seat[i] -= j; &#125; &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201612-2.工资计算]]></title>
    <url>%2F2019%2F07%2F27%2Fccf-csp-20161202%2F</url>
    <content type="text"><![CDATA[问题描述 小明的公司每个月给小明发工资，而小明拿到的工资为交完个人所得税之后的工资。假设他一个月的税前工资（扣除五险一金后、未扣税前的工资）为S元，则他应交的个人所得税按如下公式计算： 1） 个人所得税起征点为3500元，若S不超过3500，则不交税，3500元以上的部分才计算个人所得税，令A=S-3500元； 2） A中不超过1500元的部分，税率3%； 3） A中超过1500元未超过4500元的部分，税率10%； 4） A中超过4500元未超过9000元的部分，税率20%； 5） A中超过9000元未超过35000元的部分，税率25%； 6） A中超过35000元未超过55000元的部分，税率30%； 7） A中超过55000元未超过80000元的部分，税率35%； 8） A中超过80000元的部分，税率45%； 例如，如果小明的税前工资为10000元，则A=10000-3500=6500元，其中不超过1500元部分应缴税1500×3%=45元，超过1500元不超过4500元部分应缴税(4500-1500)×10%=300元，超过4500元部分应缴税(6500-4500)×20%=400元。总共缴税745元，税后所得为9255元。 已知小明这个月税后所得为T元，请问他的税前工资S是多少元。 输入格式 输入的第一行包含一个整数T，表示小明的税后所得。所有评测数据保证小明的税前工资为一个整百的数。 输出格式 输出一个整数S，表示小明的税前工资。 样例输入 9255 样例输出 10000 评测用例规模与约定 对于所有评测用例，1 ≤ T ≤ 100000。 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;climits&gt;int main() &#123; // 税后工资 int t; scanf("%d", &amp;t); // 各区间最大收税金额 int range[8] = &#123; 3500, 1500, 3000, 4500, 26000, 20000, 25000, INT_MAX &#125;; // 各区间税率 double rate[8] = &#123; 0, 0.03, 0.1, 0.2, 0.25, 0.3, 0.35, 0.45 &#125;; // 税前工资 int salary = 0; // 最大税后工资 int rear = 0; for (int i = 0; i &lt; 8; i++) &#123; if (i &gt; 0) &#123; salary += range[i - 1]; &#125; int last = rear; rear += range[i] * (1 - rate[i]); // 寻找税后工资所处的区间 if (t &lt;= rear) &#123; salary += (t - last) / (1 - rate[i]); break; &#125; &#125; printf("%d\n", salary); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201703-2.学生排队]]></title>
    <url>%2F2019%2F07%2F26%2Fccf-csp-20170302%2F</url>
    <content type="text"><![CDATA[问题描述 体育老师小明要将自己班上的学生按顺序排队。他首先让学生按学号从小到大的顺序排成一排，学号小的排在前面，然后进行多次调整。一次调整小明可能让一位同学出队，向前或者向后移动一段距离后再插入队列。 例如，下面给出了一组移动的例子，例子中学生的人数为8人。 0）初始队列中学生的学号依次为1, 2, 3, 4, 5, 6, 7, 8； 1）第一次调整，命令为“3号同学向后移动2”，表示3号同学出队，向后移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 3, 6, 7, 8； 2）第二次调整，命令为“8号同学向前移动3”，表示8号同学出队，向前移动3名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 5, 8, 3, 6, 7； 3）第三次调整，命令为“3号同学向前移动2”，表示3号同学出队，向前移动2名同学的距离，再插入到队列中，新队列中学生的学号依次为1, 2, 4, 3, 5, 8, 6, 7。 小明记录了所有调整的过程，请问，最终从前向后所有学生的学号依次是多少？ 请特别注意，上述移动过程中所涉及的号码指的是学号，而不是在队伍中的位置。在向后移动时，移动的距离不超过对应同学后面的人数，如果向后移动的距离正好等于对应同学后面的人数则该同学会移动到队列的最后面。在向前移动时，移动的距离不超过对应同学前面的人数，如果向前移动的距离正好等于对应同学前面的人数则该同学会移动到队列的最前面。 输入格式 输入的第一行包含一个整数n，表示学生的数量，学生的学号由1到n编号。 第二行包含一个整数m，表示调整的次数。 接下来m行，每行两个整数p, q，如果q为正，表示学号为p的同学向后移动q，如果q为负，表示学号为p的同学向前移动-q。 输出格式 输出一行，包含n个整数，相邻两个整数之间由一个空格分隔，表示最终从前向后所有学生的学号。 样例输入 833 28 -33 -2 样例输出 1 2 4 3 5 8 6 7 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ m ≤ 1000，所有移动均合法。 分析： 本题考察链表的应用。 首先，寻找待移动元素在链表中的位置，并将其删除。然后，寻找需要插入的位置，插入该元素。 C++版 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;list&gt;using namespace std;int main() &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); // 初始化 list&lt;int&gt; ls; for (int i = 0; i &lt; n; i++) &#123; ls.push_back(i + 1); &#125; int num, step; while (m--) &#123; scanf("%d %d", &amp;num, &amp;step); list&lt;int&gt;::iterator iter = ls.begin(); // 查找待删除元素的位置 while (*iter != num) &#123; iter++; &#125; // 寻找插入位置 iter = ls.erase(iter); while (step &lt; 0) &#123; iter--; step++; &#125; while (step &gt; 0) &#123; iter++; step--; &#125; // 插入该元素 ls.insert(iter, num); &#125; for (list&lt;int&gt;::iterator iter = ls.begin(); iter != ls.end(); iter++) &#123; if (iter != ls.begin()) &#123; printf(" "); &#125; printf("%d", *iter); &#125; printf("\n"); return 0;&#125; Java版 1234567891011121314151617181920212223242526272829303132import java.util.LinkedList;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int m = scan.nextInt(); // 1.初始化 LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; n; i++) &#123; list.add(i + 1); &#125; // 2.查找待移动的元素并删除，然后在待插入的位置，插入该元素 for (int i = 0; i &lt; m; i++) &#123; int num = scan.nextInt(); int step = scan.nextInt(); int index = list.indexOf(num); list.remove(index); list.add(index + step, num); &#125; scan.close(); // 3.输出 StringBuilder sb = new StringBuilder(2 * n); for (int num : list) &#123; sb.append(num).append(' '); &#125; sb.deleteCharAt(sb.length() - 1); System.out.println(sb.toString()); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python包管理器——pip]]></title>
    <url>%2F2019%2F07%2F26%2Fpython-pip%2F</url>
    <content type="text"><![CDATA[pip，全称package installer for Python，是python的包管理工具。这里总结下pip中常用的一些命令。 查看版本信息12# 注意在-V中，V是大写字母pip --version 或者 pip -V 安装包 安装最新版本 1pip install 包名 指定某个版本 12# 必须写两个等号，且等号左右不能有空格pip install 包名==版本号 指定版本的范围 1234pip install 包名&gt;=版本号pip install 包名&lt;=版本号pip install 包名&gt;版本号pip install 包名&lt;版本号 安装依赖文件中列出的所有包 1pip install -r &lt;requirements file&gt; 更改源临时使用在安装包时，可以使用-i &lt;url&gt;或者--index-url &lt;url&gt;指定临时的Python Package Index（PyPI）源地址（默认为https://pypi.org/simple）。 1pip install some-package -i 源 PyPI 国内源 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple 阿里云 http://mirrors.aliyun.com/pypi/simple 例如，使用清华大学的PyPI镜像来安装NumPy 1pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple 设为默认还是以清华大学的PyPI镜像为例： 1pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple 上述操作将在当前用户的主目录下，生成.config/pip/pip.conf，文件内容如下： 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple 如果想要恢复默认的PyPI源，可以使用如下的命令： 1pip config unset global.index-url 升级包12pip install --upgrade 包名pip install -U 包名 查看已安装的包1pip list 搜索包使用search命令可以从PyPI中搜索需要的包。 1pip search 包名 卸载包 卸载某个包 1pip uninstall 包名 卸载依赖文件中列出的所有包 1pip uninstall -r &lt;requirements file&gt; 帮助信息 如果记不住这些命令，没有关系，使用--help或者-h参数，可以打印帮助信息。 1pip --help 或者 pip -h 使用help查看命令详情。 1pip help 命令]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的激活函数]]></title>
    <url>%2F2019%2F07%2F26%2Fdeep-learning-activation-function%2F</url>
    <content type="text"><![CDATA[常见的激活函数有sigmoid函数、tanh函数和ReLU函数，本文对这三者进行了分析和比较。 sigmoid函数$$\sigma(x) = \frac{1}{1+e^{-x}} \tag{1}$$ sigmoid函数的导数为$$\begin{align}\sigma^\prime (x)&amp;= \frac{-e^{-x}}{(1+e^{-x})^2} \\&amp;= \frac{1}{1+e^{-x}} \times \left( 1-\frac{1}{1+e^{-x}} \right) \\&amp;= \sigma(x) (1-\sigma(x))\end{align} \tag{2}$$ tanh函数$$tanh(x) = \frac{sinhx}{coshx} = \frac{e^x-e^{-x}}{e^x+e^{-x}} \tag{3}$$ tanh函数的导数为$$\begin{align}tanh^\prime(x)&amp;= \frac{(e^x + e^{-x})(e^x + e^{-x}) - (e^x - e^{-x})(e^x - e^{-x})}{(e^x + e^{-x})^2} \\&amp;= 1 - tanh^2 (x)\end{align} \tag{4}$$ ReLU函数线性整流函数（Rectified Linear Unit, ReLU），其数学表达式为$$f(x) = max(0,x) \tag{5}$$ ReLU的导数为$$f^\prime (x) =\begin{cases}0, &amp; x \leq 0 \\1, &amp; x &gt; 0\end{cases} \tag{6}$$ 对比（1）sigmoid函数将值限制在区间(0,1)中，这可能会限制模型的性能。当值趋近于0或者1时，曲线趋于饱和。 （2）由于$$\begin{align}tanh(\frac{x}{2}) &amp;= \frac{e^{\frac{x}{2}}-e^{-\frac{x}{2}}}{e^{\frac{x}{2}}+e^{-\frac{x}{2}}} \\&amp;= \frac{1 - e^{-x}}{1 + e^{-x}} \\&amp;= \frac{2 - (1 + e^{-x})}{1 + e^{-x}} \\&amp;= 2 \sigma(x) - 1\end{align} \tag{7}$$因此，tanh函数也只是在一定程度上缓解了sigmoid函数的问题。 （3）ReLU函数并不会产生饱和问题，能够很好地适应稀疏数据。 参考文献Xiangnan He, Lizi Liao, Hanwang Zhang, Liqiang Nie, Xia Hu and Tat-Seng Chua (2017). Neural Collaborative Filtering. In Proceedings of WWW ‘17, Perth, Australia, April 03-07, 2017.]]></content>
      <categories>
        <category>deep learning</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201709-2.公共钥匙盒]]></title>
    <url>%2F2019%2F07%2F26%2Fccf-csp-20170902%2F</url>
    <content type="text"><![CDATA[问题描述 有一个学校的老师共用N个教室，按照规定，所有的钥匙都必须放在公共钥匙盒里，老师不能带钥匙回家。每次老师上课前，都从公共钥匙盒里找到自己上课的教室的钥匙去开门，上完课后，再将钥匙放回到钥匙盒中。 钥匙盒一共有N个挂钩，从左到右排成一排，用来挂N个教室的钥匙。一串钥匙没有固定的悬挂位置，但钥匙上有标识，所以老师们不会弄混钥匙。 每次取钥匙的时候，老师们都会找到自己所需要的钥匙将其取走，而不会移动其他钥匙。每次还钥匙的时候，还钥匙的老师会找到最左边的空的挂钩，将钥匙挂在这个挂钩上。如果有多位老师还钥匙，则他们按钥匙编号从小到大的顺序还。如果同一时刻既有老师还钥匙又有老师取钥匙，则老师们会先将钥匙全还回去再取出。 今天开始的时候钥匙是按编号从小到大的顺序放在钥匙盒里的。有K位老师要上课，给出每位老师所需要的钥匙、开始上课的时间和上课的时长，假设下课时间就是还钥匙时间，请问最终钥匙盒里面钥匙的顺序是怎样的？ 输入格式 输入的第一行包含两个整数N, K。 接下来K行，每行三个整数w, s, c，分别表示一位老师要使用的钥匙编号、开始上课的时间和上课的时长。可能有多位老师使用同一把钥匙，但是老师使用钥匙的时间不会重叠。 保证输入数据满足输入格式，你不用检查数据合法性。 输出格式 输出一行，包含N个整数，相邻整数间用一个空格分隔，依次表示每个挂钩上挂的钥匙编号。 样例输入 5 24 3 32 2 7 样例输出 1 4 3 2 5 样例说明 第一位老师从时刻3开始使用4号教室的钥匙，使用3单位时间，所以在时刻6还钥匙。第二位老师从时刻2开始使用钥匙，使用7单位时间，所以在时刻9还钥匙。 每个关键时刻后的钥匙状态如下（X表示空）： 时刻2后为1X345； 时刻3后为1X3X5； 时刻6后为143X5； 时刻9后为14325。 样例输入 5 71 1 143 3 121 15 122 7 203 18 124 21 195 30 9 样例输出 1 2 3 5 4 评测用例规模与约定 对于30%的评测用例，1 ≤ N, K ≤ 10, 1 ≤ w ≤ N, 1 ≤ s, c ≤ 30； 对于60%的评测用例，1 ≤ N, K ≤ 50，1 ≤ w ≤ N，1 ≤ s ≤ 300，1 ≤ c ≤ 50； 对于所有评测用例，1 ≤ N, K ≤ 1000，1 ≤ w ≤ N，1 ≤ s ≤ 10000，1 ≤ c ≤ 100。 分析： 首先，定义结构体Key，包含钥匙的编号num、当前动作的开始时间start以及借还状态borrow。 定义vector&lt;key&gt;类型的变量list，长度为n的int型数组arr，其值表示钥匙编号，初始化为1到n。 遍历输入的借还记录，将借和还分别加入到list中。 然后，对list进行排序，排序规则为：按照时间从大到小的顺序排列；若时间相同，则按照先借后还的顺序排列；若借还状态相同，则按照钥匙的编号从大到小排列。 当list不为空时，执行如下循环：将最后一个元素出列，若其borrow == true，则找到对应的钥匙编号，将其设置为-1，表示已借出；否则，寻找arr中第一个值为-1的位置，将钥匙还入该位置。 最后，顺序输出数组arr中的值即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef struct Node &#123; // 钥匙编号 int num; // 开始时间 int start; // 借钥匙还是还钥匙 bool borrow; Node(int _num, int _start, bool _borrow) &#123; num = _num; start = _start; borrow = _borrow; &#125;&#125; Key;bool cmp(Key a, Key b) &#123; // 时间早的在后面，先出列 if (a.start != b.start) &#123; return a.start &gt; b.start; &#125; // 先借后还，还的先出列 if (a.borrow != b.borrow) &#123; return a.borrow &amp;&amp; !b.borrow; &#125; // 按照编号从大到小排列，小的先出列 return a.num &gt; b.num;&#125;int main() &#123; int n, k; scanf("%d %d", &amp;n, &amp;k); int arr[n]; for (int i = 0; i &lt; n; i++) &#123; arr[i] = i + 1; &#125; vector&lt;Key&gt; list; int w, s, c; for (int i = 0; i &lt; k; i++) &#123; scanf("%d %d %d", &amp;w, &amp;s, &amp;c); list.push_back(Key(w, s, true)); list.push_back(Key(w, s + c, false)); &#125; sort(list.begin(), list.end(), cmp); while (!list.empty()) &#123; Key key = list.back(); list.pop_back(); if (key.borrow) &#123; for (int i = 0; i &lt; n; i++) &#123; if (arr[i] == key.num) &#123; // 表示该钥匙已被借出 arr[i] = -1; break; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; n; i++) &#123; if (arr[i] == -1) &#123; arr[i] = key.num; break; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; printf("%d", arr[i]); if (i &lt; n - 1) &#123; printf(" "); &#125; else &#123; printf("\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTex总结]]></title>
    <url>%2F2019%2F07%2F25%2Flatex%2F</url>
    <content type="text"><![CDATA[LaTex文档的基本格式: 12345\documentclass[option]&#123;article&#125;\begin&#123;document&#125; % 所有的其他内容均放在这里 content...\end&#123;document&#125; 注释 单行注释使用%，例如 1% 单行注释 多行注释使用\iffalse...\fi，例如 1234\iffalseHello \LaTexWhy I like it.\fi 使用中文LaTex默认不支持中文，如果要在文档中显示中文，需要引入ctex包 1\usepackage&#123;ctex&#125; 文章标题在导言区使用\title命令，指定文章的标题。 示例： 12345678\title&#123;your title&#125;...\begin&#123;document&#125; ... % 必须加\maketitle，否则，不能显示标题 \maketitle content...\end&#123;document&#125; 作者123456\author&#123;author name&#125;% 比如\author&#123;Gongshan He&#125;\begin&#123;document&#125; content...\end&#123;document&#125; 摘要123\begin&#123;abstract&#125; content...\end&#123;abstract&#125; 目录在文档合适的地方，加入如下命令即可。 1\tableofcontents 分页1\clearpage 插入图片123456789101112...% 引入包\usepackage&#123;graphicx&#125;....\begin&#123;document&#125; .... \begin&#123;figure&#125; \includegraphics&#123;图片地址&#125; \caption&#123;图片标题&#125; \end&#123;figure&#125; ....\end&#123;document&#125; 插入表格12345678910\begin&#123;table&#125; \begin&#123;tabular&#125;&#123;|ccc|&#125; \hline 直角a &amp; 直角b &amp; 直角c \\ \hline 3 &amp; 4 &amp; 5 \\ 5 &amp; 12 &amp; 13 \\ \hline \end&#123;tabular&#125;\end&#123;table&#125; tabular中有一个参数，里面声明了表格中列的模式。|ccc|表示表格有三列，都是居中对齐，在第一列前面和第三列后面各有一条垂直的表格线。类似的还有l（左对齐）和r（右对齐）。 行与行之间用命令\\隔开，每行内部的表项则用符号&amp;隔开。表格中的横线用\hline产生。 分栏 在\documentclass中指定分栏模式 1\documentclass[twocolumn]&#123;article&#125; 在正文中使用命令切换。\twocolumn进入双栏模式，\onecolumn进入单栏模式，两个命令都会先使用\clearpage换页，并不产生一页之内单双栏混合的效果。 参考文献可以使用BIBTEX处理参考文献。 将所有可能会引用的文献放到以.bib结尾的文本文件中。 使用\bibliographystyle设定参考文献的格式，这通常在导言区完成。 使用\bibliography打印出参考文献列表。 例如，当前目录下有一个名为reference.bib的文献数据库，内容如下： 1234567891011121314151617@inproceedings&#123;He:2017:NCF:3038912.3052569, author = &#123;He, Xiangnan and Liao, Lizi and Zhang, Hanwang and Nie, Liqiang and Hu, Xia and Chua, Tat-Seng&#125;, title = &#123;Neural Collaborative Filtering&#125;, booktitle = &#123;Proceedings of the 26th International Conference on World Wide Web&#125;, series = &#123;WWW '17&#125;, year = &#123;2017&#125;, isbn = &#123;978-1-4503-4913-0&#125;, location = &#123;Perth, Australia&#125;, pages = &#123;173--182&#125;, numpages = &#123;10&#125;, url = &#123;https://doi.org/10.1145/3038912.3052569&#125;, doi = &#123;10.1145/3038912.3052569&#125;, acmid = &#123;3052569&#125;, publisher = &#123;International World Wide Web Conferences Steering Committee&#125;, address = &#123;Republic and Canton of Geneva, Switzerland&#125;, keywords = &#123;collaborative filtering, deep learning, implicit feedback, matrix factorization, neural networks&#125;,&#125; 指定数据库文件时，不带bib后缀。可以同时从多个文献数据库中提取文献，文件名用逗号分隔开即可。 123456\begin&#123;document&#125;...% 从文献数据库reference.bib中获取文献信息，打印参考文献列表\bibliography&#123;reference&#125;\end&#123;document&#125; 在正文中，使用\cite命令引用需要的文献，\cite命令引用的位置会出现文献的编号，同时将提示LATEX列出所引用的文献 123456\begin&#123;document&#125;...ncf\cite&#123;He:2017:NCF:3038912.3052569&#125;% 从文献数据库reference.bib中获取文献信息，打印参考文献列表\bibliography&#123;reference&#125;\end&#123;document&#125; 数学公式参看MathJax语法]]></content>
      <categories>
        <category>latex</category>
      </categories>
      <tags>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201712-2.游戏]]></title>
    <url>%2F2019%2F07%2F25%2Fccf-csp-20171202%2F</url>
    <content type="text"><![CDATA[问题描述 有n个小朋友围成一圈玩游戏，小朋友从1至n编号，2号小朋友坐在1号小朋友的顺时针方向，3号小朋友坐在2号小朋友的顺时针方向，……，1号小朋友坐在n号小朋友的顺时针方向。 游戏开始，从1号小朋友开始顺时针报数，接下来每个小朋友的报数是上一个小朋友报的数加1。若一个小朋友报的数为k的倍数或其末位数（即数的个位）为k，则该小朋友被淘汰出局，不再参加以后的报数。当游戏中只剩下一个小朋友时，该小朋友获胜。 例如，当n=5, k=2时： 1号小朋友报数1； 2号小朋友报数2淘汰； 3号小朋友报数3； 4号小朋友报数4淘汰； 5号小朋友报数5； 1号小朋友报数6淘汰； 3号小朋友报数7； 5号小朋友报数8淘汰； 3号小朋友获胜。 给定n和k，请问最后获胜的小朋友编号为多少？ 输入格式 输入一行，包括两个整数n和k，意义如题目所述。 输出格式 输出一行，包含一个整数，表示获胜的小朋友编号。 样例输入 5 2 样例输出 3 样例输入 7 3 样例输出 4 数据规模和约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 9。 分析： 本题考察队列的应用。 先将所有小朋友的编号入队，在队列的长度大于1时，执行如下循环： 若当前报数num % k == 0 || num % 10 == k，则将其出队；否则，让其先出队，再入队。 当队列中只剩下一个小朋友的编号时，这个人就是获胜者。 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int main() &#123; int n, k; scanf("%d %d", &amp;n, &amp;k); queue&lt;int&gt; qu; for (int i = 0; i &lt; n; i++) &#123; qu.push(i + 1); &#125; int num = 0, temp; while (qu.size() &gt; 1) &#123; num++; if (num % k == 0 || num % 10 == k) &#123; qu.pop(); &#125; else &#123; temp = qu.front(); qu.pop(); qu.push(temp); &#125; &#125; printf("%d\n", qu.front()); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201809-2.买菜]]></title>
    <url>%2F2019%2F07%2F20%2Fccf-csp-20180902%2F</url>
    <content type="text"><![CDATA[问题描述 小H和小W来到了一条街上，两人分开买菜，他们买菜的过程可以描述为，去店里买一些菜然后去旁边的一个广场把菜装上车，两人都要买n种菜，所以也都要装n次车。具体的，对于小H来说有n个不相交的时间段$[a_1,b_1],[a_2,b_2]…[a_n,b_n]​$在装车，对于小W来说有n个不相交的时间段$[c_1,d_1],[c_2,d_2]…[c_n,d_n]​$在装车。其中，一个时间段[s, t]表示的是从时刻s到时刻t这段时间，时长为t-s。 由于他们是好朋友，他们都在广场上装车的时候会聊天，他们想知道他们可以聊多长时间。 输入格式 输入的第一行包含一个正整数n，表示时间段的数量。 接下来n行每行两个数$a_i，b_i​$，描述小H的各个装车的时间段。 接下来n行每行两个数$c_i，d_i​$，描述小W的各个装车的时间段。 输出格式 输出一行，一个正整数，表示两人可以聊多长时间。 样例输入 41 35 69 1314 152 45 710 1113 14 样例输出 3 数据规模和约定 对于所有的评测用例，1 ≤ n ≤ 2000, $a_i &lt; b_i &lt; a_{i+1}，c_i &lt; d_i &lt; c_{i+1}$,对于所有的i(1 ≤ i ≤ n)有，1 ≤ $a_i, b_i, c_i, d_i$ ≤ 1000000。 分析： 暴力法：双重循环 用time表示小H和小W能够聊天的时间。 用二维数组hArr存储小H装车的n个时间段，二维数组wArr存储小W装车的n个时间段。 遍历数组hArr，循环内部再遍历数组wArr， 令x为当前的两个时间段中最大的下界，y为最小的上界，即 x = max(hArr[i][0], wArr[j][0])，y= min(hArr[i][1], wArr[j][1]) 若y - x &gt; 0，则表示两个时间段有交叉，time += y - x。 1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void input(int arr[][2], int n) &#123; for (int i = 0; i &lt; n; i++) &#123; scanf("%d %d", &amp;arr[i][0], &amp;arr[i][1]); &#125;&#125;int main() &#123; int n; scanf("%d", &amp;n); int hArr[n][2], wArr[n][2]; input(hArr, n); input(wArr, n); int time = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; int x = max(hArr[i][0], wArr[j][0]); int y = min(hArr[i][1], wArr[j][1]); if (y - x &gt; 0) &#123; time += y - x; &#125; &#125; &#125; printf("%d\n", time); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于《球状闪电》这本小说]]></title>
    <url>%2F2019%2F07%2F19%2Freading-note-ball-lightning%2F</url>
    <content type="text"><![CDATA[《球状闪电》是我这个暑期看的第二本小说，前后大概花了一个星期的时间。 小说结尾时，量子态的林云和其父亲林峰将军长篇幅的两人对话，确实有点无聊。但瑕不掩瑜，《球状闪电》仍是一本很不错的小说。 作为主角的陈博士，大刘没有明说他毕业于哪个学校。但是，根据主角的学校所在地——南京，主角的专业——大气科学，另个一个主角林云的身份——国防科技大学防空武器系统博士，以及2017年的第四轮学科评估，我猜测，应该是南京大学。 下面是我比较喜欢的一些句子： 1.投入全部身心钻研，只问耕耘不问收获，不知不觉的专注中，一辈子也就过去了。 2.美妙人生的关键在于你能迷上什么东西。 3.我现在的人生好比一颗疾飞的炮弹，除了对到达目标时那一声爆炸的渴望之外什么都没有。 4.我和它，像两个要用一生时间准备一场决斗的骑士，当我没准备好的时候，既不去见它也不去想它。 5.窗外的每一片树叶，都使人类的科学显得那么幼稚无力。 6.像我们这样的人，全部身心长期被某种东西占据着以致最后这种东西成了你的一部分，生活中的其他事，再怎么看也是第二位的。 7.恒星这东西，如果不是其确实存在，本来可以很容易证明它不可能存在的。 8.当你渴望某样东西时，道德的约束是多么无力。 9.以前对我来说万分珍贵的时间，现在变得用之不竭了。 10.真正值得关注的是现在和未来。 11.从量子力学的角度来讲，人的死亡过程就是由一个强观察者变为弱观察者再变为非观察者的过程。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201812-2.小明放学]]></title>
    <url>%2F2019%2F07%2F19%2Fccf-csp-20181202%2F</url>
    <content type="text"><![CDATA[题目背景 汉东省政法大学附属中学所在的光明区最近实施了名为“智慧光明”的智慧城市项目。具体到交通领域，通过“智慧光明”终端，可以看到光明区所有红绿灯此时此刻的状态。小明的学校也安装了“智慧光明”终端，小明想利用这个终端给出的信息，估算自己放学回到家的时间。 问题描述 一次放学的时候，小明已经规划好了自己回家的路线，并且能够预测经过各个路段的时间。同时，小明通过学校里安装的“智慧光明”终端，看到了出发时刻路上经过的所有红绿灯的指示状态。请帮忙计算小明此次回家所需要的时间。 输入格式 输入的第一行包含空格分隔的三个正整数 r、y、g，表示红绿灯的设置。这三个数均不超过 10^6。 输入的第二行包含一个正整数 n，表示小明总共经过的道路段数和路过的红绿灯数目。 接下来的 n 行，每行包含空格分隔的两个整数 k、t。k=0 表示经过了一段道路，将会耗时 t 秒，此处 t 不超过 10^6；k=1、2、3 时，分别表示出发时刻，此处的红绿灯状态是红灯、黄灯、绿灯，且倒计时显示牌上显示的数字是 t，此处 t 分别不会超过 r、y、g。 输出格式 输出一个数字，表示此次小明放学回家所用的时间。 样例输入 30 3 3080 101 50 112 20 60 33 100 3 样例输出 46 样例说明 小明先经过第一段路，用时 10 秒。第一盏红绿灯出发时是红灯，还剩 5 秒；小明到达路口时，这个红绿灯已经变为绿灯，不用等待直接通过。接下来经过第二段路，用时 11 秒。第二盏红绿灯出发时是黄灯，还剩两秒；小明到达路口时，这个红绿灯已经变为红灯，还剩 11 秒。接下来经过第三、第四段路，用时 9 秒。第三盏红绿灯出发时是绿灯，还剩 10 秒；小明到达路口时，这个红绿灯已经变为红灯，还剩两秒。接下来经过最后一段路，用时 3 秒。共计 10+11+11+9+2+3 = 46 秒。 评测用例规模与约定 有些测试点具有特殊的性质： 前 2 个测试点中不存在任何信号灯。 测试点的输入数据规模： 前 6 个测试点保证 n ≤ 10^3。 * 所有测试点保证 n ≤ 10^5。 分析： 用time表示回家所用的时间。 遇到道路，即k==0，则将t加到time上； 遇到红绿灯，则通过取余操作，计算当前交通信号灯的状态：rear = (time - t) % (r + g + y);，其中rear表示某个信号灯已经用掉的时间， 若为红灯，则将红灯剩余的时间加到time上； 若为黄灯，则将黄灯剩余的时间以及一个红灯的时间加到time上。 本题需要注意的地方： 第一，交通灯的变换顺序为：红-&gt;绿-&gt;黄-&gt;红。每次遇到黄灯，需要多等待一个红灯的时间。 第二， n ≤ 10^5，t ≤ 10^6，max(time)=n*t = 10^11。因此，time需要声明为long long类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;int main() &#123; int r, y, g; scanf("%d %d %d", &amp;r, &amp;y, &amp;g); int n, k, t; scanf("%d", &amp;n); long long time = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%d %d", &amp;k, &amp;t); if (k == 0) &#123; time += t; &#125; else if (k == 1) &#123; // 红灯 if (t &gt; time) &#123; time = t; &#125; else &#123; // rear表示某个信号灯已经用掉的时间 int rear = (time - t) % (g + y + r); if (rear &gt; g &amp;&amp; rear &lt;= g + y) &#123; // 当前为黄灯 time += g + y - rear + r; &#125; else if (rear &gt; g + y) &#123; // 红灯 time += g + y + r - rear; &#125; &#125; &#125; else if (k == 2) &#123; // 黄灯 if (t &gt; time) &#123; time = t + r; &#125; else &#123; int rear = (time - t) % (r + g + y); if (rear &lt;= r) &#123; // 红灯 time += r - rear; &#125; else if (rear &gt; r + g) &#123; //黄灯 time += r + g + y - rear + r; &#125; &#125; &#125; else &#123; // 绿灯 if (t &lt; time) &#123; int rear = (time - t) % (y + r + g); //黄灯 if (rear &lt;= y) &#123; time += y - rear + r; &#125; else if (rear &lt;= y + r) &#123; time += y + r - rear; &#125; &#125; &#125; &#125; printf("%lld\n", time); return 0;&#125; 若得分为20，则表示没有考虑到黄灯后是红灯； 若得分为60，则表示没有考虑到数据的取值范围，time&lt;=10^11。]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201903-2.二十四点]]></title>
    <url>%2F2019%2F07%2F19%2Fccf-csp-20190302%2F</url>
    <content type="text"><![CDATA[分析： 本题可以使用栈来解决。 遇到数字，则直接进栈； 遇到x，则将栈顶元素top出栈，并将top与下一个数字的乘积，放进栈中； 遇到/，则将栈顶元素top出栈，并让top除以下一个数字，将商放进栈中； 遇到-，则将下一个数字的相反数放进栈中（将减法变为加法）。 最后，将栈中的元素依次出栈，并累加到变量sum中。若sum等于24，则输出Yes；否则，输出No。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;stack&gt;using namespace std;int main() &#123; int n; scanf("%d", &amp;n); getchar(); int data = 0; stack&lt;int&gt; st; while (n--) &#123; // 输入表达式 char str[9]; char temp; int index = 0; while ((temp = getchar()) != '\n') &#123; str[index++] = temp; &#125; str[index] = '\0'; int flag = 1; for (int i = 0; i &lt; index; i++) &#123; if ('1' &lt;= str[i] &amp;&amp; str[i] &lt;= '9') &#123; st.push(flag * (str[i] - '0')); &#125; else if (str[i] == 'x') &#123; data = st.top() * (str[++i] - '0'); st.pop(); st.push(data); &#125; else if (str[i] == '/') &#123; data = st.top() / (str[++i] - '0'); st.pop(); st.push(data); &#125; else if (str[i] == '-') &#123; flag = -1; &#125; else &#123; flag = 1; &#125; &#125; int sum = 0; while (!st.empty()) &#123; sum += st.top(); st.pop(); &#125; if (sum == 24) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201312-1.出现次数最多的数]]></title>
    <url>%2F2019%2F07%2F19%2Fccf-csp-20131201%2F</url>
    <content type="text"><![CDATA[问题描述 给定n个正整数，找出它们中出现次数最多的数。如果这样的数有多个，请输出其中最小的一个。 输入格式 输入的第一行只有一个正整数n(1 ≤ n ≤ 1000)，表示数字的个数。 输入的第二行有n个整数s1, s2, …, sn (1 ≤ si ≤ 10000, 1 ≤ i ≤ n)。相邻的数用空格分隔。 输出格式 输出这n个次数中出现次数最多的数。如果这样的数有多个，输出其中最小的一个。 样例输入 610 1 10 20 30 20 样例输出 10 分析： 本题考察哈希表和排序的简单应用。 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n; scanf("%d", &amp;n); int arr[n]; int hash[10001] = &#123; 0 &#125;; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); hash[arr[i]]++; &#125; sort(arr, arr + n); int index = 0; for (int i = 0; i &lt; n; i++) &#123; if (hash[arr[i]] &gt; hash[arr[index]]) &#123; index = i; &#125; &#125; printf("%d\n", arr[index]); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201403-1.相反数]]></title>
    <url>%2F2019%2F07%2F19%2Fccf-csp-20140301%2F</url>
    <content type="text"><![CDATA[问题描述 有 N 个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数(a 和 -a 为一对相反数)。 输入格式 第一行包含一个正整数 N。(1 ≤ N ≤ 500)。 第二行为 N 个用单个空格隔开的非零整数,每个数的绝对值不超过1000,保证这些整数各不相同。 输出格式 只输出一个整数,即这 N 个数中包含多少对相反数。 样例输入 51 2 3 -1 -2 样例输出 2 123456789101112131415161718192021#include &lt;cstdio&gt;int main() &#123; int n; scanf("%d", &amp;n); int arr[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; int count = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (arr[i] == -arr[j]) &#123; count++; &#125; &#125; &#125; printf("%d\n", count); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201409-1.相邻数对]]></title>
    <url>%2F2019%2F07%2F19%2Fccf-csp-20140901%2F</url>
    <content type="text"><![CDATA[问题描述 给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。 输入格式 输入的第一行包含一个整数n，表示给定整数的个数。 第二行包含所给定的n个整数。 输出格式 输出一个整数，表示值正好相差1的数对的个数。 样例输入 610 2 6 3 7 8 样例输出 3 样例说明 值正好相差1的数对包括(2, 3), (6, 7), (7, 8)。 评测用例规模与约定 1&lt;=n&lt;=1000，给定的整数为不超过10000的非负整数。 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstdlib&gt;int main() &#123; int n; scanf("%d", &amp;n); int arr[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; int count = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (abs(arr[i] - arr[j]) == 1) &#123; count++; &#125; &#125; &#125; printf("%d\n", count); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201412-1.门禁系统]]></title>
    <url>%2F2019%2F07%2F19%2Fccf-csp-20141201%2F</url>
    <content type="text"><![CDATA[问题描述 涛涛最近要负责图书馆的管理工作，需要记录下每天读者的到访情况。每位读者有一个编号，每条记录用读者的编号来表示。给出读者的来访记录，请问每一条记录中的读者是第几次出现。 输入格式 输入的第一行包含一个整数n，表示涛涛的记录条数。 第二行包含n个整数，依次表示涛涛的记录中每位读者的编号。 输出格式 输出一行，包含n个整数，由空格分隔，依次表示每条记录中的读者编号是第几次出现。 样例输入 51 2 1 1 3 样例输出 1 1 2 3 1 评测用例规模与约定 1≤n≤1,000，读者的编号为不超过n的正整数。 分析： 本题可以采用哈希表求解。 12345678910111213141516171819#include &lt;cstdio&gt;int main() &#123; int n; scanf("%d", &amp;n); int arr[n]; // n≤1,000 int hash[1001] = &#123; 0 &#125;; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); printf("%d", ++hash[arr[i]]); if (i &lt; n - 1) &#123; printf(" "); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1048.Find Coins (25 分)]]></title>
    <url>%2F2019%2F07%2F17%2Fpat-advanced-1048%2F</url>
    <content type="text"><![CDATA[Eva loves to collect coins from all over the universe, including some other planets like Mars. One day she visited a universal shopping mall which could accept all kinds of coins as payments. However, there was a special requirement of the payment: for each bill, she could only use exactly two coins to pay the exact amount. Since she has as many as 105 coins with her, she definitely needs your help. You are supposed to tell her, for any given amount of money, whether or not she can find two coins to pay for it. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive numbers: N (≤10^5, the total number of coins) and M (≤10^3, the amount of money Eva has to pay). The second line contains N face values of the coins, which are all positive numbers no more than 500. All the numbers in a line are separated by a space. Output Specification:For each test case, print in one line the two face values V1 and V2 (separated by a space) such that V1+V2=M and V1≤V2. If such a solution is not unique, output the one with the smallest V1. If there is no solution, output No Solution instead. Sample Input 1:128 151 2 8 7 2 4 11 15 Sample Output 1:14 11 Sample Input 2:127 141 8 7 2 4 11 15 Sample Output 2:1No Solution 分析：题目要求：给定N个硬币（每个硬币的面值不超过500），和一个金额M。从N个硬币中选出两个，使得两者的和等于M。然后，按照面值从小到大的顺序，输出这两个硬币的金额V1、V2（V1≤V2）。 若存在多组硬币满足要求，则输出V1最小的那组值。若不存在这样的两个硬币，则输出No Solution。 思路：本题考察哈希表和排序的简单应用。 使用数组hash表示哈希表，下标表示硬币的面值，对应的值表示该面值出现的次数，初始值为0。 将输入的N个硬币的存在数组arr中。 首先，遍历数组arr，统计出各面值硬币出现的次数。 由于题目要求按照从小到大的顺序输出，因此，需要对数组arr进行升序排序。 接着，再次遍历arr，若m - arr[i] &gt;=0 &amp;&amp; m-arr[i] &lt;= 500 &amp;&amp; hash[m - arr[i]] &gt; 0成立， 则接着判断m == arr[i] * 2 &amp;&amp; hash[arr[i]] &lt; 2是否成立， 若成立，则继续下一轮循环；否则，表示已经找到这样两个硬币。 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); int hash[501] = &#123; 0 &#125;; int arr[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); hash[arr[i]]++; &#125; sort(arr, arr + n); for (int i = 0; i &lt; n; i++) &#123; if (m - arr[i] &gt;= 0 &amp;&amp; m - arr[i] &lt;= 500 &amp;&amp; hash[m - arr[i]] &gt; 0) &#123; if (2 * arr[i] == m &amp;&amp; hash[arr[i]] &lt; 2) &#123; continue; &#125; printf("%d %d\n", arr[i], m - arr[i]); return 0; &#125; &#125; printf("No Solution\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1005.继续(3n+1)猜想 (25 分)]]></title>
    <url>%2F2019%2F07%2F16%2Fpat-basic-1005%2F</url>
    <content type="text"><![CDATA[卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式：每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开。 输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。 输入样例：1263 5 6 7 8 11 输出样例：17 6 分析：本题考察哈希表和排序的简单应用。 使用数组hash表示哈希表，下标为给定的正整数，对应的值为该整数出现的次数（或者是否出现），初始值为0。 遍历输入的K个整数，对每个整数执行如下操作： 求出它所覆盖的每个数字data，若data不大于100（n≤100），则data在数组hash中的值加一。 由于题目要求按从大到小的顺序输出关键数字，因此，需要对输入的K个整数进行排序。 最后，再次遍历输入的K个整数，若其在数组hash中的值为0，表示其是关键数字，未被其他数字覆盖。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int k, data; scanf("%d", &amp;k); int hash[101] = &#123; 0 &#125;; int arr[k]; for (int i = 0; i &lt; k; i++) &#123; scanf("%d", &amp;arr[i]); data = arr[i]; while (data != 1) &#123; if (data % 2 == 0) &#123; data /= 2; &#125; else &#123; data = (3 * data + 1) / 2; &#125; // 若不加该条件判断，建议将数组hash的长度设置为5000及以上 // 97能覆盖的最大值为4616 if (data &lt;= 100) &#123; hash[data]++; &#125; &#125; &#125; sort(arr, arr + k); bool isFirst = true; for (int i = k - 1; i &gt;= 0; i--) &#123; if (hash[arr[i]] == 0) &#123; if (!isFirst) &#123; printf(" "); &#125; isFirst = false; printf("%d", arr[i]); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201503-1.图像旋转]]></title>
    <url>%2F2019%2F07%2F15%2Fccf-csp-20150301%2F</url>
    <content type="text"><![CDATA[问题描述 旋转是图像处理的基本操作，在这个问题中，你需要将一个图像逆时针旋转90度。 计算机中的图像表示可以用一个矩阵来表示，为了旋转一个图像，只需要将对应的矩阵旋转即可。 输入格式 输入的第一行包含两个整数n, m，分别表示图像矩阵的行数和列数。 接下来n行每行包含m个整数，表示输入的图像。 输出格式 输出m行，每行包含n个整数，表示原始矩阵逆时针旋转90度后的矩阵。 样例输入 2 31 5 33 2 4 样例输出 3 45 21 3 评测用例规模与约定 1 ≤ n, m ≤ 1,000，矩阵中的数都是不超过1000的非负整数。 分析： n和m的上限为1000。当n和m均达到上限时，数组将包含10^6个元素。因此，该数组应该在main函数外定义。 全局变量在静态存储区中分配空间；而局部变量在栈中分配存储空间。若局部变量过大，会导致栈溢出。 12345678910111213141516171819202122232425#include &lt;cstdio&gt;int arr[1000][1000];int main() &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; scanf("%d", &amp;arr[i][j]); &#125; &#125; // 转置 for (int j = m - 1; j &gt;= 0; j--) &#123; for (int i = 0; i &lt; n; i++) &#123; if (i &gt; 0) &#123; printf(" "); &#125; printf("%d", arr[i][j]); &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201509-1.数列分段]]></title>
    <url>%2F2019%2F07%2F15%2Fccf-csp-20150901%2F</url>
    <content type="text"><![CDATA[问题描述 给定一个整数数列，数列中连续相同的最长整数序列算成一段，问数列中共有多少段？ 输入格式 输入的第一行包含一个整数n，表示数列中整数的个数。 第二行包含n个整数a1, a2, …, an，表示给定的数列，相邻的整数之间用一个空格分隔。 输出格式 输出一个整数，表示给定的数列有多个段。 样例输入 88 8 8 0 12 12 8 0 样例输出 5 样例说明 8 8 8是第一段，0是第二段，12 12是第三段，倒数第二个整数8是第四段，最后一个0是第五段。 评测用例规模与约定 1 ≤ n ≤ 1000，0 ≤ ai ≤ 1000。 1234567891011121314151617#include &lt;cstdio&gt;int main() &#123; int n; scanf("%d", &amp;n); int arr[n]; // 数列段数，n &gt;= 1，因此，count初始化为1 int count = 1; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); if (i &gt; 0 &amp;&amp; arr[i] != arr[i - 1]) &#123; count++; &#125; &#125; printf("%d\n", count); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201512-1.数位之和]]></title>
    <url>%2F2019%2F07%2F15%2Fccf-csp-20151201%2F</url>
    <content type="text"><![CDATA[问题描述 给定一个十进制整数n，输出n的各位数字之和。 输入格式 输入一个整数n。 输出格式 输出一个整数，表示答案。 样例输入 20151220 样例输出 13 样例说明 20151220的各位数字之和为2+0+1+5+1+2+2+0=13。 评测用例规模与约定 所有评测用例满足：0 ≤ n ≤ 1000000000。 123456789101112#include &lt;cstdio&gt;int main() &#123; int n, sum = 0; scanf("%d", &amp;n); while (n &gt; 0) &#123; sum += n % 10; n = n / 10; &#125; printf("%d\n", sum); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201604-1.折点计数]]></title>
    <url>%2F2019%2F07%2F15%2Fccf-csp-20160401%2F</url>
    <content type="text"><![CDATA[问题描述 给定n个整数表示一个商店连续n天的销售量。如果某天之前销售量在增长，而后一天销售量减少，则称这一天为折点，反过来如果之前销售量减少而后一天销售量增长，也称这一天为折点。其他的天都不是折点。如下图中，第3天和第6天是折点。 给定n个整数$a_1, a_2, …, a_n​$表示销售量，请计算出这些天总共有多少个折点。 为了减少歧义，我们给定的数据保证：在这n天中相邻两天的销售量总是不同的，即$a_{i-1}​$≠$a_i​$。注意，如果两天不相邻，销售量可能相同。 输入格式 输入的第一行包含一个整数n。 第二行包含n个整数，用空格分隔，分别表示$a_1, a_2, …, a_n$。 输出格式 输出一个整数，表示折点出现的数量。 样例输入 75 4 1 2 3 6 4 样例输出 2 评测用例规模与约定 所有评测用例满足：1 ≤ n ≤ 1000，每天的销售量是不超过10000的非负整数。 分析： 若某点的值比左右相邻点的值都大，或者都小，则该点为折点。 123456789101112131415161718192021#include &lt;cstdio&gt;int main() &#123; int n; scanf("%d", &amp;n); int arr[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; int count = 0; for (int i = 1; i &lt; n - 1; i++) &#123; // 统计折点 if ((arr[i - 1] &gt; arr[i] &amp;&amp; arr[i] &lt; arr[i + 1]) || (arr[i - 1] &lt; arr[i] &amp;&amp; arr[i] &gt; arr[i + 1])) &#123; count++; &#125; &#125; printf("%d\n", count); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201609-1.最大波动]]></title>
    <url>%2F2019%2F07%2F15%2Fccf-csp-20160901%2F</url>
    <content type="text"><![CDATA[问题描述 小明正在利用股票的波动程度来研究股票。小明拿到了一只股票每天收盘时的价格，他想知道，这只股票连续几天的最大波动值是多少，即在这几天中某天收盘价格与前一天收盘价格之差的绝对值最大是多少。 输入格式 输入的第一行包含了一个整数n，表示小明拿到的收盘价格的连续天数。 第二行包含n个正整数，依次表示每天的收盘价格。 输出格式 输出一个整数，表示这只股票这n天中的最大波动值。 样例输入 62 5 5 7 3 5 样例输出 4 样例说明 第四天和第五天之间的波动最大，波动值为|3-7|=4。 评测用例规模与约定 对于所有评测用例，2 ≤ n ≤ 1000。股票每一天的价格为1到10000之间的整数。 123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;cstdlib&gt;int main() &#123; int n; scanf("%d", &amp;n); int arr[n]; int result = 0, temp = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); if (i &gt; 0) &#123; temp = abs(arr[i] - arr[i - 1]); if (temp &gt; result) &#123; result = temp; &#125; &#125; &#125; printf("%d\n", result); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201612-1.中间数]]></title>
    <url>%2F2019%2F07%2F14%2Fccf-csp-20161201%2F</url>
    <content type="text"><![CDATA[问题描述 在一个整数序列a1, a2, …, an中，如果存在某个数，大于它的整数数量等于小于它的整数数量，则称其为中间数。在一个序列中，可能存在多个下标不相同的中间数，这些中间数的值是相同的。 给定一个整数序列，请找出这个整数序列的中间数的值。 输入格式 输入的第一行包含了一个整数n，表示整数序列中数的个数。 第二行包含n个正整数，依次表示a1, a2, …, an。 输出格式 如果约定序列的中间数存在，则输出中间数的值，否则输出-1表示不存在中间数。 样例输入 62 6 5 6 3 5 样例输出 5 样例说明 比5小的数有2个，比5大的数也有2个。 样例输入 43 4 6 7 样例输出 -1 样例说明 在序列中的4个数都不满足中间数的定义。 样例输入 53 4 6 6 7 样例输出 -1 样例说明 在序列中的5个数都不满足中间数的定义。 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ ai ≤ 1000。 方法一：暴力法 双重循环，时间复杂度为O(n^2)。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;int main() &#123; int n; scanf("%d", &amp;n); int arr[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; // 是否存在中间数 bool exists = false; // left为小于某数的元素个数，right为大于某数的元素个数 int left, right; left = right = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == j) &#123; continue; &#125; if (arr[i] &gt; arr[j]) &#123; left++; &#125; if (arr[i] &lt; arr[j]) &#123; right++; &#125; &#125; if (left == right) &#123; exists = true; printf("%d\n", arr[i]); break; &#125; // 重置为0 left = right = 0; &#125; if (!exists) &#123; printf("-1\n"); &#125; return 0;&#125; 方法二： 先排序，然后找到中间位置mid。分别统计出左右两边与其不相等的元素个数left、right，若left等于right，则mid代表的元素为中间数；否则，不存在中间数。该方法的时间复杂度为O(n log n)。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n; scanf("%d", &amp;n); int arr[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; sort(arr, arr + n); int mid = n / 2; // left为小于arr[mid]的元素个数，right为大于arr[mid]的元素个数 int left = mid, right = n - mid - 1; for (int i = mid - 1; i &gt;= 0; i--) &#123; if (arr[i] != arr[mid]) &#123; break; &#125; left--; &#125; for (int i = mid + 1; i &lt; n; i++) &#123; if (arr[i] != arr[mid]) &#123; break; &#125; right--; &#125; if (left == right) &#123; printf("%d\n", arr[mid]); &#125; else &#123; printf("-1\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1050.String Subtraction (20 分)]]></title>
    <url>%2F2019%2F07%2F14%2Fpat-advanced-1050%2F</url>
    <content type="text"><![CDATA[Given two strings S1 and S2, S=S1−S2 is defined to be the remaining string after taking all the characters in S2 from S1. Your task is simply to calculate S1−S2 for any given strings. However, it might not be that simple to do it fast. Input Specification:Each input file contains one test case. Each case consists of two lines which gives S1 and S2, respectively. The string lengths of both strings are no more than 10^4. It is guaranteed that all the characters are visible ASCII codes and white space, and a new line character signals the end of a string. Output Specification:For each test case, print S1−S2 in one line. Sample Input:12They are students.aeiou Sample Output:1Thy r stdnts. 分析：本题考察哈希表的运用。 用int型数组hash表示哈希表，下标表示字符，对应的值表示该字符是否在S1中出现，默认为0，表示没有出现。 首先，遍历S1，将S1中每个字符的hash值设置为1。 然后，遍历S2中的每个字符，将其在数组hash中的值重置为0，表示在S1中减去该字符。 最后，遍历S1中的每个字符，若该字符在数组hash中的值为1，则输出该字符；否则，不输出。 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;int main() &#123; // 'z' = 122 int hash[123] = &#123; 0 &#125;; char temp; char s1[10001]; int index = 0; // 输入s1,将s1中每个字符的hash值均设置为1 while ((temp = getchar()) != '\n') &#123; s1[index++] = temp; hash[(int) temp] = 1; &#125; s1[index] = '\0'; // 凡是s2中出现的字符，其hash值均重置为0 while ((temp = getchar()) != '\n') &#123; hash[(int) temp] = 0; &#125; for (int i = 0; i &lt; index; i++) &#123; if (hash[(int) s1[i]] == 1) &#123; printf("%c", s1[i]); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201703-1.分蛋糕]]></title>
    <url>%2F2019%2F07%2F14%2Fccf-csp-20170301%2F</url>
    <content type="text"><![CDATA[问题描述 小明今天生日，他有n块蛋糕要分给朋友们吃，这n块蛋糕（编号为1到n）的重量分别为a1, a2, …, an。小明想分给每个朋友至少重量为k的蛋糕。小明的朋友们已经排好队准备领蛋糕，对于每个朋友，小明总是先将自己手中编号最小的蛋糕分给他，当这个朋友所分得蛋糕的重量不到k时，再继续将剩下的蛋糕中编号最小的给他，直到小明的蛋糕分完或者这个朋友分到的蛋糕的总重量大于等于k。 请问当小明的蛋糕分完时，总共有多少个朋友分到了蛋糕。 输入格式 输入的第一行包含了两个整数n, k，意义如上所述。 第二行包含n个正整数，依次表示a1, a2, …, an。 输出格式 输出一个整数，表示有多少个朋友分到了蛋糕。 样例输入 6 92 6 5 6 3 5 样例输出 3 样例说明 第一个朋友分到了前3块蛋糕，第二个朋友分到了第4、5块蛋糕，第三个朋友分到了最后一块蛋糕。 评测用例规模与约定 对于所有评测用例，1 ≤ n ≤ 1000，1 ≤ k ≤ 10000，1 ≤ ai ≤ 1000。 分析： 用count表示分到蛋糕的朋友个数，weight表示分给某个朋友的蛋糕总质量，两者均初始化为0。 遍历每一块蛋糕，将重量累加到weight中， 当weight大于等于k，或者当前蛋糕是最后一块蛋糕时，count自增，weight重置为0，继续下一次循环。 1234567891011121314151617181920212223#include &lt;cstdio&gt;int main() &#123; int n, k; scanf("%d %d", &amp;n, &amp;k); int arr[n]; // 分到蛋糕的朋友个数 int count = 0; int weight = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); weight += arr[i]; // 若分得蛋糕的总重量大于等于k，或者当前蛋糕是最后一块蛋糕 if (weight &gt;= k || i == n - 1) &#123; count++; weight = 0; &#125; &#125; printf("%d\n", count); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201709-1.打酱油]]></title>
    <url>%2F2019%2F07%2F14%2Fccf-csp-20170901%2F</url>
    <content type="text"><![CDATA[问题描述 小明带着N元钱去买酱油。酱油10块钱一瓶，商家进行促销，每买3瓶送1瓶，或者每买5瓶送2瓶。请问小明最多可以得到多少瓶酱油。 输入格式 输入的第一行包含一个整数N，表示小明可用于买酱油的钱数。N是10的整数倍，N不超过300。 输出格式 输出一个整数，表示小明最多可以得到多少瓶酱油。 样例输入 40 样例输出 5 样例说明 把40元分成30元和10元，分别买3瓶和1瓶，其中3瓶送1瓶，共得到5瓶。 样例输入 80 样例输出 11 样例说明 把80元分成30元和50元，分别买3瓶和5瓶，其中3瓶送1瓶，5瓶送2瓶，共得到11瓶。 分析： 买5送2，比买3送1划算。因此，尽可能把钱花在买5送2的活动上，剩下的钱继续买3送1的活动，最后才单买。 123456789101112131415161718192021222324#include &lt;cstdio&gt;int main() &#123; int n; scanf("%d", &amp;n); int count = 0; // 每买5瓶送2瓶 if (n &gt;= 50) &#123; count += (n / 50) * 7; n %= 50; &#125; // 每买3瓶送1瓶 if (n &gt;= 30) &#123; count += (n / 30) * 4; n %= 30; &#125; if (n &gt;= 10) &#123; count += n / 10; &#125; printf("%d\n", count); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201712-1.最小差值]]></title>
    <url>%2F2019%2F07%2F13%2Fccf-csp-20171201%2F</url>
    <content type="text"><![CDATA[问题描述 给定n个数，请找出其中相差（差的绝对值）最小的两个数，输出它们的差值的绝对值。 输入格式 输入第一行包含一个整数n。 第二行包含n个正整数，相邻整数之间使用一个空格分隔。 输出格式 输出一个整数，表示答案。 样例输入 51 5 4 8 20 样例输出 1 样例说明 相差最小的两个数是5和4，它们之间的差值是1。 样例输入 59 3 6 1 3 样例输出 0 样例说明 有两个相同的数3，它们之间的差值是0. 数据规模和约定 对于所有评测用例，2 ≤ n ≤ 1000，每个给定的整数都是不超过10000的正整数。 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstdlib&gt;int main() &#123; int n; scanf("%d", &amp;n); int arr[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; int span = 10000, temp; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; temp = abs(arr[i] - arr[j]); if (temp &lt; span) &#123; span = temp; &#125; &#125; &#125; printf("%d\n", span); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1041.Be Unique (20 分)]]></title>
    <url>%2F2019%2F07%2F13%2Fpat-advanced-1041%2F</url>
    <content type="text"><![CDATA[Being unique is so important to people on Mars that even their lottery is designed in a unique way. The rule of winning is simple: one bets on a number chosen from [1,10^4]. The first one who bets on a unique number wins. For example, if there are 7 people betting on { 5 31 5 88 67 88 17 }, then the second one who bets on 31 wins. Input Specification:Each input file contains one test case. Each case contains a line which begins with a positive integer N (≤10^5) and then followed by N bets. The numbers are separated by a space. Output Specification:For each test case, print the winning number in a line. If there is no winner, print None instead. Sample Input 1:17 5 31 5 88 67 88 17 Sample Output 1:131 Sample Input 2:15 888 666 666 888 888 Sample Output 2:1None 分析：题目要求：给定N个数，输出第一个不重复的数字。若不存在这样的数字，则输出None。 思路：本题考察哈希表的运用。 用数组hash表示哈希表，下标表示待输入的数，取值范围为[1,10^4]，对应值为该数出现的次数，初始值为0。 设置bool型变量exists，表示是否存在不重复的数字，初始值为false。 对输入的N个数执行两次遍历，第一次遍历，统计每个数出现的次数；第二次遍历，寻找第一个出现次数为1的数字并输出。若存在这样的数字，则将exists设置为true。 第二次遍历结束以后，若exists仍为false，表示不存在这样的数字，则输出None。 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;int main() &#123; int n; scanf("%d", &amp;n); int hash[10001] = &#123; 0 &#125;; int data[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data[i]); hash[data[i]]++; &#125; // 是否存在赢家 bool exists = false; for (int i = 0; i &lt; n; i++) &#123; if (hash[data[i]] == 1) &#123; exists = true; printf("%d\n", data[i]); break; &#125; &#125; if (!exists) &#123; printf("None\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201809-1.卖菜]]></title>
    <url>%2F2019%2F07%2F12%2Fccf-csp-20180901%2F</url>
    <content type="text"><![CDATA[问题描述 在一条街上有n个卖菜的商店，按1至n的顺序排成一排，这些商店都卖一种蔬菜。 第一天，每个商店都自己定了一个价格。店主们希望自己的菜价和其他商店的一致，第二天，每一家商店都会根据他自己和相邻商店的价格调整自己的价格。具体的，每家商店都会将第二天的菜价设置为自己和相邻商店第一天菜价的平均值（用去尾法取整）。 注意，编号为1的商店只有一个相邻的商店2，编号为n的商店只有一个相邻的商店n-1，其他编号为i的商店有两个相邻的商店i-1和i+1。 给定第一天各个商店的菜价，请计算第二天每个商店的菜价。 输入格式 输入的第一行包含一个整数n，表示商店的数量。 第二行包含n个整数，依次表示每个商店第一天的菜价。 输出格式 输出一行，包含n个正整数，依次表示每个商店第二天的菜价。 样例输入 84 1 3 1 6 5 17 9 样例输出 2 2 1 3 4 9 10 13 数据规模和约定 对于所有评测用例，2 ≤ n ≤ 1000，第一天每个商店的菜价为不超过10000的正整数。 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;int main() &#123; int n; scanf("%d", &amp;n); int arr[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; // 计算第二天的菜价 int price; for (int i = 0; i &lt; n; i++) &#123; if (i == 0) &#123; price = (arr[i] + arr[i + 1]) / 2; &#125; else if (i == n - 1) &#123; price = (arr[i] + arr[i - 1]) / 2; &#125; else &#123; price = (arr[i - 1] + arr[i] + arr[i + 1]) / 3; &#125; if (i &gt; 0) &#123; printf(" "); &#125; printf("%d", price); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201812-1.小明上学]]></title>
    <url>%2F2019%2F07%2F12%2Fccf-csp-20181201%2F</url>
    <content type="text"><![CDATA[题目背景 小明是汉东省政法大学附属中学的一名学生，他每天都要骑自行车往返于家和学校。为了能尽可能充足地睡眠，他希望能够预计自己上学所需要的时间。他上学需要经过数段道路，相邻两段道路之间设有至多一盏红绿灯。 京州市的红绿灯是这样工作的：每盏红绿灯有红、黄、绿三盏灯和一个能够显示倒计时的显示牌。假设红绿灯被设定为红灯 r 秒，黄灯 y 秒，绿灯 g 秒，那么从 0 时刻起，[0,r) 秒内亮红灯，车辆不许通过；[r, r+g) 秒内亮绿灯，车辆允许通过；[r+g, r+g+y) 秒内亮黄灯，车辆不许通过，然后依次循环。倒计时的显示牌上显示的数字 l（l &gt; 0）是指距离下一次信号灯变化的秒数。 问题描述 一次上学的路上，小明记录下了经过每段路的时间，和各个红绿灯在小明到达路口时的颜色和倒计时秒数。希望你帮忙计算此次小明上学所用的时间。 输入格式 输入的第一行包含空格分隔的三个正整数 r、y、g，表示红绿灯的设置。这三个数均不超过 10^6。 输入的第二行包含一个正整数 n（n ≤ 100），表示小明总共经过的道路段数和看到的红绿灯数目。 接下来的 n 行，每行包含空格分隔的两个整数 k、t。k=0 表示经过了一段道路，耗时 t 秒，此处 t 不超过 10^6；k=1、2、3 时，分别表示看到了一个红灯、黄灯、绿灯，且倒计时显示牌上显示的数字是 t，此处 t 分别不会超过 r、y、g。 输出格式 输出一个数字，表示此次小明上学所用的时间。 样例输入 30 3 3080 101 50 112 20 60 33 100 3 样例输出 70 样例说明 小明先经过第一段道路，用时 10 秒，然后等待 5 秒的红灯，再经过第二段道路，用时 11 秒，然后等待 2 秒的黄灯和 30 秒的红灯，再经过第三段、第四段道路，分别用时6、3秒，然后通过绿灯，再经过最后一段道路，用时 3 秒。共计 10 + 5 + 11 + 2 + 30 + 6 + 3 + 3=70 秒。 评测用例规模与约定 测试点 1, 2 中不存在任何信号灯。 测试点 3, 4 中所有的信号灯在被观察时均为绿灯。 测试点 5, 6 中所有的信号灯在被观察时均为红灯。 测试点 7, 8 中所有的信号灯在被观察时均为黄灯。 测试点 9, 10 中将出现各种可能的情况。 分析： 红绿灯的变换顺序为：红-&gt;绿-&gt;黄-&gt;红… 因此，每当遇到黄灯时，需要额外加上一个红灯的时间。 1234567891011121314151617181920212223#include &lt;cstdio&gt;int main() &#123; int r, y, g; scanf("%d %d %d", &amp;r, &amp;y, &amp;g); int n, k, t, time = 0; scanf("%d", &amp;n); // 红绿灯变色顺序：红-&gt;绿-&gt;黄-&gt;红 // k=1、2、3，表示红、黄、绿 for (int i = 0; i &lt; n; i++) &#123; scanf("%d %d", &amp;k, &amp;t); if (k == 0 || k == 1 || k == 2) &#123; time += t; &#125; if (k == 2) &#123; time += r; &#125; &#125; printf("%d\n", time); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1047.编程团体赛 (20 分)]]></title>
    <url>%2F2019%2F07%2F11%2Fpat-basic-1047%2F</url>
    <content type="text"><![CDATA[编程团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。 现给定所有队员的比赛成绩，请你编写程序找出冠军队。 输入格式：输入第一行给出一个正整数 N（≤10^4），即所有参赛队员总数。随后 N 行，每行给出一位队员的成绩，格式为：队伍编号-队员编号 成绩，其中队伍编号为 1 到 1000 的正整数，队员编号为 1 到 10 的正整数，成绩为 0 到 100 的整数。 输出格式：在一行中输出冠军队的编号和总成绩，其间以一个空格分隔。注意：题目保证冠军队是唯一的。 输入样例：123456763-10 9911-5 87102-1 0102-3 10011-9 893-2 61 输出样例：111 176 分析：本题考察的是哈希表的应用。 用数组hash表示哈希表，其下标表示队伍编号，对应的值为该队伍的比赛成绩，初始值为0。 遍历输入的N个参赛队员及其成绩score，将该成绩累加到该队员所在队伍的比赛成绩中。 然后，遍历数组hash，寻找其中比赛成绩最高的队伍，输出其队伍编号和总成绩。 12345678910111213141516171819#include &lt;cstdio&gt;int main() &#123; int n, teamNo, peopleNo, score; scanf("%d", &amp;n); int hash[1001] = &#123; 0 &#125;; for (int i = 0; i &lt; n; i++) &#123; scanf("%d-%d %d", &amp;teamNo, &amp;peopleNo, &amp;score); hash[teamNo] += score; &#125; int maxIndex = 0; for (int i = 0; i &lt; 1001; i++) &#123; if (hash[i] &gt; hash[maxIndex]) &#123; maxIndex = i; &#125; &#125; printf("%d %d\n", maxIndex, hash[maxIndex]); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1043.输出PATest (20 分)]]></title>
    <url>%2F2019%2F07%2F11%2Fpat-basic-1043%2F</url>
    <content type="text"><![CDATA[给定一个长度不超过 10^4 的、仅由英文字母构成的字符串。请将字符重新调整顺序，按 PATestPATest.... 这样的顺序输出，并忽略其它字符。当然，六种字符的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按 PATest 的顺序打印，直到所有字符都被输出。 输入格式：输入在一行中给出一个长度不超过 10^4 的、仅由英文字母构成的非空字符串。 输出格式：在一行中按题目要求输出排序后的字符串。题目保证输出非空。 输入样例：1redlesPayBestPATTopTeePHPereatitAPPT 输出样例：1PATestPATestPTetPTePePee 分析：本题考察哈希表的简单运用。 用数组hash表示哈希表，其下标表示字母，对应的值表示该字母的出现次数。 设置一个bool型变量flag，标记是否还需要输出，默认为true。 然后，循环执行如下操作： 按照PATest的顺序，输出对应的字母，并减少其在hash中的值。若某种字符已经输出完，则余下的字符仍按 PATest 的顺序打印，直到所有字符都被输出。 当PATest这六个字母在数组hash中的值全为0时，表示不再需要输出，flag设置为false，循环结束。 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;int main() &#123; char temp; int hash[123] = &#123; 0 &#125;; while ((temp = getchar()) != '\n') &#123; hash[temp]++; &#125; char arr[7] = &#123; 'P', 'A', 'T', 'e', 's', 't' &#125;; // flag表示是否还有字符可以输出 bool flag = true; while (flag) &#123; for (int i = 0; i &lt; 6; i++) &#123; if (hash[arr[i]] != 0) &#123; printf("%c", arr[i]); hash[arr[i]]--; &#125; &#125; // 判断是否所有的字符都已被输出 flag = false; for (int i = 0; i &lt; 6; i++) &#123; if (hash[arr[i]] != 0) &#123; flag = true; &#125; &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1042.字符统计 (20 分)]]></title>
    <url>%2F2019%2F07%2F11%2Fpat-basic-1042%2F</url>
    <content type="text"><![CDATA[请编写程序，找出一段给定文字中出现最频繁的那个英文字母。 输入格式：输入在一行中给出一个长度不超过 1000 的字符串。字符串由 ASCII 码表中任意可见字符及空格组成，至少包含 1 个英文字母，以回车结束（回车不算在内）。 输出格式：在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。 输入样例：1This is a simple TEST. There ARE numbers and other symbols 1&amp;2&amp;3........... 输出样例：1e 7 分析：本题考察哈希表的应用。 用数组hash表示哈希表，其下标表示字母，对应值为该字母出现的次数，初始值为0。 遍历输入字符串中的每一个字符，当该字符为小写字母时，其在hash中的值加一；若为大写字母，则其小写形式的hash值加一。 最后，遍历数组hash，输出其中的最大值及其对应的最小下标（字母序最小的那个字母）。 1234567891011121314151617181920212223#include &lt;cstdio&gt;int main() &#123; char temp; // 'z' = 122 char hash[123] = &#123; 0 &#125;; while ((temp = getchar()) != '\n') &#123; if ('A' &lt;= temp &amp;&amp; temp &lt;= 'Z') &#123; hash[temp + 32]++; &#125; else if ('a' &lt;= temp &amp;&amp; temp &lt;= 'z') &#123; hash[(int) temp]++; &#125; &#125; int count = 0; for (int i = 97; i &lt; 123; i++) &#123; if (hash[i] &gt; count) &#123; temp = i; count = hash[i]; &#125; &#125; printf("%c %d\n", temp, count); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201903-1.小中大]]></title>
    <url>%2F2019%2F07%2F09%2Fccf-csp-20190301%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;int main() &#123; int n; scanf("%d", &amp;n); int arr[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; // 输入的数据是否为升序 bool asc = true; // 最大值 if (arr[n - 1] &gt; arr[0]) &#123; printf("%d ", arr[n - 1]); &#125; else &#123; asc = false; printf("%d ", arr[0]); &#125; // 中位数 if (n % 2 == 0) &#123; if ((arr[n / 2 - 1] + arr[n / 2]) % 2 == 0) &#123; printf("%d ", (arr[n / 2 - 1] + arr[n / 2]) / 2); &#125; else &#123; printf("%.1f ", (arr[n / 2 - 1] + arr[n / 2]) / 2.0); &#125; &#125; else &#123; printf("%d ", arr[n / 2]); &#125; // 最小值 if (asc) &#123; printf("%d\n", arr[0]); &#125; else &#123; printf("%d\n", arr[n - 1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1039.到底买不买 (20 分)]]></title>
    <url>%2F2019%2F07%2F07%2Fpat-basic-1039%2F</url>
    <content type="text"><![CDATA[小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。 为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。 图 1 输入格式：每个输入包含 1 个测试用例。每个测试用例分别在 2 行中先后给出摊主的珠串和小红想做的珠串，两串都不超过 1000 个珠子。 输出格式：如果可以买，则在一行中输出 Yes 以及有多少多余的珠子；如果不可以买，则在一行中输出 No 以及缺了多少珠子。其间以 1 个空格分隔。 输入样例 1：12ppRYYGrrYBR2258YrR8RrY 输出样例 1：1Yes 8 输入样例 2：12ppRYYGrrYB225YrR8RrY 输出样例 2：1No 2 分析：本题考察的是哈希表的使用。 变量设置 使用数组hash表示哈希表，其下标表示某字符，值表示该字符出现的次数。 bool型变量absent，表示是否缺少珠子，初始化为false。 int型变量count，表示缺少或多出的珠子的个数，初始化为0。 思路 首先，使用数组hash统计出摊主的珠串中各字符出现的次数。 然后，遍历小红想做的珠串，判断每个字符（这里用temp表示）在hash中的值， 若hash[temp]==0，则表示缺少该字符，count自增，absent设置为true；否则，hash[temp]--。 最后，判断absent是否为true，若absent == true，则输出No和缺少的珠子个数count； 否则，输出Yes和多出的珠子个数。此时数组hash中所有值之和，即为多出的珠子个数。 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;int main() &#123; char temp; // 'z' = 122 int hash[123] = &#123; 0 &#125;; while ((temp = getchar()) != '\n') &#123; hash[temp]++; &#125; // 是否缺少珠子 bool absent = false; // 统计多出或者缺少的珠子个数 int count = 0; while ((temp = getchar()) != '\n') &#123; // 没有某颗珠子 if (hash[temp] == 0) &#123; // 统计缺少珠子的个数 count++; absent = true; &#125; else &#123; hash[temp]--; &#125; &#125; if (absent) &#123; printf("No "); &#125; else &#123; printf("Yes "); // 计算多余珠子的个数 for (int i = 0; i &lt; 123; i++) &#123; count += hash[i]; &#125; &#125; printf("%d\n", count); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1038.统计同成绩学生 (20 分)]]></title>
    <url>%2F2019%2F07%2F07%2Fpat-basic-1038%2F</url>
    <content type="text"><![CDATA[本题要求读入 N 名学生的成绩，将获得某一给定分数的学生人数输出。 输入格式：输入在第 1 行给出不超过 10^5 的正整数 N，即学生总人数。随后一行给出 N 名学生的百分制整数成绩，中间以空格分隔。最后一行给出要查询的分数个数 K（不超过 N 的正整数），随后是 K 个分数，中间以空格分隔。 输出格式：在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。 输入样例：1231060 75 90 55 75 99 82 90 75 503 75 90 88 输出样例：13 2 0 分析：本题考察的是哈希表的运用。 数组hash表示哈希表，其下标为分数，值为得分等于该分数的学生人数。 首先，遍历所有学生的得分，用数组hash统计各分数的出现次数。 然后，输出待查询的分数在数组hash中的值即可。 12345678910111213141516171819202122#include &lt;cstdio&gt;int main() &#123; int n, k, score; // 下标表示分数，值表示该分数出现的次数 int hash[101] = &#123; 0 &#125;; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;score); hash[score]++; &#125; scanf("%d", &amp;k); for (int i = 0; i &lt; k; i++) &#123; scanf("%d", &amp;score); if (i &gt; 0) &#123; printf(" "); &#125; printf("%d", hash[score]); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1033.旧键盘打字 (20 分)]]></title>
    <url>%2F2019%2F07%2F05%2Fpat-basic-1033%2F</url>
    <content type="text"><![CDATA[旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？ 输入格式：输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 10^5 个字符的串。可用的字符包括字母 [a-z, A-Z]、数字 0-9、以及下划线 _（代表空格）、,、.、-、+（代表上档键）。题目保证第 2 行输入的文字串非空。 注意：如果上档键坏掉了，那么大写的英文字母无法被打出。 输出格式：在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。 输入样例：127+IE.7_This_is_a_test. 输出样例：1_hs_s_a_tst 分析：采用哈希表。数组hash以字符为下标，初始值均赋为0。对坏掉的那些键，更新其值为1。 遍历应该输入的文字时，若对应字符在数组hash中的值为1，则表示该键坏掉了；若为0，则表示该键没坏，输出该字符。 如果上档键坏掉了，那么大写的英文字母无法被打出。因此，若当前字符为大写字母，则需要判断上档键是否坏掉。若上档键没坏，则输出该字符；否则，不输出。 由于英文字母的坏键以大写给出，因此，若当前字符为小写字母，则应判断其大写形式在hash中的值是否为1。 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;bool isNotBroken(int hash[], char c) &#123; // 若上档键坏了，那么大写的英文字母不能输出。 if ('A' &lt;= c &amp;&amp; c &lt;= 'Z' &amp;&amp; hash['+'] == 1) &#123; return false; &#125; if ('a' &lt;= c &amp;&amp; c &lt;= 'z') &#123; c -= 32; &#125; return hash[c] == 0;&#125;int main() &#123; // 'z'=122 int hash[123] = &#123; 0 &#125;; char temp; // 处理坏掉的键，更新其值为1 while ((temp = getchar()) != '\n') &#123; hash[temp] = 1; &#125; // 处理应该输入的文字 while ((temp = getchar()) != '\n') &#123; // 若当前键没坏，则输出 if (isNotBroken(hash, temp)) &#123; printf("%c", temp); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1029.旧键盘/PAT甲级 1084.Broken Keyboard (20 分)]]></title>
    <url>%2F2019%2F07%2F03%2Fpat-basic-1029%2F</url>
    <content type="text"><![CDATA[旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。 输入格式：输入在 2 行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过 80 个字符的串，由字母 A-Z（包括大、小写）、数字 0-9、以及下划线 _（代表空格）组成。题目保证 2 个字符串均非空。 输出格式：按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键。 输入样例：127_This_is_a_test_hs_s_a_es 输出样例：17TI 分析：设应该输入的文字为s1，实际被输入的文字为s2。 使用哈希表hash（用数组表示），记录下s1中各字符的出现次数。数组hash以字符为下标，出现次数为值。 由于小写字母z的ASCII码值为122，因此，数组hash的长度应申明为123。 然后，遍历s2，对数组hash中相应字符的出现次数，执行自减操作。 最后，遍历s1，若当前字符c在数组hash中的值大于0，则输出该字符。 由于题目要求相同字符只输出一次，因此，输出字符c后，其在数组hash中的值应赋值为0，即hash[c]=0。 需要注意的地方：英文字母只输出大写。因此，在遍历s1（s2）时，若为小写字母，则增加（减少）其大写字母的出现次数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstring&gt;bool is_lower(char c) &#123; return 'a' &lt;= c &amp;&amp; c &lt;= 'z';&#125;void getline(char s[]) &#123; char temp; int index = 0; while ((temp = getchar()) != '\n') &#123; s[index++] = temp; &#125; s[index] = '\0';&#125;int main() &#123; char s1[81], s2[81]; getline(s1); // 'z'=122 int hash[123] = &#123; 0 &#125;; int len1 = strlen(s1); for (int i = 0; i &lt; len1; i++) &#123; if (is_lower(s1[i])) &#123; hash[s1[i] - 32]++; &#125; else &#123; hash[s1[i]]++; &#125; &#125; getline(s2); for (int i = 0; i &lt; strlen(s2); i++) &#123; if (is_lower(s2[i])) &#123; hash[s2[i] - 32]--; &#125; else &#123; hash[s2[i]]--; &#125; &#125; char c; for (int i = 0; i &lt; len1; i++) &#123; if (is_lower(s1[i])) &#123; c = s1[i] - 32; &#125; else &#123; c = s1[i]; &#125; if (hash[c] &gt; 0) &#123; printf("%c", c); // 相同字符只输出一次 hash[c] = 0; &#125; &#125; printf("\n");&#125;]]></content>
      <categories>
        <category>pat乙级</category>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在MacOS中配置MySQL]]></title>
    <url>%2F2019%2F07%2F01%2Fmacos-mysql-installation%2F</url>
    <content type="text"><![CDATA[“好记性不如烂笔头。”这里，记录下我在MacOS中安装MySQL的过程。 1.下载及安装 下载地址：https://dev.mysql.com/downloads/mysql/ 默认安装路径为/usr/local/mysql 2.启动服务 在系统偏好设置中，查看MySQL服务是否启动，如果没有启动，则启动服务。 3.配置环境变量 由于没有配置环境变量，此时，若在终端输入mysql，将找不到命令 12hgs:bin hegongshan$ mysql-bash: mysql: command not found 修改～/.bash_profile文件，在其中添加如下内容 12# mysqlPATH=$PATH:/usr/local/mysql/bin 然后，在终端中输入如下命令，使刚才的配置生效 1source ~/.bash_profile 4.检查配置是否成功 在终端中尝试输出mysql的版本号，检查配置是否成功 1mysql --version 输出如下 12hgs:bin hegongshan$ mysql --versionmysql Ver 8.0.16 for macos10.14 on x86_64 (MySQL Community Server - GPL)]]></content>
      <categories>
        <category>macos</category>
      </categories>
      <tags>
        <tag>macos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1080.Graduate Admission (30 分)]]></title>
    <url>%2F2019%2F06%2F30%2Fpat-advanced-1080%2F</url>
    <content type="text"><![CDATA[It is said that in 2011, there are about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure. Each applicant will have to provide two grades: the national entrance exam grade $G_E​$, and the interview grade $G_I​$. The final grade of an applicant is ($G_E​$+$G_I​$)/2. The admission rules are: The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list. If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade $G_E​$. If still tied, their ranks must be the same. Each applicant may have K choices and the admission will be done according to his/her choices: if according to the rank list, it is one’s turn to be admitted; and if the quota of one’s most preferred shcool is not exceeded, then one will be admitted to this school, or one’s other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected. If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, even if its quota will be exceeded. Input Specification:Each input file contains one test case. Each case starts with a line containing three positive integers: N (≤40,000), the total number of applicants; M (≤100), the total number of graduate schools; and K (≤5), the number of choices an applicant may have. In the next line, separated by a space, there are M positive integers. The i-th integer is the quota of the i-th graduate school respectively. Then N lines follow, each contains 2+K integers separated by a space. The first 2 integers are the applicant’s $G_E​$ and $G_I​$, respectively. The next K integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to M−1, and the applicants are numbered from 0 to N−1. Output Specification:For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants’ numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly. Sample Input:1234567891011121311 6 32 1 2 2 2 3100 100 0 1 260 60 2 3 5100 90 0 3 490 100 1 2 090 90 5 1 380 90 1 0 280 80 0 1 280 80 0 1 280 70 1 3 270 80 1 2 3100 100 0 2 4 Sample Output:1234560 1035 6 72 81 4 分析：题目要求：给定N个考生、M个学校，每个考生可以填报K个学校。 每个考生的成绩由两部分组成：国家入学考试成绩$G_E$和面试成绩$G_I$，最终成绩为($G_E$+$G_I$)/2。 按照他们的最终成绩从高到低排序，依次进入录取程序。 若最终成绩相同，则按照$G_E$从高到低排序。若$G_E$也相同，则排名相同。 若考生当前志愿学校尚未招满，则考生被录取。否则，依次考虑其他志愿。此外，若当前考生与该校上一个录取的学生排名相同，即使招生计划已满，考生也会被录取。 最后，输出各校的录取名单，各校录取名单按照学生编号从小到大排序。若某校未录取任何考生，则输出空行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef struct Node &#123; int id, rank; // 成绩 int gExam, gInterview, gFinal; // 报考院校 int preferred[5];&#125; Applicant;typedef struct Node2 &#123; // 计划招生数 int quota; // 上一次录取的学生下标 int last; // 录取名单（学生的编号） vector&lt;int&gt; admission;&#125; School;bool cmp(Applicant a, Applicant b) &#123; if (a.gFinal != b.gFinal) &#123; return a.gFinal &gt; b.gFinal; &#125; return a.gExam &gt; b.gExam;&#125;int main() &#123; int n, m, k; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); Applicant applicant[n]; School schools[m]; for (int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;schools[i].quota); schools[i].last = -1; &#125; for (int i = 0; i &lt; n; i++) &#123; applicant[i].id = i; scanf("%d %d", &amp;applicant[i].gExam, &amp;applicant[i].gInterview); applicant[i].gFinal = (applicant[i].gExam + applicant[i].gInterview) / 2; for (int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;applicant[i].preferred[j]); &#125; &#125; // 排名 sort(applicant, applicant + n, cmp); applicant[0].rank = 1; for (int i = 1; i &lt; n; i++) &#123; if (applicant[i].gFinal == applicant[i - 1].gFinal &amp;&amp; applicant[i].gExam == applicant[i - 1].gExam) &#123; applicant[i].rank = applicant[i - 1].rank; &#125; else &#123; applicant[i].rank = i + 1; &#125; &#125; // 录取过程 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; int index = applicant[i].preferred[j]; int last = schools[index].last; int size = schools[index].admission.size(); // 若尚未招满，或者当前学生与上一个录取的学生排名相同 if (schools[index].quota &gt; size || (last != -1 &amp;&amp; applicant[last].rank == applicant[i].rank)) &#123; schools[index].admission.push_back(applicant[i].id); schools[index].last = i; break; &#125; &#125; &#125; // 输出录取结果 for (int i = 0; i &lt; m; i++) &#123; int size = schools[i].admission.size(); if (size &gt; 0) &#123; sort(schools[i].admission.begin(), schools[i].admission.end()); for (int j = 0; j &lt; size; j++) &#123; if (j &gt; 0) &#123; printf(" "); &#125; printf("%d", schools[i].admission[j]); &#125; &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1083.List Grades (25 分)]]></title>
    <url>%2F2019%2F06%2F28%2Fpat-advanced-1083%2F</url>
    <content type="text"><![CDATA[Given a list of N student records with name, ID and grade. You are supposed to sort the records with respect to the grade in non-increasing order, and output those student records of which the grades are in a given interval. Input Specification:Each input file contains one test case. Each case is given in the following format: 123456Nname[1] ID[1] grade[1]name[2] ID[2] grade[2]... ...name[N] ID[N] grade[N]grade1 grade2 where name[i] and ID[i] are strings of no more than 10 characters with no space, grade[i] is an integer in [0, 100], grade1 and grade2 are the boundaries of the grade’s interval. It is guaranteed that all the grades are distinct. Output Specification:For each test case you should output the student records of which the grades are in the given interval [grade1, grade2] and are in non-increasing order. Each student record occupies a line with the student’s name and ID, separated by one space. If there is no student’s grade in that interval, output NONE instead. Sample Input 1:1234564Tom CS000001 59Joe Math990112 89Mike CS991301 100Mary EE990830 9560 100 Sample Output 1:123Mike CS991301Mary EE990830Joe Math990112 Sample Input 2:12342Jean AA980920 60Ann CS01 8090 95 Sample Output 2:1NONE 分析：题目要求：给定N个学生的姓名name、ID和成绩grade，以及成绩范围[grade1,grade2]。 先按照成绩从高到低排序，然后输出成绩在[grade1,grade2]内的学生的姓名和ID。 若没有一个学生的成绩在给定的范围内，则输出NONE。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef struct Node &#123; char name[11], id[11]; int grade;&#125; Student;bool cmp(Student a, Student b) &#123; return a.grade &gt; b.grade;&#125;int main() &#123; int n, low, high; scanf("%d", &amp;n); Student stu[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%s %s %d", stu[i].name, stu[i].id, &amp;stu[i].grade); &#125; scanf("%d %d", &amp;low, &amp;high); sort(stu, stu + n, cmp); // 是否存在满足条件的学生 bool exist = false; for (int i = 0; i &lt; n; i++) &#123; if (low &lt;= stu[i].grade &amp;&amp; stu[i].grade &lt;= high) &#123; printf("%s %s\n", stu[i].name, stu[i].id); exist = true; &#125; &#125; if (!exist) &#123; printf("NONE\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1075.PAT Judge (25 分)]]></title>
    <url>%2F2019%2F06%2F28%2Fpat-advanced-1075%2F</url>
    <content type="text"><![CDATA[The ranklist of PAT is generated from the status list, which shows the scores of the submissions. This time you are supposed to generate the ranklist for PAT. Input Specification:Each input file contains one test case. For each case, the first line contains 3 positive integers, N (≤10^4), the total number of users, K (≤5), the total number of problems, and M (≤10^5), the total number of submissions. It is then assumed that the user id’s are 5-digit numbers from 00001 to N, and the problem id’s are from 1 to K. The next line contains K positive integers p[i] (i=1, …, K), where p[i] corresponds to the full mark of the i-th problem. Then M lines follow, each gives the information of a submission in the following format: 1user_id problem_id partial_score_obtained where partial_score_obtained is either −1 if the submission cannot even pass the compiler, or is an integer in the range [0, p[problem_id]]. All the numbers in a line are separated by a space. Output Specification:For each test case, you are supposed to output the ranklist in the following format: 1rank user_id total_score s[1] ... s[K] where rank is calculated according to the total_score, and all the users with the same total_score obtain the same rank; and s[i] is the partial score obtained for the i-th problem. If a user has never submitted a solution for a problem, then “-“ must be printed at the corresponding position. If a user has submitted several solutions to solve one problem, then the highest score will be counted. The ranklist must be printed in non-decreasing order of the ranks. For those who have the same rank, users must be sorted in nonincreasing order according to the number of perfectly solved problems. And if there is still a tie, then they must be printed in increasing order of their id’s. For those who has never submitted any solution that can pass the compiler, or has never submitted any solution, they must NOT be shown on the ranklist. It is guaranteed that at least one user can be shown on the ranklist. Sample Input:123456789101112131415161718192021227 4 2020 25 25 3000002 2 1200007 4 1700005 1 1900007 2 2500005 1 2000002 2 200005 1 1500001 1 1800004 3 2500002 2 2500005 3 2200006 4 -100001 2 1800002 1 2000004 1 1500002 4 1800001 3 400001 4 200005 2 -100004 2 0 Sample Output:123451 00002 63 20 25 - 182 00005 42 20 0 22 -2 00007 42 - 25 - 172 00001 42 18 18 4 25 00004 40 15 0 25 - 分析：题目要求：给定N个用户、K个题目的满分以及M次提交，其中每次提交包含用户的ID、题号及相应的得分。 每道题用户可能会提交多次，因此，只记录其最高得分。 然后，按照总分从高到低排序，若总分相同，则按照获得满分的题目个数从大到小排序；若前两者均相等，则按照用户ID从小到大排序，输出排序后的排名信息。 若某用户从未提交过代码，或者没有能通过编译的提交，则该用户不出现在最后的排名中。 需要注意的地方： 1.题目给出的user_id和problem_id均从1开始； 2.编译不通过时，partial_score_obtained给出的结果为-1，但得分为0； 3.用户每个题目的得分，只记录最高分； 4.计算用户获得满分的题目个数时，需要考虑到同一道题用户可能会多次获得满分； 5.若某题用户未提交过，则该题的得分为-； 6.若某用户从未提交过代码，或者没有能通过编译的提交，则该用户不需要输出。 坑点：用户id需要提前初始化，否则，无法通过最后一个测试点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef struct Node &#123; int rank, id; int totalScore; // solve表示获得满分的题目个数 int solve; // 数组的值，-2表示未提交，-1表示编译错误 int s[5]; // 是否参加排名 bool status;&#125; User;bool cmp(User a, User b) &#123; if (a.totalScore != b.totalScore) &#123; return a.totalScore &gt; b.totalScore; &#125; if (a.solve != b.solve) &#123; return a.solve &gt; b.solve; &#125; return a.id &lt; b.id;&#125;int main() &#123; int k, n, m; scanf("%d %d %d", &amp;n, &amp;k, &amp;m); int p[k]; for (int i = 0; i &lt; k; i++) &#123; scanf("%d", &amp;p[i]); &#125; User user[n]; // 初始化 for (int i = 0; i &lt; n; i++) &#123; user[i].id = i; user[i].rank = 0; user[i].totalScore = 0; user[i].solve = 0; for (int j = 0; j &lt; k; j++) &#123; // -2表示未提交 user[i].s[j] = -2; &#125; user[i].status = false; &#125; int userId, problemId, score; for (int i = 0; i &lt; m; i++) &#123; scanf("%d %d %d", &amp;userId, &amp;problemId, &amp;score); userId--; problemId--; user[userId].id = userId + 1; if (score &gt; user[userId].s[problemId]) &#123; // 当提交结果，编译通过时 if (score &gt;= 0) &#123; // 计算用户的总分 user[userId].totalScore += score; if (user[userId].s[problemId] &gt; 0) &#123; user[userId].totalScore -= user[userId].s[problemId]; &#125; // 至少有一次编译通过，则参加排名 user[userId].status = true; &#125; // 计算用户得满分的题目个数，score &gt; user[userId].s[problemId]保证solve不会重复累加 if (score == p[problemId]) &#123; user[userId].solve++; &#125; // 更新题目的最高得分 user[userId].s[problemId] = score; &#125; &#125; // 排名 sort(user, user + n, cmp); user[0].rank = 1; for (int i = 1; i &lt; n; i++) &#123; if (user[i].totalScore == user[i - 1].totalScore) &#123; user[i].rank = user[i - 1].rank; &#125; else &#123; user[i].rank = i + 1; &#125; &#125; for (int i = 0; i &lt; n &amp;&amp; user[i].status; i++) &#123; printf("%d %05d %d", user[i].rank, user[i].id, user[i].totalScore); for (int j = 0; j &lt; k; j++) &#123; // 该题未提交 if (user[i].s[j] == -2) &#123; printf(" -"); &#125; else if (user[i].s[j] == -1) &#123; // 提交过，但编译错误 printf(" 0"); &#125; else &#123; printf(" %d", user[i].s[j]); &#125; &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1055.The World's Richest (25 分)]]></title>
    <url>%2F2019%2F06%2F26%2Fpat-advanced-1055%2F</url>
    <content type="text"><![CDATA[Forbes magazine publishes every year its list of billionaires based on the annual ranking of the world’s wealthiest people. Now you are supposed to simulate this job, but concentrate only on the people in a certain range of ages. That is, given the net worths of Npeople, you must find the M richest people in a given range of their ages. Input Specification:Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤10^5) - the total number of people, and K (≤10^3) - the number of queries. Then N lines follow, each contains the name (string of no more than 8 characters without space), age (integer in (0, 200]), and the net worth (integer in [−10^6,10^6]) of a person. Finally there are K lines of queries, each contains three positive integers: M (≤100) - the maximum number of outputs, and [Amin, Amax] which are the range of ages. All the numbers in a line are separated by a space. Output Specification:For each query, first print in a line Case #X: where X is the query number starting from 1. Then output the M richest people with their ages in the range [Amin, Amax]. Each person’s information occupies a line, in the format 1Name Age Net_Worth The outputs must be in non-increasing order of the net worths. In case there are equal worths, it must be in non-decreasing order of the ages. If both worths and ages are the same, then the output must be in non-decreasing alphabetical order of the names. It is guaranteed that there is no two persons share all the same of the three pieces of information. In case no one is found, output None. Sample Input:123456789101112131415161712 4Zoe_Bill 35 2333Bob_Volk 24 5888Anny_Cin 95 999999Williams 30 -22Cindy 76 76000Alice 18 88888Joe_Mike 32 3222Michael 5 300000Rosemary 40 5888Dobby 24 5888Billy 24 5888Nobody 5 04 15 454 30 354 5 951 45 50 Sample Output:12345678910111213141516Case #1:Alice 18 88888Billy 24 5888Bob_Volk 24 5888Dobby 24 5888Case #2:Joe_Mike 32 3222Zoe_Bill 35 2333Williams 30 -22Case #3:Anny_Cin 95 999999Michael 5 300000Alice 18 88888Cindy 76 76000Case #4:None 分析：题目要求：给定N个人的姓名、年龄以及财富。按照财富递减的顺序排序。 若财富相同，则按照年龄从小到大排序。若年龄也相同，则按照姓名字典序从小到大排序。 然后，进行K次查询，每次查询给定需要输出的个数M、年龄的取值范围[Amin,Amax]，输出满足条件的人的姓名、年龄和财富。若不存在满足条件的人，则输出None。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct People &#123; char name[9]; int age; int netWorth;&#125;;bool cmp(People a, People b) &#123; if (a.netWorth != b.netWorth) &#123; return a.netWorth &gt; b.netWorth; &#125; if (a.age != b.age) &#123; return a.age &lt; b.age; &#125; return strcmp(a.name, b.name) &lt; 0;&#125;int main() &#123; int n, k; scanf("%d %d", &amp;n, &amp;k); People people[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%s %d %d", people[i].name, &amp;people[i].age, &amp;people[i].netWorth); &#125; int m, min, max; sort(people, people + n, cmp); for (int i = 0; i &lt; k; i++) &#123; scanf("%d %d %d", &amp;m, &amp;min, &amp;max); printf("Case #%d:\n", i + 1); int count = 0; for (int j = 0; j &lt; n; j++) &#123; if (min &lt;= people[j].age &amp;&amp; people[j].age &lt;= max) &#123; printf("%s %d %d\n", people[j].name, people[j].age, people[j].netWorth); count++; if (count &gt;= m) &#123; break; &#125; &#125; &#125; if (count == 0) &#123; printf("None\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript访问HTML元素]]></title>
    <url>%2F2019%2F06%2F25%2Fjs-get-element%2F</url>
    <content type="text"><![CDATA[在JavaScript中，要想访问HTML元素，可以使用下面几种方法。 12345document.getElementById(id)document.getElementsByTagName(tagName)document.getElementsByClassName(className)document.querySelector(selector)document.querySelectorAll(selector) getElementById()该方法返回带有指定ID的元素。 12// 访问id为main-div的元素document.getElementById("main-div"); getElementsByTagName()该方法返回带有指定标签名的所有元素，返回值类型为HTMLCollection。 12// 访问标签名为div的所有元素document.getElementsByTagName("div"); getElementsByClassName()该方法返回带有指定class属性值的所有元素，返回值类型为HTMLCollection。 12// 访问类名为c-red的所有元素document.getElementsByClassName("c-red"); querySelector()该方法返回带有指定CSS样式选择器的第一个元素。 12// 访问类名为c-red的第一个元素document.querySelector(".c-red"); querySelectorAll()该方法返回带有指定CSS样式选择器的所有元素，返回值类型为NodeList。 12// 访问类名为c-red的所有元素document.querySelectorAll(".c-red"); 示例 下面是一段简单的html片段。 JavaScriptJavaC++PythonRubySwift 123456789101112&lt;div id="main-div"&gt; &lt;div class="c-red"&gt; &lt;p id="demo-p"&gt;JavaScript&lt;/p&gt; &lt;p&gt;Java&lt;/p&gt; &lt;p&gt;C++&lt;/p&gt; &lt;/div&gt; &lt;div class="c-red c-green"&gt; &lt;p&gt;Python&lt;/p&gt; &lt;p&gt;Ruby&lt;/p&gt; &lt;p&gt;Swift&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 访问ID为demo-p的元素 &nbsp; &nbsp;访问标签名为p的所有元素 &nbsp;访问类名为c-red的所有元素 &nbsp;访问类名为c-red的第一个元素 访问类名为c-red的所有元素（querySelectorAll） window.onload = function() { f("btn-id","demo-p",1); f("btn-tag","p",2); f("btn-class-name","c-red",3); f("btn-query",".c-red",4); f("btn-query-all",".c-red",5); }; function f(btnSelector,selector,type) { var oBtn = document.getElementById(btnSelector); oBtn.onclick = function() { var oDiv1; if(type == 1) { oDiv1 = document.getElementById(selector); alert("元素类型："+oDiv1+"\nid："+oDiv1.getAttribute("id")+"\n文本内容："+oDiv1.firstChild.nodeValue+"\n访问方式：document.getElementById(\""+selector+"\")"); } else if(type == 2) { oDiv1 = document.getElementsByTagName(selector); alert("元素类型："+oDiv1+"\ntag："+selector+"\n访问方式：document.getElementsByTagName(\""+selector+"\")"); } else if(type == 3) { oDiv1 = document.getElementsByClassName(selector); alert("元素类型："+oDiv1+"\nclass："+selector+"\n访问方式：document.getElementsByClassName(\""+selector+"\")"); } else if(type == 4) { oDiv1 = document.querySelector(selector); alert("元素类型："+oDiv1+"\ncss选择器："+selector+"\n第一个子元素中的文本内容："+oDiv1.firstChild.firstChild.nodeValue+"\n访问方式：document.querySelector(\""+selector+"\")"); } else { oDiv1 = document.querySelectorAll(selector); alert("元素类型："+oDiv1+"\ncss选择器："+selector+"\n选中元素个数："+oDiv1.length+"\n访问方式：document.querySelectorAll(\""+selector+"\")"); } }; }]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1028.List Sorting (25 分)]]></title>
    <url>%2F2019%2F06%2F24%2Fpat-advanced-1028%2F</url>
    <content type="text"><![CDATA[Excel can sort records according to any column. Now you are supposed to imitate this function. Input Specification:Each input file contains one test case. For each case, the first line contains two integers N (≤$10^5$) and C, where N is the number of records and C is the column that you are supposed to sort the records with. Then N lines follow, each contains a record of a student. A student’s record consists of his or her distinct ID (a 6-digit number), name (a string with no more than 8 characters without space), and grade (an integer between 0 and 100, inclusive). Output Specification:For each test case, output the sorting result in N lines. That is, if C = 1 then the records must be sorted in increasing order according to ID’s; if C= 2 then the records must be sorted in non-decreasing order according to names; and if C = 3 then the records must be sorted in non-decreasing order according to grades. If there are several students who have the same name or grade, they must be sorted according to their ID’s in increasing order. Sample Input 1:12343 1000007 James 85000010 Amy 90000001 Zoe 60 Sample Output 1:123000001 Zoe 60000007 James 85000010 Amy 90 Sample Input 2:123454 2000007 James 85000010 Amy 90000001 Zoe 60000002 James 98 Sample Output 2:1234000010 Amy 90000002 James 98000007 James 85000001 Zoe 60 Sample Input 3:123454 3000007 James 85000010 Amy 90000001 Zoe 60000002 James 90 Sample Output 3:1234000001 Zoe 60000007 James 85000002 James 90000010 Amy 90 分析：题目要求：给定N个学生的ID、姓名和成绩，根据给定的参数C，进行不同的排序，输出排序后的结果。 当C==1时，按照ID从小到大排序； 当C==2时，按照姓名字典序从小到大排序；若姓名相同，则按照ID从小到大排序； 当C==3时，按照成绩从低到高排序；若成绩相同，则按照ID从小到大排序。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct Student &#123; char id[7]; char name[9]; int grade;&#125;;int c = 0;bool cmp(struct Student a, struct Student b) &#123; if (c == 1) &#123; return strcmp(a.id, b.id) &lt; 0; &#125; if (c == 2) &#123; int s = strcmp(a.name, b.name); if (s == 0) &#123; return strcmp(a.id, b.id) &lt; 0; &#125; return s &lt; 0; &#125; if (a.grade == b.grade) &#123; return strcmp(a.id, b.id) &lt; 0; &#125; return a.grade &lt; b.grade;&#125;int main() &#123; int n; scanf("%d %d", &amp;n, &amp;c); struct Student stu[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%s %s %d", stu[i].id, stu[i].name, &amp;stu[i].grade); &#125; sort(stu, stu + n, cmp); for (int i = 0; i &lt; n; i++) &#123; printf("%s %s %d\n", stu[i].id, stu[i].name, stu[i].grade); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于《中国太阳》这篇小说]]></title>
    <url>%2F2019%2F06%2F21%2Freading-note-china-sun%2F</url>
    <content type="text"><![CDATA[《中国太阳》是刘慈欣发表于2002年的一篇短篇小说，获得了2002年度（第14届）银河奖。 何为中国太阳“这是一个面积达三万平方千米的反射镜，它在三万六千千米高的同步轨道上向地球反射阳光。从地面看上去，天空中像多了个太阳。” 中国太阳可以以多种方式影响天气，改变目标区域的气候。 故事背景水娃，一个土生土长的农村娃，只上过三年小学。他出生和长大的村庄，常年处于干旱中，只靠着水窖中积下的一点雨水过活。水娃家没钱修水泥窖，用的是土水窖，水一到大热天就臭了。以往，这臭水热开了还能喝，就是苦点儿涩点儿，但这年夏天，那水热开了喝都拉肚子。为了喝点不苦的水、攒钱盖房娶媳妇，水娃就此离开了生活多年的村庄。 人生目标的转变1.人生第一个目标：喝点不苦的水，挣点钱。 职业：矿区工人，引路人：同村国强，转折事件：国强之死 2.人生第二个目标：到灯更多、水更甜的城里，挣更多的钱。 职业：省城擦鞋匠，引路人：邻村二宝，转折事件：中国太阳工程正式启动 3.人生第三个目标：到更大的城市，见更大的世面，挣更多的钱。 前往北京，引路人：室友庄宇博士 4.人生第四个目标：成为一个北京人。 职业：高空清洁工，转折事件：再遇庄宇 5.人生第五个目标：飞向太空擦太阳。 职业：中国太阳上的镜面农夫，引路人：中国太阳工程首席科学家庄宇，转折事件：与史蒂芬·霍金的交往 6.人生第六个目标：飞向星海，把人类的目光重新引向宇宙深处。 引路人：史蒂芬·霍金 佳句摘抄1.现代社会充满着机遇，满天都飞着金鸟儿，说不定哪天你一伸手就抓住一只，前提是你得拿自己当回事儿。 2.有些东西你只有在看见后才知道是什么样儿，凭想象是绝对想不出来的。 3.事情得从高处才能看清楚。 4.站在这么高的地方，人想的事情肯定不一样…… 5.有人满足于老婆孩子热炕头，从不向与己无关的尘世之外扫一眼；有的人则用尽全部生命，只为看一眼人类从未见过的事物。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1012.The Best Rank (25 分)]]></title>
    <url>%2F2019%2F06%2F20%2Fpat-advanced-1012%2F</url>
    <content type="text"><![CDATA[To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: C - C Programming Language, M - Mathematics (Calculus or Linear Algrbra), and E - English. At the mean time, we encourage students by emphasizing on their best ranks – that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student. For example, The grades of C, M, E and A - Average of 4 students are given as the following: 12345StudentID C M E A310101 98 85 88 90310102 70 95 88 84310103 82 87 94 88310104 91 91 91 91 Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average. Input Specification:Each input file contains one test case. Each case starts with a line containing 2 numbers N and M (≤2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of C, M and E. Then there are M lines, each containing a student ID. Output Specification:For each of the M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space. The priorities of the ranking methods are ordered as A &gt; C &gt; M &gt; E. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority. If a student is not on the grading list, simply output N/A. Sample Input:1234567891011125 6310101 98 85 88310102 70 95 88310103 82 87 94310104 91 91 91310105 85 90 90310101310102310103310104310105999999 Sample Output:1234561 C1 M1 E1 A3 AN/A 分析：题目要求：给定N个学生，及其C语言（C）、数学（M）、英语（E）三门课的成绩，对包括平均分（A）在内的四个成绩分别进行排名。 给定M个学生的id，求他们的最好排名及对应的课程（或者平均分） 当有多个科目取得相同的最好排名时，按照A &gt; C &gt; M &gt; E的顺序，输出其中优先级最大的课程。 若学生id不存在，则输出N/A。 需要注意的地方：1.平均分要四舍五入；2.若分数相同，则排名并列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;struct Student &#123; int id; // 0-A,1-C,2-M,3-E int score[4]; int rank[4]; int best;&#125;;int flag = 0;// 快速判断id是否存在int exists[1000000];char course[5] = &#123; 'A', 'C', 'M', 'E' &#125;;bool cmp(struct Student s1, struct Student s2) &#123; return s1.score[flag] &gt; s2.score[flag];&#125;int main() &#123; int n, m, id; scanf("%d %d", &amp;n, &amp;m); struct Student stu[n]; // 输入 for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;stu[i].id); int sum = 0; for (int j = 1; j &lt;= 3; j++) &#123; scanf("%d", &amp;stu[i].score[j]); sum += stu[i].score[j]; &#125; // 平均成绩四舍五入 stu[i].score[0] = sum / 3.0 + 0.5; &#125; // 按照不同的科目分别排序 for (flag = 0; flag &lt; 4; flag++) &#123; sort(stu, stu + n, cmp); stu[0].rank[flag] = 1; for (int j = 1; j &lt; n; j++) &#123; stu[j].rank[flag] = j + 1; // 若分数相同，则排名并列 if (stu[j].score[flag] == stu[j - 1].score[flag]) &#123; stu[j].rank[flag] = stu[j - 1].rank[flag]; &#125; &#125; &#125; // 计算最佳排名 for (int i = 0; i &lt; n; i++) &#123; exists[stu[i].id] = i + 1; int rank = n + 1; for (int j = 0; j &lt; 4; j++) &#123; if (stu[i].rank[j] &lt; rank) &#123; rank = stu[i].rank[j]; stu[i].best = j; &#125; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;id); int index = exists[id]; if (index) &#123; index -= 1; int best = stu[index].best; printf("%d %c\n", stu[index].rank[best], course[best]); &#125; else &#123; printf("N/A\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于《流浪地球》这篇小说]]></title>
    <url>%2F2019%2F06%2F17%2Freading-note-the-wandering-earth%2F</url>
    <content type="text"><![CDATA[《流浪地球》是一篇精彩宏大的小说，这里记录下小说中的一些设定及情节。 故事背景天体物理学家发现太阳内部氢转化为氦的速度加快，氦元素的聚变将在很短的时间内传遍整个太阳内部，由此产生一次叫“氦闪”的剧烈爆炸。之后，太阳将变为一颗巨大但暗淡的红巨星。而在氦闪爆发时，地球将被气化。这一切将在四百年内发生。人类唯一的生路是向外太空恒星际移民。而照人类目前的技术力量，全人类移民唯一可行的目标是半人马座比邻星，这是距地球最近的恒星，有四点三光年的路程。 人类的逃亡计划人类的逃亡分为五步： 第一步，刹车时代。用地球发动机使地球停止自转，使发动机喷口对准地球运行的反方向； 第二步，逃逸时代。全功率开动地球发动机，使地球加速到逃逸速度，飞出太阳系； 第三步，流浪时代I（加速）。在外太空继续加速，飞向比邻星； 第四步，流浪时代II（减速）。在中途使地球重新自转，掉转发动机方向，开始减速； 第五步，新太阳时代。地球泊入比邻星轨道，成为这颗恒星的行星。 整个移民过程将延续两千五百年时间，一百代人。 刹车时代人类通过“记忆遗传技术”使得小娃娃具备了成人的智力水平，因而在四个世纪内就造出了地球发动机。 地球发动机利用重元素聚变，以岩石为燃料，安装在亚洲和美洲大陆上，因为只有这两个大陆完整坚实的板块结构才能承受发动机对地球巨大的推力。地球发动机共有一万两千台，分布在亚洲和美洲大陆的各个平原上。 地球自转刹车用了四十二年。 关于地球的卫星——月亮的处理： 人类带不走月球，就在月球上也安装了行星发动机，把它推离地球轨道，以免在地球加速时相撞。 逃逸时代人类搬入地下城。 学校教育集中在理工科，艺术和哲学之类的教育被压缩到最少——人类没有这份闲心了。 对于这一时代人类的心理状态和精神生活，大刘是这样描述的： 在这个时代，死亡的威胁和逃生的欲望压倒了一切……对于爱情这类东西，他们只是用余光瞥一下而已，就像赌徒在盯着轮盘的间隙抓住几秒钟喝口水一样。 由于环境的严酷，法律规定每三对新婚配偶中只有一对有生育权，抽签决定。 地球发动机给了地球很小的加速度，使得地球在绕日运动时，逐渐加速。地球绕太阳运行的速度越快，其运行轨道越扁——近日点距离保持不变，远日点越来越远。地球绕日运行的第十五圈，远日点会到达木星轨道，地球将与木星在几乎相撞的距离上擦身而过。在木星巨大引力的拉动下，地球将最终达到逃逸速度。 叛乱当地球离开木星后，部分人类对太阳氦闪产生了怀疑。通过对太阳的探测，他们认定太阳氦闪是一个人为编造的超级骗局，因而打算推翻联合政府，控制地球发动机，返回原来的地球轨道。叛军所到之处，人民群起响应。 最终，叛军取得了胜利，地球驾驶台中联合政府方剩下的五千多人全部被冻死。恰恰就是在这个时候，太阳氦闪爆发了。 流浪时代地球发动机将不间断地开动五百年，到时地球将加速至光速的千分之五，然后地球将以这个速度滑行一千三百年，走完三分之二的航程，然后掉转发动机的方向，开始长达五百年的减速。地球将在两千四百年后达到比邻星，再用一百年时间泊入这颗恒星的轨道，成为它的一颗行星。 结语故事很有传统的家国情怀。 首先，通过主角的小学老师黎星之口，道出了只顾自己跑的“飞船派”的不足之处，肯定了“地球派”带着地球一起走的做法。 然后，通过主角爷爷及主角之口，反复表达了人类对未来的向往：“啊，地球，我的流浪地球啊……”。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年“锐捷网络杯”华中区高校研究生程序设计大赛K.A good game]]></title>
    <url>%2F2019%2F06%2F02%2Fhbppc-2019-problem-k-a-good-game%2F</url>
    <content type="text"><![CDATA[Bigbrother is a cute boy who likes to play cards. One day, he gets N cards and every of them has a number $V_i$. Now, he wants to play a game with you. He has M operations. In the k-th operation, the sum of $V_i$ between intervals [L,R] is S, k×S is the k-th score. You can sort the M operations and get the maximum sum of scores. InputThere are multiple tests. The first line contains integer T(1≤T≤10). The second line contains integer N, M(1 ≤ N,M ≤ 100000) The next line contain N numbers $V_i$ (1 ≤$V_i$ ≤ 1000) . The following $M​$ lines, each line contains two numbers, L,R(1 ≤ L,R ≤ N). OutputThere are T lines. In every line print a single integer — the answer to the problem. Sample Input12345614 31 2 3 41 22 41 4 Sample Output151 分析题目大意：给定N张牌，每张牌的权值为$V_i$。对这些牌进行M次操作，第k次操作的得分为$k \times S$，其中$S = \sum_{i=L}^{R}V_i$，L和R由输入给出，表示第L和R张牌。对M次操作的先后顺序进行调换，使得总得分最高，输出最高总得分。 思路：前缀和 加 贪心。 输入$V_i$时，计算每张牌到第1张牌之间的权值和span[i]。 然后通过对应的权值之和，计算某一操作的得分S。 对所有的S进行升序排列，使得较大的S位于序列的后面，从而使得总得分最高。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int t; scanf("%d", &amp;t); while (t--) &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); int arr[n]; // span[i]存储第i+1张牌到第1张牌之间的权值和 int span[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); if (i == 0) &#123; span[i] = arr[i]; &#125; else &#123; // 前缀和 span[i] = span[i - 1] + arr[i]; &#125; &#125; int left, right; // 存储单个操作的得分S long long scores[m]; for (int i = 0; i &lt; m; i++) &#123; scanf("%d %d", &amp;left, &amp;right); if (left == 1) &#123; scores[i] = span[right - 1]; &#125; else &#123; scores[i] = span[right - 1] - span[left - 2]; &#125; &#125; // 对所有的S进行升序排列 sort(scores, scores + m); // 最大总得分 long long sum = 0; for (int i = 0; i &lt; m; i++) &#123; sum += (i + 1) * scores[i]; &#125; printf("%lld\n", sum); &#125; return 0;&#125; 本题需要注意的几个地方：$$\max(S) = \max(V_i) \times \max(N) = 10^5 \times 10^3 = 10^8$$ $$max(sum) = max(S) \times (1+2+\dots+\max(N)) = 10^8 \times \frac{10^5 \times (10^5 + 1)}{2} ≈ 5\times 10^{17}$$ 因此，总得分sum必须用long long存储。 又因为$\max(k \times S) = 10^5 \times 10^8 = 10^{13}$，因此S必须采用long long存储，否则，$ k \times S$可能会溢出。]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 946.验证栈序列]]></title>
    <url>%2F2019%2F06%2F01%2Fleetcode-946-validate-stack-sequences%2F</url>
    <content type="text"><![CDATA[给定 pushed 和 popped 两个序列，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。 示例 1： 12345输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 示例 2： 123输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。 提示： 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed 是 popped 的排列。 解决方案 思路：模拟进出栈操作。 对pushed中的每一个元素执行如下操作： 1.将该元素进栈； 2.当栈不为空时，判断栈顶元素与popped中的当前元素popped[j]是否相等。若相等，则执行出栈操作，且j++。循环执行该操作，直到条件不满足为止。 待上述操作执行完后，判断栈是否为空。若栈空，则表示给定的栈序列是合法的；否则，则不合法。 12345678910111213141516171819class Solution &#123; public boolean validateStackSequences(int[] pushed, int[] popped) &#123; // 用一个数组模拟栈的操作 int[] stack = new int[pushed.length]; // 栈的实际长度 int len = 0; for (int i = 0, j = 0; i &lt; pushed.length; i++) &#123; // 1.进栈 stack[len++] = pushed[i]; // 2.栈不为空时，循环判断栈顶元素与popped的当前元素是否相等 while(len != 0 &amp;&amp; stack[len-1] == popped[j]) &#123; // 出栈 len--; j++; &#125; &#125; return len == 0; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于研会竞选这件事]]></title>
    <url>%2F2019%2F05%2F30%2Fwhu-cs-graduate-union-election%2F</url>
    <content type="text"><![CDATA[2019年5月30日，武汉大学计算机学院举办了第十九届研究生代表大会，我成为了计算机学院第十九届研究生会主席团的一名成员。 为什么要参加研会竞选？学院研究生会共七个部门，原本以为每个部门要推荐一个人去竞选。我们体育部分管主席起先中意的是另一个同学。老实讲，我也觉得他很合适。但是，合适并不意味着愿意。那个哥们不想去竞选主席，理由是二年级可能会去交流。然后，分管主席找上了我，遂无奈接下了这个任务。 今年学校改革，我们院只能有5个主席（一正四副，以前是7个主席），报名的只有6个人，因此变成了6选5。 竞选心路历程5月29日，也就是竞选的前一天。当天下午在学院报告厅彩排，我发现其他候选人的PPT和演讲稿都比我要充实丰富。这时候，我已经感觉到自己可能会被刷掉。 彩排完毕，分管主席肖学长也来了。他和我说，其实他希望我不要选上，所以也没有让我把PPT和演讲稿弄的特别充实。因为他说一旦选上，会比较忙，耽误自己的科研。其实，我也是这么想，所以也一直对室友说，希望自己被刷掉。 当然，人是比较矛盾的。我既希望自己被刷掉，又不想自己被刷掉。因为如果是拼尽了全力，仍然被刷下来了，说明自己能力不行。此外，我当时想的是，本科的时候没参加过学生会，自己性格又偏内向。如果选上了，能锻炼下自己各方面的能力，对自己是有帮助的。 另外，还有个小插曲。因为工作人员要控制PPT的播放，所以他们需要我在第二天正式竞选的时候交一张纸质版的演讲稿。那天晚上我回去得比较晚，打印店已经关门了，就想着30日早上打印应该也来得及。事实上，30日早上的时候，时间根本不够，到学院已经将近八点二十分了（九点正式开始，八点半签到）。彼时，学院旁边的打印店还没开门，我还没换正装。于是，决定先去换正装，换完差不多八点半。 当时，我比较紧张，以为自己需要脱稿演讲了（当时我手头有一张纸质版的演讲稿，是我29日彩排前打印的）。人越是紧张，越是容易忘。幸好，研代会前半部分，是学校和学院的领导们讲话。这时候，另一个同学已经到了学院，他实验室有打印机，我让他帮我打印了。 这件事，也算是对我的一个警告：凡事要留有余地。当一个“笨人”，每件事情作好最坏的打算，留出足够的周旋时间。 竞选结果统计我的得票为60+（应到投票人为114，实际投票人为100），排在第四位，成功当选主席团。 从左至右依次是：刘江、万言、赵东星、张士伟、贺巩山、高航。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1015.德才论/PAT甲级 1062.Talent and Virtue (25 分)]]></title>
    <url>%2F2019%2F05%2F29%2Fpat-basic-1015%2F</url>
    <content type="text"><![CDATA[宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。” 现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式：输入第一行给出 3 个正整数，分别为：N（≤10^5），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。 随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。 输出格式：输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 输入样例：12345678910111213141514 60 8010000001 64 9010000002 90 6010000011 85 8010000003 85 8010000004 80 8510000005 82 7710000006 83 7610000007 90 7810000008 75 7910000009 59 9010000010 88 4510000012 80 10010000013 90 9910000014 66 60 输出样例：123456789101112131210000013 90 9910000012 80 10010000003 85 8010000011 85 8010000004 80 8510000007 90 7810000006 83 7610000005 82 7710000002 90 6010000014 66 6010000008 75 7910000001 64 90 分析：按照题目要求，可以建立如下的结构体： 12345678910struct Student &#123; // 准考证号 int permitNo; // 德分 int personalityScore; // 才分 int abilityScore; // 所属类别，1表示才德全尽，2表示德胜才，3表示“才德兼亡”但尚有“德胜才”，4表示其他满足最低要求的考生 int level;&#125;; 然后进行相应的排序即可。 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;struct Student &#123; // 准考证号 int permitNo; // 德分 int personalityScore; // 才分 int abilityScore; // 所属类别 int level;&#125;;bool cmp(struct Student stu1, struct Student stu2) &#123; if (stu1.level != stu2.level) &#123; return stu1.level &lt; stu2.level; &#125; // 按总分排序 if (stu1.abilityScore + stu1.personalityScore != stu2.abilityScore + stu2.personalityScore) &#123; return stu1.abilityScore + stu1.personalityScore &gt; stu2.abilityScore + stu2.personalityScore; &#125; // 若总分相同，则按德分降序排列 if (stu1.personalityScore != stu2.personalityScore) &#123; return stu1.personalityScore &gt; stu2.personalityScore; &#125; // 若德分并列，则按准考证号升序 return stu1.permitNo &lt; stu2.permitNo;&#125;void print(struct Student stu[], int len) &#123; for (int i = 0; i &lt; len; i++) &#123; printf("%d %d %d\n", stu[i].permitNo, stu[i].personalityScore, stu[i].abilityScore); &#125;&#125;int main() &#123; int n, low, high, m = 0; scanf("%d %d %d", &amp;n, &amp;low, &amp;high); struct Student stu[n]; int permitNo, personalityScore, abilityScore; for (int i = 0; i &lt; n; i++) &#123; scanf("%d %d %d", &amp;permitNo, &amp;personalityScore, &amp;abilityScore); if (personalityScore &lt; low || abilityScore &lt; low) &#123; continue; &#125; stu[m].permitNo = permitNo; stu[m].abilityScore = abilityScore; stu[m].personalityScore = personalityScore; // 才德全尽 if (personalityScore &gt;= high &amp;&amp; abilityScore &gt;= high) &#123; stu[m].level = 1; &#125; else if (personalityScore &gt;= high) &#123; // 德胜才 stu[m].level = 2; &#125; else if (abilityScore &gt;= high) &#123; stu[m].level = 4; &#125; else &#123; // “才德兼亡”但尚有“德胜才” if (personalityScore &gt;= abilityScore) &#123; stu[m].level = 3; &#125; else &#123; stu[m].level = 4; &#125; &#125; m++; &#125; // 排序 sort(stu, stu + m, cmp); // 输出 printf("%d\n", m); print(stu, m); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 889.根据前序和后序遍历构造二叉树]]></title>
    <url>%2F2019%2F05%2F29%2Fleetcode-889-construct-binary-tree-from-preorder-and-postorder-traversal%2F</url>
    <content type="text"><![CDATA[返回与给定的前序和后序遍历匹配的任何二叉树。 pre 和 post 遍历中的值是不同的正整数。 示例： 12输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]输出：[1,2,3,4,5,6,7] 提示： 1 &lt;= pre.length == post.length &lt;= 30 pre[] 和 post[] 都是 1, 2, ..., pre.length 的排列 每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。 解决方案 思路：仅知道先序遍历和后序遍历的结果，满足条件的二叉树并不唯一。一种直观的方法是：按照先序遍历和后序遍历的特点，先构造根结点root，然后找出左子树left和右子树right的起止范围，对它们递归执行该过程即可。 12345678910111213141516171819202122232425262728293031323334353637/*public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;*/class Solution &#123; public TreeNode constructFromPrePost(int[] pre, int[] post) &#123; return constructFromPrePost(pre, post, 0, pre.length-1, 0, post.length-1); &#125; public TreeNode constructFromPrePost(int[] pre, int[] post, int preFrom, int preTo, int postFrom, int postTo) &#123; // 1.范围判断，当给定的范围不合法时，返回null if(preFrom &gt; preTo || postFrom &gt; postTo) &#123; return null; &#125; // 2.构造根结点root TreeNode root = new TreeNode(pre[preFrom]); // 3.若仅有一个元素，则直接返回，避免再次执行递归操作 if(preFrom == preTo) &#123; return root; &#125; // 4.计算左子树的元素个数,i=左子树元素个数-1 int i = 0; while(pre[preFrom+1] != post[postFrom + i]) &#123; i++; &#125; // 5.递归构造左右子树 root.left = constructFromPrePost(pre, post, preFrom+1, preFrom+i+1, postFrom, postFrom+i); root.right = constructFromPrePost(pre,post, preFrom+i+2, preTo, postFrom+i+1, postTo-1); return root; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 106.从中序与后序遍历序列构造二叉树]]></title>
    <url>%2F2019%2F05%2F29%2Fleetcode-106-construct-binary-tree-from-inorder-and-postorder-traversal%2F</url>
    <content type="text"><![CDATA[根据一棵树的中序遍历与后序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12中序遍历 inorder = [9,3,15,20,7]后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 解决方案 思路：按照中序遍历和后序遍历的特点，先构造根结点root，然后找出左子树left和右子树right的起止范围，对它们递归执行该过程即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;*/class Solution &#123; public TreeNode buildTree(int[] inorder, int[] postorder) &#123; //return buildTree(inorder,postorder,0,postorder.length-1,postorder.length); return buildTree(inorder,postorder,0,inorder.length-1,0,postorder.length-1); &#125; /*public TreeNode buildTree(int[] inorder, int[] postorder, int inStart, int postEnd, int length) &#123; if(length == 0) &#123; return null; &#125; TreeNode root = new TreeNode(postorder[postEnd]); int i=0; while(root.val != inorder[inStart + i]) &#123; i++; &#125; root.left = buildTree(inorder, postorder, inStart, postEnd - (length - i), i); root.right = buildTree(inorder, postorder, inStart + i + 1, postEnd-1, length-i-1); return root; &#125;*/ public TreeNode buildTree(int[] inorder, int[] postorder, int inFrom, int inTo, int postFrom, int postTo) &#123; if(inFrom &gt; inTo || postFrom &gt; postTo) &#123; return null; &#125; // 构造根结点root TreeNode root = new TreeNode(postorder[postTo]); // 寻找中序遍历中根结点所在的位置，i表示当前状态下左子树的元素个数 int i=0; while(root.val != inorder[inFrom + i]) &#123; i++; &#125; // 对左右子树递归执行该过程 /* ------------------------------------------------------------------------- inorder | left root right index | inFrom ... inFrom+i-1 inFrom+i inFrom+i+1 ... inTo ------------------------------------------------------------------------- postorder | left right root index | postFrom ... postFrom+i-1 postFrom+i ...postTo-1 postTo ------------------------------------------------------------------------- */ root.left = buildTree(inorder, postorder, inFrom, inFrom + i - 1, postFrom, postFrom + i - 1); root.right = buildTree(inorder, postorder, inFrom + i + 1, inTo, postFrom + i, postTo - 1); return root; &#125; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 105.从前序与中序遍历序列构造二叉树]]></title>
    <url>%2F2019%2F05%2F29%2Fleetcode-105-construct-binary-tree-from-preorder-and-inorder-traversal%2F</url>
    <content type="text"><![CDATA[根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 解决方案 思路：按照先序遍历和中序遍历的特点，先构造根结点root，然后找出左子树left和右子树right的起止范围，对它们递归执行该过程即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/*public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;*/class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; return buildTree(preorder,inorder,0,preorder.length-1, 0,inorder.length-1); &#125; /*public TreeNode buildTree(int[] preorder, int[] inorder, int preStart,int inStart,int length) &#123; if(length == 0) &#123; return null; &#125; TreeNode root = new TreeNode(preorder[preStart]); if(length == 1) &#123; return root; &#125; int i=0; while(root.val != inorder[inStart + i]) &#123; i++; &#125; root.left = buildTree(preorder,inorder,preStart+1,inStart,i); root.right = buildTree(preorder,inorder,preStart+i+1,inStart+i+1,length-i-1); return root; &#125;*/ public TreeNode buildTree(int[] preorder, int[] inorder, int preFrom, int preTo, int inFrom, int inTo) &#123; if(preFrom &gt; preTo || inFrom &gt; inTo) &#123; return null; &#125; // 构造根结点root TreeNode root = new TreeNode(preorder[preFrom]); if(preFrom == preTo) &#123; return root; &#125; // 寻找中序遍历中根结点所在的位置，i表示当前状态下左子树的元素个数 int i=0; while(root.val != inorder[inFrom + i]) &#123; i++; &#125; // 对左右子树递归执行该过程 /* ------------------------------------------------------------------------- preorder | root left right index | preFrom preFrom+1 ... preFrom+i preFrom+i+1 ... preTo ------------------------------------------------------------------------- inorder | left root right index | inFrom ... inFrom+i-1 inFrom+i inFrom+i+1 ... inTo ------------------------------------------------------------------------- */ root.left = buildTree(preorder,inorder, preFrom+1,preFrom+i,inFrom,inFrom+i-1); root.right = buildTree(preorder,inorder, preFrom+i+1,preTo,inFrom+i+1,inTo); return root; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1008.先序遍历构造二叉树]]></title>
    <url>%2F2019%2F05%2F27%2Fleetcode-1008-construct-binary-search-tree-from-preorder-traversal%2F</url>
    <content type="text"><![CDATA[返回与给定先序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。 (回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &lt; node.val，而 node.right 的任何后代，值总 &gt; node.val。此外，先序遍历首先显示节点的值，然后遍历 node.left，接着遍历 node.right。） 示例： 1234567输入：[8,5,1,7,10,12]输出：[8,5,10,1,7,null,12] 8 / \ 5 10 / \ \ 1 7 12 提示： 1 &lt;= preorder.length &lt;= 100 先序 preorder 中的值是不同的。 解决方案方法一：利用先序遍历 思路：按照先序遍历的顺序，每次将preorder划分为根节点root、左子树left和右子树right三个部分，然后对left和right递归执行该过程。 12345678910111213141516171819202122232425262728293031/*public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;*/class Solution &#123; public TreeNode bstFromPreorder(int[] preorder) &#123; if(preorder == null) &#123; return null; &#125; return bstFromPreorder(preorder, 0, preorder.length - 1); &#125; // 按照先序遍历构造BST public TreeNode bstFromPreorder(int[] preorder, int low, int high) &#123; TreeNode root = null; if(low &lt;= high) &#123; root = new TreeNode(preorder[low]); // 寻找当前节点的右子树 int i = low + 1; while(i &lt;= high &amp;&amp; preorder[i] &lt;= root.val) &#123; i++; &#125; // low low+1 ... i-1 i ... high // root left right root.left = bstFromPreorder(preorder, low + 1, i - 1); root.right = bstFromPreorder(preorder, i, high); &#125; return root; &#125;&#125; 方法二：直接构造二叉搜索树 思路：按照先序遍历构造二叉搜索树，等价于按照给定的顺序，直接构造二叉搜索树。 123456789101112131415161718192021222324252627282930313233/*public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;*/class Solution &#123; public TreeNode bstFromPreorder(int[] preorder) &#123; if(preorder == null) &#123; return null; &#125; TreeNode root = null; // 将所有的元素依次插入到BST中 for(int val : preorder) &#123; root = insert(root, val); &#125; return root; &#125; // 将元素插入到BST中 public TreeNode insert(TreeNode root, int val) &#123; if(root == null) &#123; root = new TreeNode(val); return root; &#125; if(val &lt; root.val) &#123; root.left = insert(root.left, val); &#125; else if(val &gt; root.val) &#123; root.right = insert(root.right, val); &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 102.二叉树的层次遍历]]></title>
    <url>%2F2019%2F05%2F26%2Fleetcode-102-binary-tree-level-order-traversal%2F</url>
    <content type="text"><![CDATA[给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 解决方案 思路：使用队列。先将根结点root进队，在队列不为空时循环： 此时队列中的元素个数size即为二叉树中当前层的节点个数，循环执行size次如下操作：将队首元素出队，若其有左孩子，则将其左孩子进队。若其还有右孩子，再将右孩子也进队。 12345678910111213141516171819202122232425262728293031323334/*public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;*/class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); if (root != null) &#123; Deque&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); // 进队 queue.offer(root); while (!queue.isEmpty()) &#123; List&lt;Integer&gt; levels = new ArrayList&lt;&gt;(); // 当前层的节点个数 int size = queue.size(); for (int i = 0; i &lt; size; i++) &#123; // 出队 TreeNode node = queue.poll(); levels.add(node.val); if (node.left != null) &#123; queue.offer(node.left); &#125; if (node.right != null) &#123; queue.offer(node.right); &#125; &#125; list.add(levels); &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 145.二叉树的后序遍历]]></title>
    <url>%2F2019%2F05%2F26%2Fleetcode-145-binary-tree-postorder-traversal%2F</url>
    <content type="text"><![CDATA[给定一个二叉树，返回它的 后序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [3,2,1] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解决方案方法一：递归123456789101112131415161718192021/*public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;*/class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root != null) &#123; if(root.left != null) &#123; list.addAll(postorderTraversal(root.left)); &#125; if(root.right != null) &#123; list.addAll(postorderTraversal(root.right)); &#125; list.add(root.val); &#125; return list; &#125;&#125; 方法二：迭代 思路：遇到一个节点，将其进栈，并将其所有左节点一一进栈。变量parent表示上一次访问过的节点。当栈不为空时，循环执行如下操作：将栈顶元素node出栈，若node的右孩子就是parent，表示node没有右孩子或者其右子树已被访问过，此时可以访问node节点，然后让parent指向node；否则，将node重新压入栈中，并让其指向右孩子，跳出循环。然后重新执行上述过程，直至栈空。 1234567891011121314151617181920212223242526272829303132333435/*public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;*/class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root != null) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; do &#123; while(node != null) &#123; stack.push(node); node = node.left; &#125; // 上一次访问的节点 TreeNode parent = null; while(!stack.isEmpty()) &#123; node = stack.pop(); if(node.right == parent) &#123; list.add(node.val); parent = node; &#125; else &#123; stack.push(node); node = node.right; break; &#125; &#125; &#125; while(!stack.isEmpty()); &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 94.二叉树的中序遍历]]></title>
    <url>%2F2019%2F05%2F25%2Fleetcode-94-binary-tree-inorder-traversal%2F</url>
    <content type="text"><![CDATA[给定一个二叉树，返回它的中序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解决方案方法一：递归1234567891011121314151617/*public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;*/class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root != null) &#123; list.addAll(inorderTraversal(root.left)); list.add(root.val); list.addAll(inorderTraversal(root.right)); &#125; return list; &#125;&#125; 方法二：迭代 思路：遇到一个节点，将其进栈，并将其所有左节点一一进栈。此时，栈顶节点node没有左孩子或者左子树均已访问过。然后出栈并访问node，让node指向其右孩子，对右子树进行同样的处理。 1234567891011121314151617181920212223242526272829303132/*public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125;*/class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root != null) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); TreeNode node = root; // 刚开始循环或者左子树（包括根结点）已经遍历过时，栈为空， // 此时需要使用node != null保证循环执行 while(!stack.isEmpty() || node != null) &#123; // 将当前节点的所有左节点一一进栈 while(node != null) &#123; stack.push(node); node = node.left; &#125; // 此时，栈顶节点没有左孩子或左子树均已访问过 if(!stack.isEmpty()) &#123; node = stack.pop(); list.add(node.val); // 处理右孩子 node = node.right; &#125; &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 144.二叉树的前序遍历]]></title>
    <url>%2F2019%2F05%2F25%2Fleetcode-144-binary-tree-preorder-traversal%2F</url>
    <content type="text"><![CDATA[给定一个二叉树，返回它的 前序 遍历。 示例: 12345678输入: [1,null,2,3] 1 \ 2 / 3 输出: [1,2,3] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解决方案方法一：递归12345678910111213141516171819/* public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root != null) &#123; list.add(root.val); list.addAll(preorderTraversal(root.left)); list.addAll(preorderTraversal(root.right)); &#125; return list; &#125;&#125; 方法二：迭代 思路：先将根结点root进栈，在栈不空时循环：出栈并访问node，若其右孩子节点不为空，则将右孩子节点进栈，若其左孩子节点不为空，再将其左孩子节点进栈。 12345678910111213141516171819202122232425262728293031/* public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; */class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root != null) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) &#123; // 1.栈顶元素出栈 TreeNode node = stack.pop(); list.add(node.val); // 2.若其右孩子节点不为空 if(node.right != null) &#123; stack.push(node.right); &#125; // 3.若其左孩子节点不为空 if(node.left != null) &#123; stack.push(node.left); &#125; &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1025.PAT Ranking (25 分)]]></title>
    <url>%2F2019%2F05%2F23%2Fpat-advanced-1025%2F</url>
    <content type="text"><![CDATA[Programming Ability Test (PAT) is organized by the College of Computer Science and Technology of Zhejiang University. Each test is supposed to run simultaneously in several places, and the ranklists will be merged immediately after the test. Now it is your job to write a program to correctly merge all the ranklists and generate the final rank. Input Specification:Each input file contains one test case. For each case, the first line contains a positive number N (≤100), the number of test locations. Then N ranklists follow, each starts with a line containing a positive integer K (≤300), the number of testees, and then K lines containing the registration number (a 13-digit number) and the total score of each testee. All the numbers in a line are separated by a space. Output Specification:For each test case, first print in one line the total number of testees. Then print the final ranklist in the following format: 1registration_number final_rank location_number local_rank The locations are numbered from 1 to N. The output must be sorted in nondecreasing order of the final ranks. The testees with the same score must have the same rank, and the output must be sorted in nondecreasing order of their registration numbers. Sample Input:123456789101112251234567890001 951234567890005 1001234567890003 951234567890002 771234567890004 8541234567890013 651234567890011 251234567890014 1001234567890012 85 Sample Output:1234567891091234567890005 1 1 11234567890014 1 2 11234567890001 3 1 21234567890003 3 1 21234567890004 5 1 41234567890012 5 2 21234567890002 7 1 51234567890013 8 2 31234567890011 9 2 4 分析：题目要求：已知有N个考场，每个考场有若干个考生，给定每个考场中考生的准考证号和分数，要求计算排名。按照总排名的先后顺序，输出每个考生的准考证号、总排名、考场号以及考场内排名。 思路：先进行考场内排名，然后再进行总排名。分数相同的情况下，按照准考证号从小到大的顺序排列，但其排名是相同的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct Testee &#123; char registrationNumber[14]; int finalRank; int locationNumber; int localRank; int score;&#125;;// 按照分数降序排序，若分数相同，则按照准考证号从小到大排序bool cmp(Testee a, Testee b) &#123; if (a.score != b.score) &#123; return a.score &gt; b.score; &#125; return strcmp(a.registrationNumber, b.registrationNumber) &lt; 0;&#125;int main() &#123; int n, k, num = 0; scanf("%d", &amp;n); // max(n) * max(k) = 100 * 300 struct Testee testees[30000]; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;k); // 1.输入考生的准考证号和分数 for (int j = 0; j &lt; k; j++) &#123; Testee testee; scanf("%s %d", testee.registrationNumber, &amp;testee.score); testee.locationNumber = i; testees[num++] = testee; &#125; // 2.计算考场内排名 sort(testees + num - k, testees + num, cmp); for (int j = num - k; j &lt; num; j++) &#123; if (j == num - k) &#123; testees[j].localRank = 1; &#125; else &#123; if (testees[j].score == testees[j - 1].score) &#123; testees[j].localRank = testees[j - 1].localRank; &#125; else &#123; testees[j].localRank = j - (num - k) + 1; &#125; &#125; &#125; &#125; // 3.计算总排名 sort(testees, testees + num, cmp); printf("%d\n", num); for (int j = 0; j &lt; num; j++) &#123; if (j == 0) &#123; testees[j].finalRank = 1; &#125; else &#123; if (testees[j].score == testees[j - 1].score) &#123; testees[j].finalRank = testees[j - 1].finalRank; &#125; else &#123; testees[j].finalRank = j + 1; &#125; &#125; printf("%s %d %d %d\n", testees[j].registrationNumber, testees[j].finalRank, testees[j].locationNumber, testees[j].localRank); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1082.Read Number in Chinese (25 分)]]></title>
    <url>%2F2019%2F05%2F23%2Fpat-advanced-1082%2F</url>
    <content type="text"><![CDATA[Given an integer with no more than 9 digits, you are supposed to read it in the traditional Chinese way. Output Fu first if it is negative. For example, -123456789 is read as Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu. Note: zero (ling) must be handled correctly according to the Chinese tradition. For example, 100800 is yi Shi Wan ling ba Bai. Input Specification:Each input file contains one test case, which gives an integer with no more than 9 digits. Output Specification:For each test case, print in a line the Chinese way of reading the number. The characters are separated by a space and there must be no extra space at the end of the line. Sample Input 1:1-123456789 Sample Output 1:1Fu yi Yi er Qian san Bai si Shi wu Wan liu Qian qi Bai ba Shi jiu Sample Input 2:1100800 Sample Output 2:1yi Shi Wan ling ba Bai 分析：题目要求：按照中文数字的读法，输出给定的整数（不超过9位）。 思路：将输入的整数当作字符串来处理。 首先，判断首位字符是否为-，若为-，则输出Fu。 然后，设置left、right两个指针，用于标明同一组数字的最高位和最低位，从前向后每次循环只处理一组数字。(字符串从后向前，每四位数字为一组。) 用hasPrint表示在处理该组数字时，是否输出过非零数字，默认为false。 用hasZero表示当前数字的前面是否存在累积的零，默认为false。 若本组输出过至少一个非零数字，且right小于字符串的最大索引，则输出该节数字的单位（万或亿）。 处理完一组数字后，right后移4位，继续下一次循环，直到left大于等于字符串的长度为止。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; char digits[10][5] = &#123; "ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu" &#125;; char unit[5][5] = &#123; "Shi", "Bai", "Qian", "Wan", "Yi" &#125;; char data[11]; scanf("%s", data); int len = strlen(data); int left = 0, right = len - 1; // 若为负数 if (len != 0 &amp;&amp; data[0] == '-') &#123; printf("Fu"); left = 1; &#125; // 找到与left在同一节中的right while (left + 4 &lt;= right) &#123; right -= 4; &#125; while (left &lt; len) &#123; bool hasPrint = false; bool hasZero = false; // 处理某一组数字 while (left &lt;= right) &#123; if (left &gt; 0 &amp;&amp; data[left] == '0') &#123; hasZero = true; &#125; else &#123; if (hasZero == true) &#123; printf(" ling"); hasZero = false; &#125; hasPrint = true; // 若当前数字不是第一个数字，则输出空格 if (left &gt; 0) &#123; printf(" "); &#125; printf("%s", digits[data[left] - '0']); if (right &gt; left) &#123; printf(" %s", unit[right - left - 1]); &#125; &#125; left++; &#125; // 若本组已经输出过至少一个非零数字，则输出该组数字的单位(万/亿) if (hasPrint &amp;&amp; right &lt; len - 1) &#123; printf(" %s", unit[(len - 1 - right) / 4 + 2]); &#125; right += 4; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吴军《见识》读书笔记]]></title>
    <url>%2F2019%2F05%2F22%2Freading-note-insight%2F</url>
    <content type="text"><![CDATA[序言 “命”和“运”决定人的一生 一个人小富小贵，可以靠一时的运气……仅仅靠一时运气好是不可能大富大贵的。 要想命好，首先要认识命的重要性，即信命和认命。信命是知道自己有所不能，认命则是不超越命运给自己画的线，对于得不到的坦然接受。 我的理解：“信命”就是知道自己做不了什么，比如我性格偏内向，不善言辞，你让我去做推销，我肯定做不好。”认命“就是知道自己能做什么。 但凡人的知识面稍微宽一点，交际的圈子稍微广一点，了解事情稍微全面一点，命就会好很多。 我的理解：1.多读好书，最好涉猎多个领域。以我为例，我想涉猎的领域有文学、心理学、经济学、管理学、计算机等。 2.多交值得结交的朋友。常言道：在家靠父母，出门靠朋友。 3.人在信息不全面的情况下，容易做出错误的决定。 性格决定命运。其实决定命运的还包括我们的习惯、行为及其背后的思维方式。思维方式出问题的人，命运之神是永远不会眷顾的。 我的理解：比如，那些过马路不走人行道、闯红灯的人（这里要批评我自己，我有时和别人一起的时候，会跟着别人一起横穿马路），都是思维方式有问题的人。相比不遵守交通规则带来的那一点点时间节省，我们更应该考虑自身的安全。 以认怂的态度对待人生一道又一道的坎，就会不断地被这个世界扇巴掌。 幸福是目的，成功是手段 人生是一条河 高尔基：给总比拿要快乐得多。 人生是一条河，每个人总希望自己这条河能够更宽一点、更深一点、更长一点。要做到更深，是靠自己的修行和对世界的理解；而要做到更宽，则是要和一些志同道合的人在一起共同做一些事情。 这个世界没有欠你什么 ……那些指望通过十年寒窗苦读就一下子翻身的人……是不现实的。 寒窗苦读是成功的因素之一，和经济条件好、智商高、出身好、长得美一样，都只是其中的一个变量而已，而命运是多个变量互动的结果。这种因为寒窗苦读所以全世界都欠你钱的三观，早一天毁掉比晚一点毁掉好。 在任何国家、任何时代，社会都是分层的。 没有一个国家、一个社会，会每过两年就把现有的金字塔打碎，然后随机地再建造一个，那样的社会被称为动荡不安。 逆袭不成功是常态，成功的反而是少数。逆袭是一个漫长的过程。 我的理解：逆袭是一个漫长的过程，不可能一蹴而就，需要几代人的努力才能实现。 朝为田舍郎，暮登天子堂。 人生最重要的投资 对于年轻人来讲，对自己的投资和在职业上的进步，远比在股市上捞点钱或者向父母借钱买一套房子更为重要，也更为靠得住。当然，还有一个和投资自己至少同样重要甚至更为重要的投资，就是找一个好的配偶。 在一个完美的婚姻中，双方都要明白关系的亲密程度和重要性依次是”夫妻优先于子女，更优先于双方的父母“。 我的理解：首先，配偶陪在自己身边的时间远超过父母和儿女。其次，在继承法中，配偶是遗产的第一顺位继承人，子女和父母是第二顺位继承人。 先让父母成熟起来 人不可能一辈子不栽跟头，如果一定要栽跟头，早一点比晚一点好。 在现代社会，婚姻更多是两个人的事情，而不是一大家子一起掺和的事情。 我的理解：在现代社会，大多数夫妻不会与双方父母生活在一起。只要两个人处得来，孝顺双方父母就可以了。儿孙自有儿孙福，双方父母不要过多干涉两个人的生活。 向死而生 俗话说，除死无大难。 与其生不如死地多活两个月，不如用这个钱把人生几十年活好。 我的理解：如果明知抢救不过来，不要花钱抢救我。与其给我延长一点点生命，每天饱受疼痛折磨，不如让我早点离开。 人生需要做减法 不做选择的幸福 很多时候，我们把太多的精力花在了选择上，而不是经营上，导致难以精进。或许少些选择，会更加聚焦，也会让我们更幸福、更成功。 西瓜与芝麻 人一旦心志变得非常低，就很难提升自己、让自己走到越来越高的层次上。 生也有涯，知也无涯 《庄子》：吾生也有涯，而知也无涯，以有涯随无涯，殆矣。已而为知者，殆而已矣。 人生成功的秘诀在于做减法，而做减法的关键在于能够跳出一般人的思维定式，找到那些其实无关紧要的事情，然后下决心把那些事情放弃掉。 谈谈见识 我们和天才相差有多远？ 凡天才必有过人之处，但是我们和他们之间的差异可能不是生理上的差距，而是在其他方面，比如认识上、见识上、勇气上或方法上。 起跑线和玻璃心 学习是一个长期的事情、一辈子的事情，是马拉松比赛，而不是百米赛跑。 我的理解：终身学习型社会，一时的落后并不要紧。一辈子很长，只要我们不懈努力，终会找到反超的机会。 论运气 人在运气不好的时候，最需要的不是盲目的努力，而是慢下来思考，有耐心地做事情。 我的理解：思考适合自己的方向，并为之不懈努力。 任何经历只要善于利用都是财富，不善于利用都是浪费时间。一个有心的人，会善于把过去的经历变为今后成功的铺路石。 社会上不是强者生存，而是适者生存。 比贫穷更可怕的是什么？ 《庄子·外篇·秋水》：夏虫不可以语于冰者，笃于时也；曲士不可以语于道者，束于教也。 缺乏见识、缺乏爱、缺乏规矩，是比缺钱更可怕的事情。 贫穷可能会在短期内使物质条件差一点，但是并不影响父母在见识、爱和规矩上培养好孩子。 对话庄子：谈谈见识 把目光放远，不要为眼前那一点点成就而沾沾自喜。 阅读的意义 阅读不仅让我们在冷酷无情的科技时代获得喘息，而且重启了大脑深入思考的功能，还是抵抗狭隘、思想控制和舆论支配的方式。 牛津大学圣埃德蒙：Study as if you were to live forever, live as if you were to die tomorrow. 终身学习，向死而生。 大家智慧 莎士比亚的智慧：论朋友 《哈姆雷特》：To be or not not be, that is a question. 好的朋友是巨大的财富，而损友则是巨大的负资产。 销售大师的智慧 很多人不顾家地去挣钱，讲的理由是为了家人的幸福，其实这种做法本身已经让家人不幸福了。 我的理解：挣钱是手段，幸福生活才是目的。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 108.将有序数组转换为二叉搜索树]]></title>
    <url>%2F2019%2F05%2F20%2Fleetcode-108-convert-sorted-array-to-binary-search-tree%2F</url>
    <content type="text"><![CDATA[将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 123456789给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 解决方案方法一：直接构造AVL树参看LeetCode 109.有序链表转换二叉搜索树 方法二：递归 思路：以数组的中间元素为界，将数组一分为二。然后对这两个部分递归执行该过程。 12345678910111213141516171819202122232425262728/* public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; */class Solution &#123; public TreeNode sortedArrayToBST(int[] nums) &#123; if(nums == null || nums.length == 0) &#123; return null; &#125; return createAVL(nums, 0, nums.length-1); &#125; public TreeNode createAVL(int[] nums, int low, int high) &#123; if(low &gt; high) &#123; return null; &#125; int mid = (low + high) / 2; TreeNode root = new TreeNode(nums[mid]); root.left = createAVL(nums, low, mid-1); root.right = createAVL(nums, mid+1, high); return root; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 109.有序链表转换二叉搜索树]]></title>
    <url>%2F2019%2F05%2F20%2Fleetcode-109-convert-sorted-list-to-binary-search-tree%2F</url>
    <content type="text"><![CDATA[给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 123456789给定的有序链表： [-10, -3, 0, 5, 9],一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 解决方案方法一：直接构造AVL树 思路：遍历链表中的每一个节点，将其插入到AVL树中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/* public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; *//* public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; */class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; TreeNode root = null; while(head != null) &#123; root = insert(root,head.val); head = head.next; &#125; return root; &#125; // LL型旋转 public TreeNode leftRotation(TreeNode root) &#123; TreeNode node = root.left; root.left = node.right; node.right = root; return node; &#125; // RR型旋转 public TreeNode rightRotation(TreeNode root) &#123; TreeNode node = root.right; root.right = node.left; node.left = root; return node; &#125; // LR型旋转 public TreeNode leftRightRotation(TreeNode root) &#123; root.left = rightRotation(root.left); return leftRotation(root); &#125; // RL型旋转 public TreeNode rightLeftRotation(TreeNode root) &#123; root.right = leftRotation(root.right); return rightRotation(root); &#125; public TreeNode insert(TreeNode root,int x) &#123; if(root == null) &#123; root = new TreeNode(x); &#125; else if(x &lt; root.val) &#123; root.left = insert(root.left,x); if(getHeight(root.left) - getHeight(root.right) &gt;= 2) &#123; if(x &lt; root.left.val) &#123; root = leftRotation(root); &#125; else &#123; root = leftRightRotation(root); &#125; &#125; &#125; else if(x &gt; root.val) &#123; root.right = insert(root.right,x); if(getHeight(root.right) - getHeight(root.left) &gt;= 2) &#123; if(x &gt; root.right.val) &#123; root = rightRotation(root); &#125; else &#123; root = rightLeftRotation(root); &#125; &#125; &#125; return root; &#125; // 求树的高度 public int getHeight(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; return Math.max(getHeight(root.left),getHeight(root.right)) + 1; &#125;&#125; 方法二：快慢指针+递归 思路：通过快慢指针，寻找中间节点。以此节点为界，将链表一分为二。然后对这两个部分递归执行该过程。 123456789101112131415161718192021222324252627282930313233343536373839404142/* public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; *//* public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; */class Solution &#123; public TreeNode sortedListToBST(ListNode head) &#123; // 1.寻找中间节点 ListNode pre = head; ListNode slow = head; ListNode fast = head; while(fast != null &amp;&amp; fast.next != null) &#123; pre = slow; slow = slow.next; fast = fast.next.next; &#125; TreeNode root = null; if(slow != null) &#123; root = new TreeNode(slow.val); // 2.以中间节点为界，将链表一分为二 pre.next = null; fast = slow.next; // 3.对左右两个部分递归执行该过程 if(slow != head) &#123; root.left = sortedListToBST(head); &#125; root.right = sortedListToBST(fast); &#125; return root; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 110.平衡二叉树]]></title>
    <url>%2F2019%2F05%2F20%2Fleetcode-110-balanced-binary-tree%2F</url>
    <content type="text"><![CDATA[给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。 示例 1: 给定二叉树 [3,9,20,null,null,15,7] 12345 3 / \9 20 / \ 15 7 返回 true 。 示例 2: 给定二叉树 [1,2,2,3,3,null,null,4,4] 1234567 1 / \ 2 2 / \ 3 3 / \4 4 返回 false 。 解决方案本题可以采用递归法，递归表达式如下所示：$$isBalanced(root)=\begin{cases}true, &amp; root为空 \\isBalanced(root.left) \cap isBalanced(root.right), &amp; root节点是平衡的 \\\end{cases}$$ 1234567891011121314151617181920212223242526/* public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; */class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if(root == null) &#123; return true; &#125; if(Math.abs(getHeight(root.left) - getHeight(root.right)) &lt;= 1) &#123; return isBalanced(root.left) &amp;&amp; isBalanced(root.right); &#125; return false; &#125; //求树的高度 public int getHeight(TreeNode root) &#123; if(root == null) &#123; return 0; &#125; return Math.max(getHeight(root.left), getHeight(root.right)) + 1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>binary-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 CCF CCSP分区赛折戟而归]]></title>
    <url>%2F2019%2F05%2F18%2F2019-ccf-ccsp-division-series%2F</url>
    <content type="text"><![CDATA[竞赛安排今年，CCF决定举办首届CCF CCSP分区赛。CCF官方对其的定位为：分赛区竞赛以CSP认证为初赛，是CCSP总决赛前的复赛。 全国被分成了七个赛区，分别由七所高校承办： 东北： 哈尔滨工业大学 华北：北京邮电大学 华中：湖南大学 华东：南京航空航天大学 华南：深圳大学 西北：西安电子科技大学 西南：四川大学 不同的赛区对参赛资格的要求各不相同。以我所在的华中赛区为例，要求CSP成绩不低于200分（近四次认证中的任一次）。 竞赛题目本次竞赛总共三道题，总分300分，时间为6个小时，不限语言（C++/Java/Python），通过一个测试点即可得到该测试点的分数。 与往常CCF CSP不同的地方是，本次比赛采用OJ的形式，可以看到提交的代码通过了哪些测试点，以及其他人的AC情况。 第一题 统计CCSP子图个数第一题是关于数据结构中图的应用。题目大意是：给定一个图，求该图中满足某些性质的子图个数。 一直以来，图就是我的知识盲区，所以一上来我就蒙了。翻开数据结构书，边敲边想，花了大概一个多小时，看到很多人已经AC了，最终无奈放弃了。 最后还剩一个小时的时候，我发现本题其实是可以骗分的。 第一个测试点（14分）不满足题目中给定子图的要求，直接输出0即可，这14分相当于是白送给我们的。 第二个测试点（34分）刚好满足给定子图的基本要求（4个顶点4条边），因此只涉及到创建图、判断该图是否连通以及图中是否存在回路。最后还剩不到十分钟时，我成功通过了第二个测试点，又骗到了34分。 因此，第一题我几乎没费什么时间就拿到了48分。当然，虽然骗到了将近一半的分数，但其实离真正AC还差得远呢！ 第二题 强化的RAID5第二题是一道字符串模拟题。题目内容与2019年3月第十六次CCF CSP的第三题几乎一样。由于本题题目实在太长，我直接就跳过了。 需要吐槽的是，同样是由于题目冗长，第十六次CSP第三题我直接没做，最终只AC前两道送分题，得了200分。 第三题 简化的MapReduce第三题要求实现一个简化版的MapReduce。本题只支持C++和Java两种语言，得分的方式也略有不同，程序的正确性只占30%，性能占70%。 题目给定了一个接口，要求我们实现该接口中的若干方法。主要考查了函数式编程及多线程的知识。 在C++版中，CCF官方直接给了一个简单的实现，而Java则需要自己实现。 Java版的实现，主要是基于Java8的Stream API。老实讲，我对Stream API并不太熟悉，幸好题目给了一个统计文件中字母a开头的各单词个数的例子，半猜半看，大致弄懂了每个方法要做什么。午饭前后，我大致完成了本题，结果一提交，只通过了第一个测试点，后面的测试点要么报TLE，要么说格式不正确，最终仅得到了2.92分。 后来，我发现题目中明确告诉我们，C++版给了一个简单的实现，遂直接将官方的实现提交了，结果直接通过了前两个测试点，得分为20.92分。 赛况统计华中赛区总共有105人参赛，参赛选手来自武大（包括我在内总计三人）、华科、国防科大、中南、湖南大学、长沙理工等15所高校。我的最终得分为68.92分，大致排在90左名。 金、银、铜奖总计62个，几乎被长沙四校（国防科大、中南、湖大以及长沙理工）包揽了。 赛后感受折腾一次就够了，真的太烧钱啦！ 为了参加本次竞赛，我前前后后总共花费了906元。其中，报名费400元，住宿一晚177元，高铁往返164.5×2=329元（本来想坐普通火车回来的，主要是心神消耗过大，加上特快要4个多小时，到武汉得晚上12点左右）。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1077.Kuchiguse (20 分)]]></title>
    <url>%2F2019%2F05%2F16%2Fpat-advanced-1077%2F</url>
    <content type="text"><![CDATA[The Japanese language is notorious for its sentence ending particles. Personal preference of such particles can be considered as a reflection of the speaker’s personality. Such a preference is called “Kuchiguse” and is often exaggerated artistically in Anime and Manga. For example, the artificial sentence ending particle “nyan~” is often used as a stereotype for characters with a cat-like personality: Itai nyan~ (It hurts, nyan~) Ninjin wa iyada nyan~ (I hate carrots, nyan~) Now given a few lines spoken by the same character, can you find her Kuchiguse? Input Specification:Each input file contains one test case. For each case, the first line is an integer N (2≤N≤100). Following are N file lines of 0~256 (inclusive) characters in length, each representing a character’s spoken line. The spoken lines are case sensitive. Output Specification:For each test case, print in one line the kuchiguse of the character, i.e., the longest common suffix of all N lines. If there is no such suffix, write nai. Sample Input 1:12343Itai nyan~Ninjin wa iyadanyan~uhhh nyan~ Sample Output 1:1nyan~ Sample Input 2:12343Itai!Ninjinnwaiyada T_TT_T Sample Output 2:1nai 分析：题目要求：给定N个字符串，求其最长公共后缀。 思路：设maxLen表示最长公共后缀的长度，初始值为258。从第二个字符串开始，将每一个字符串与前一个字符串进行比较，求其公共后缀长度len。若len小于maxLen，则将len赋给maxLen。 待循环执行完毕后，若maxLen为0，则输出nai。否则，输出最长公共后缀。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; int n; scanf("%d", &amp;n); getchar(); char lines[n][257]; int len = 0, maxLen = 257; for (int i = 0; i &lt; n; i++) &#123; char c; int j = 0; // 由于字符串中可能包含空格，故不能采用scanf。 // 且PAT不再支持gets，故采用getchar()逐个字符输入 while ((c = getchar()) != '\n') &#123; lines[i][j++] = c; &#125; lines[i][j] = '\0'; if (i &gt; 0) &#123; int preIndex = strlen(lines[i - 1]) - 1; int currentIndex = strlen(lines[i]) - 1; while (preIndex &gt;= 0 &amp;&amp; currentIndex &gt;= 0 &amp;&amp; lines[i][currentIndex--] == lines[i - 1][preIndex--]) &#123; len++; &#125; if (len &lt; maxLen) &#123; maxLen = len; &#125; len = 0; &#125; &#125; if (maxLen == 0) &#123; printf("nai"); &#125; else &#123; int len0 = strlen(lines[0]); for (int i = len0 - maxLen; i &lt; len0; i++) &#123; printf("%c", lines[0][i]); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1035.Password (20 分)]]></title>
    <url>%2F2019%2F05%2F16%2Fpat-advanced-1035%2F</url>
    <content type="text"><![CDATA[To prepare for PAT, the judge sometimes has to generate random passwords for the users. The problem is that there are always some confusing passwords since it is hard to distinguish 1 (one) from l (L in lowercase), or 0 (zero) from O (o in uppercase). One solution is to replace 1(one) by @, 0 (zero) by %, l by L, and O by o. Now it is your job to write a program to check the accounts generated by the judge, and to help the juge modify the confusing passwords. Input Specification:Each input file contains one test case. Each case contains a positive integer N (≤1000), followed by N lines of accounts. Each account consists of a user name and a password, both are strings of no more than 10 characters with no space. Output Specification:For each test case, first print the number M of accounts that have been modified, then print in the following M lines the modified accounts info, that is, the user names and the corresponding modified passwords. The accounts must be printed in the same order as they are read in. If no account is modified, print in one line There are N accounts and no account is modified where N is the total number of accounts. However, if N is one, you must print There is 1 account and no account is modified instead. Sample Input 1:12343Team000002 Rlsp0dfaTeam000003 perfectpwdTeam000001 R1spOdfa Sample Output 1:1232Team000002 RLsp%dfaTeam000001 R@spodfa Sample Input 2:121team110 abcdefg332 Sample Output 2:1There is 1 account and no account is modified Sample Input 3:1232team110 abcdefg222team220 abcdefg333 Sample Output 3:1There are 2 accounts and no account is modified 分析：题目要求：给定N个用户账号（包含用户名和密码），将密码中的1(数字一)替换为@，0(数字零)替换为%，l（小写字母）替换为L，O（大写字母）替换为o。 输出被更改的账号个数M，以及被更改账号的用户名和更改后的密码。 若没有账户需要更改，输出There are N accounts and no account is modified，其中N为账号个数。特别地，当N为1时，输出There is 1 account and no account is modified。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;struct Account &#123; char username[11]; char password[11];&#125;;int main() &#123; int n; scanf("%d", &amp;n); struct Account accounts[n]; int len = 0; for (int i = 0; i &lt; n; i++) &#123; struct Account a; getchar(); scanf("%s %s", a.username, a.password); bool isModified = false; for (int j = 0; j &lt; strlen(a.password); j++) &#123; switch(a.password[j]) &#123; case 'l': a.password[j] = 'L'; isModified = true; break; case '1': a.password[j] = '@'; isModified = true; break; case '0': a.password[j] = '%'; isModified = true; break; case 'O': a.password[j] = 'o'; isModified = true; break; &#125; &#125; if (isModified) &#123; accounts[len++] = a; &#125; &#125; if (len == 0) &#123; if (n == 1) &#123; printf("There is 1 account and no account is modified\n"); &#125; else &#123; printf("There are %d accounts and no account is modified\n", n); &#125; &#125; else &#123; printf("%d\n", len); for (int i = 0; i &lt; len; i++) &#123; struct Account a = accounts[i]; printf("%s %s\n", a.username, a.password); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 328.奇偶链表]]></title>
    <url>%2F2019%2F05%2F10%2Fleetcode-328-odd-even-linked-list%2F</url>
    <content type="text"><![CDATA[题目描述给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。 请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。 示例 1: 12输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL 示例 2: 12输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL 说明: 应当保持奇数节点和偶数节点的相对顺序。 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。 解决方案方法一：复制法 思路：复制原链表head，得到新的链表newList，分别对head的奇数节点、newList的偶数节点进行处理。 算法实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;*/class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; // 链表为空，或仅含一个节点 if(head == null || head.next == null) &#123; return head; &#125; ListNode newList = copy(head); ListNode root = new ListNode(0); ListNode rear = root; // 处理奇数节点 while(newList != null) &#123; rear.next = newList; rear = newList; if(newList.next == null) &#123; break; &#125; newList = newList.next.next; &#125; // 处理偶数节点 ListNode node = head.next; while(node != null) &#123; rear.next = node; rear = node; if(node.next == null) &#123; break; &#125; node = node.next.next; &#125; rear.next = null; return root.next; &#125; // 复制链表 public ListNode copy(ListNode head) &#123; ListNode root = new ListNode(0); ListNode rear = root; ListNode node; while(head != null) &#123; node = new ListNode(head.val); rear.next = node; rear = node; head = head.next; &#125; return root.next; &#125;&#125; 复杂度分析： 空间复杂度：该方法需要复制原链表，故空间复杂度为O(nodes) 时间复杂度：O(nodes) 方法二：双指针 思路：使用奇偶双指针，同时处理奇偶节点，分别得到两个链表，然后将这两个链表链接在一起。 算法实现 123456789101112131415161718192021222324252627/*public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;*/class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if(head == null || head.next == null) &#123; return head; &#125; ListNode l1 = head; ListNode l2 = head.next; ListNode odd = l1; ListNode even = l2; // 使用奇偶双指针，同时处理奇偶节点 while(even != null &amp;&amp; even.next != null) &#123; odd.next = even.next; even.next = even.next.next; odd = odd.next; even = even.next; &#125; // 将偶数链表拼接到奇数链表后 odd.next = l2; return l1; &#125;&#125; 复杂度分析： 空间复杂度：只使用了常数的额外空间，故空间复杂度为O(1) 时间复杂度：仅对链表执行一次遍历，故时间复杂度为O(nodes)]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 203.移除链表元素]]></title>
    <url>%2F2019%2F05%2F08%2Fleetcode-203-remove-linked-list-elements%2F</url>
    <content type="text"><![CDATA[题目描述删除链表中等于给定值 val 的所有节点。 示例: 12输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 解决方案方法一：使用头结点1234567891011121314151617181920/*public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;*/class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode root = new ListNode(0); root.next = head; ListNode node = root; while(node.next != null) &#123; if(node.next.val == val) &#123; node.next = node.next.next; &#125; else &#123; node = node.next; &#125; &#125; return root.next; &#125;&#125; 方法二：不使用头结点12345678910111213141516171819202122232425262728/*public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;*/class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if(head == null) &#123; return head; &#125; // pre表示node的前驱结点 ListNode node = head, pre = head; while(node != null) &#123; if(node.val == val) &#123; // 若头结点需要删除 if(node == head) &#123; head = head.next; &#125; else &#123; pre.next = node.next; &#125; &#125; else &#123; pre = node; &#125; node = node.next; &#125; return head; &#125;&#125; 方法三：递归法123456789101112131415161718/*public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;*/class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if(head == null) &#123; return head; &#125; // 若头结点需要删除 if(head.val == val) &#123; return removeElements(head.next, val); &#125; head.next = removeElements(head.next, val); return head; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1005.Spell It Right (20 分)]]></title>
    <url>%2F2019%2F05%2F08%2Fpat-advanced-1005%2F</url>
    <content type="text"><![CDATA[Given a non-negative integer N, your task is to compute the sum of all the digits of N, and output every digit of the sum in English. Input Specification:Each input file contains one test case. Each case occupies one line which contains an N (≤$10^{100}$). Output Specification:For each test case, output in one line the digits of the sum in English words. There must be one space between two consecutive words, but no extra space at the end of a line. Sample Input:112345 Sample Output:1one five 分析：题目要求：给定一个非负数N，计算其各位数字之和，并输出和的每一位的英文表示。 思路：以字符串的形式读入n，计算其各位数字之和sum，将sum转换为字符串result，输出result每一位对应的英文表示。 1.纯c风格（不使用c++的string） 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; char n[102]; scanf("%s", n); int sum = 0; char digits[10][6] = &#123; "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" &#125;; for (int i = 0; i &lt; strlen(n); i++) &#123; sum += (n[i] - '0'); &#125; char result[102], index = 0; // 倒序存储sum的每一位，使用do...while是为了处理sum为0的情况 do &#123; result[index++] = sum % 10 + '0'; sum /= 10; &#125; while (sum != 0); for (int i = index - 1; i &gt;= 0; i--) &#123; if (i != index - 1) &#123; printf(" "); &#125; printf("%s", digits[result[i] - '0']); &#125; printf("\n"); return 0;&#125; 2.c++风格（使用string） 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string n; cin &gt;&gt; n; int sum = 0; string digits[10] = &#123; "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" &#125;; for (int i = 0; i &lt; n.size(); i++) &#123; sum += (n[i] - '0'); &#125; string result = to_string(sum); for (int i = 0; i &lt; result.size(); i++) &#123; if (i != 0) &#123; cout &lt;&lt; " "; &#125; cout &lt;&lt; digits[result[i] - '0']; &#125; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1001.A+B Format (20 分)]]></title>
    <url>%2F2019%2F05%2F07%2Fpat-advanced-1001%2F</url>
    <content type="text"><![CDATA[Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where −10^6≤a,b≤10^6. The numbers are separated by a space. Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input:1-1000000 9 Sample Output:1-999,991 分析：题目要求：计算a+b，然后以每三位加一个逗号,的格式输出。 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;int main() &#123; int a, b, sum, index = 0; scanf("%d %d", &amp;a, &amp;b); sum = a + b; char s[30]; if (sum &lt; 0) &#123; printf("-"); sum = -sum; &#125; int count = 0; // 采用do...while，避免当sum = 0时，字符数组s为空 do &#123; count++; // 倒序存储sum s[index++] = sum % 10 + '0'; sum /= 10; // 每三位添加一个逗号 if (count % 3 == 0 &amp;&amp; sum != 0) &#123; count = 0; s[index++] = ','; &#125; &#125; while (sum != 0); for (int i = index - 1; i &gt;= 0; i--) &#123; printf("%c", s[i]); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1048.数字加密 (20 分)]]></title>
    <url>%2F2019%2F05%2F07%2Fpat-basic-1048%2F</url>
    <content type="text"><![CDATA[本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。 输入格式：输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。 输出格式：在一行中输出加密后的结果。 输入样例：11234567 368782971 输出样例：13695Q8118 分析：题目已知个位为第1位，因此可以考虑先将A、B反转，然后分奇偶位进行相应的操作。 需要注意的是：当正整数B的长度小于A时，B前面的空缺位置，依然需要执行加密操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;void reverse(char s[]) &#123; int len = strlen(s); int temp = 0; for (int i = 0; i &lt; len / 2; i++) &#123; temp = s[i]; s[i] = s[len - i - 1]; s[len - i - 1] = temp; &#125;&#125;int main() &#123; char a[101], b[101], c[101]; scanf("%s %s", a, b); reverse(a); reverse(b); int lenB = strlen(b); int lenA = strlen(a); int len = lenA &gt; lenB ? lenA : lenB; for (int i = 1; i &lt;= len; i++) &#123; int numA = i &lt;= lenA ? a[i - 1] - '0' : 0; int numB = i &lt;= lenB ? b[i - 1] - '0' : 0; // 若为奇数 if (i % 2 != 0) &#123; int result = (numA + numB) % 13; if (result &lt; 10) &#123; c[i - 1] = result + '0'; &#125; else &#123; if (result == 10) &#123; c[i - 1] = 'J'; &#125; else if (result == 11) &#123; c[i - 1] = 'Q'; &#125; else &#123; c[i - 1] = 'K'; &#125; &#125; &#125; else &#123; int result = numB - numA; if (result &lt; 0) &#123; c[i - 1] = result + 10 + '0'; &#125; else &#123; c[i - 1] = result + '0'; &#125; &#125; &#125; for (int i = strlen(c) - 1; i &gt;= 0; i--) &#123; printf("%c", c[i]); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1024.科学计数法/PAT甲级 1073.Scientific Notation (20 分)]]></title>
    <url>%2F2019%2F05%2F05%2Fpat-basic-1024%2F</url>
    <content type="text"><![CDATA[科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式 [+-][1-9].[0-9]+E[+-][0-9]+，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。 现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。 输入格式：每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 A。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。 输出格式：对每个测试用例，在一行中按普通数字表示法输出 A，并保证所有有效位都被保留，包括末尾的 0。 输入样例 1：1+1.23400E-03 输出样例 1：10.00123400 输入样例 2：1-1.2E+10 输出样例 2：1-12000000000 分析：本题的关键是，找到E的位置dot，E前面为数字部分，后面为指数。 本题需要分以下三种情况考虑： （1）输入的指数部分e为负数。首先输出0.，然后输出e-1个0，最后将输入的数字部分（不带小数点）原样输出即可。 （2）输入的指数部分e为正数，且小数位count小于指数e。首先将输入的数字部分（不带小数点）原样输出，然后再输出e-count个0即可。 （3）输入的指数部分e为正数，且小数位count大于等于指数e。首先将小数点前的数字部分输出，然后将小数点后e位输出。接着，判断count是否大于e。若大于，先输出小数点，然后将数字部分剩下的count-e位依次输出。 最后，需要注意的是：若输入为正数，则输出时不带符号。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string s, e, n, result; cin &gt;&gt; s; int index = s.find("E"); // 数字部分 n = s.substr(1, index - 1); // 指数部分 e = s.substr(index + 2, s.size() - index - 2); // 若为负数 if (s[0] == '-') &#123; result = s[0]; &#125; int x = stoi(e); int dot = n.find("."); // 若指数为负 if (s[index + 1] == '-') &#123; result += "0."; for (int i = 0; i &lt; x - 1; i++) &#123; result += "0"; &#125; result += n.substr(0, dot) + n.substr(dot + 1, n.size() - dot - 1); &#125; else &#123; int count = n.size() - n.find(".") - 1; // 若指数大于小数位数 if (count &lt; x) &#123; result += n.substr(0, dot) + n.substr(dot + 1, n.size() - dot - 1); for (int i = 0; i &lt; x - count; i++) &#123; result += "0"; &#125; &#125; else &#123; result += n.substr(0, dot) + n.substr(dot + 1, x); // 若指数小于小数位数 if (x &lt; count) &#123; result += "." + n.substr(dot + x + 1, n.size() - dot - x - 1); &#125; &#125; &#125; cout &lt;&lt; result &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 264.丑数 II]]></title>
    <url>%2F2019%2F05%2F03%2Fleetcode-264-ugly-number-ii%2F</url>
    <content type="text"><![CDATA[题目描述编写一个程序，找出第 n 个丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例: 123输入: n = 10输出: 12解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 说明: 1 是丑数。 n 不超过1690。 解决方案三指针法：使用数组ugly存储所有的丑数，ugly[0] = 1。下一个丑数ugly[i]定义为丑数数组中的值乘以权重2、3和5，所得到的最小值。 （1）使用三个指针idx2、idx3、idx5，分别表示2应该乘以ugly[idx2]，3应该乘以ugly[idx3]，5应该乘以ugly[idx5]。 （2）在计算下一个丑数时，若某指针指向的丑数乘以对应的权重所得积最小，则该指针向后移动一位。 （3）应该使用三个并列的if让指针后移，而不能采用if-else。例如，丑数6，可以由丑数2乘以权重3得到，亦可以由丑数3乘以权重2得到，此时，权重2、3的指针都需要向后移一位。 123456789101112131415161718192021222324252627class Solution &#123; public int nthUglyNumber(int n) &#123; int[] ugly = new int[n]; ugly[0] = 1; int idx2,idx3,idx5,a,b,c,temp; idx2 = idx3 = idx5 = 0; for(int i=1;i&lt;n;i++) &#123; a = 2 * ugly[idx2]; b = 3 * ugly[idx3]; c = 5 * ugly[idx5]; temp = Math.min(Math.min(a,b),c); if(temp == a) &#123; idx2++; &#125; if(temp == b) &#123; idx3++; &#125; if(temp == c) &#123; idx5++; &#125; ugly[i] = temp; &#125; return ugly[n-1]; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 263.丑数]]></title>
    <url>%2F2019%2F05%2F03%2Fleetcode-263-ugly-number%2F</url>
    <content type="text"><![CDATA[题目描述编写一个程序判断给定的数是否为丑数。 丑数就是只包含质因数 2, 3, 5 的正整数。 示例 1: 123输入: 6输出: true解释: 6 = 2 × 3 示例 2: 123输入: 8输出: true解释: 8 = 2 × 2 × 2 示例 3: 123输入: 14输出: false 解释: 14 不是丑数，因为它包含了另外一个质因数 7。 说明： 1 是丑数。 输入不会超过 32 位有符号整数的范围: $[−2^{31}, 2^{31}-1]$。 解决方案方法一：递归1234567891011121314151617181920class Solution &#123; public boolean isUgly(int num) &#123; if(num &lt;= 0) &#123; return false; &#125; if(num == 1) &#123; return true; &#125; if(num % 2 == 0) &#123; return isUgly(num / 2); &#125; if(num % 3 == 0) &#123; return isUgly(num / 3); &#125; if(num % 5 == 0) &#123; return isUgly(num / 5); &#125; return false; &#125;&#125; 方法二：循环1234567891011121314151617class Solution &#123; public boolean isUgly(int num) &#123; if(num &lt;= 0) &#123; return false; &#125; while(num % 2 == 0) &#123; num /= 2; &#125; while(num % 3 == 0) &#123; num /= 3; &#125; while(num % 5 == 0) &#123; num /= 5; &#125; return num == 1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 204.计数质数]]></title>
    <url>%2F2019%2F05%2F02%2Fleetcode-204-count-primes%2F</url>
    <content type="text"><![CDATA[题目描述统计所有小于非负整数 n 的质数的数量。 示例: 123输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 解决方案方法一：暴力法逐个判断 [ 2 , n )中的每个整数，是否为质数。 12345678910111213141516171819202122class Solution &#123; public int countPrimes(int n) &#123; int count = 0; for(int i = 2; i &lt; n; i++) &#123; if(isPrime(i)) &#123; count++; &#125; &#125; return count; &#125; public boolean isPrime(int x) &#123; if(x == 2 || x == 3) &#123; return true; &#125; for(int i = 2; i &lt;= Math.sqrt(x); i++) &#123; if(x % i == 0) &#123; return false; &#125; &#125; return true; &#125;&#125; 该方法的时间复杂度为$O(n\sqrt{n})$。 由于本题有几个较大的测试用例，如1500000，采用暴力法会超时。 方法二：埃氏筛法埃拉托色尼筛选法(the Sieve of Eratosthenes)，简称埃氏筛法，其主要思想：当某个数为素数时，那么这个数的倍数一定不是素数。 123456789101112131415161718class Solution &#123; public int countPrimes(int n) &#123; int count = 0; boolean[] isPrime = new boolean[n]; for(int i = 0; i &lt; isPrime.length; i++) &#123; isPrime[i] = true; &#125; for(int i = 2; i &lt; n; i++) &#123; if(isPrime[i]) &#123; for(int j = 2; i * j &lt; n; j++) &#123; isPrime[i * j] = false; &#125; count++; &#125; &#125; return count; &#125; &#125; 该方法的时间复杂度为$O(n\log{\log{n}})$。 方法三：欧式筛法在埃氏筛选法中，每一个非素数（合数）可能会有多次判断，例如，12，被2 6判定为非素数，亦会被3 4判定为非素数。 为了去除这种重复的判断，只使用一个数的最小质因数（能整除给定正整数的最小的质数）来排除该数字，这就是欧式筛选法。 1234567891011121314151617181920212223242526class Solution &#123; public int countPrimes(int n) &#123; int count = 0; // 除2以外的偶数，必定为合数 int[] prime = new int[n / 2]; boolean[] isPrime = new boolean[n]; for(int i = 0; i &lt; isPrime.length; i++) &#123; isPrime[i] = true; &#125; for(int i = 2; i &lt; n; i++) &#123; if(isPrime[i]) &#123; prime[count++] = i; &#125; // 遍历当前找到的所有素数 for(int j = 0; j &lt; count &amp;&amp; i * prime[j] &lt; n; j++) &#123; isPrime[i * prime[j]] = false; // 第一个满足条件i % prime[j] == 0的prime[j]，就是i的最小质因数 // 保证i只被其最小质因数排除 if(i % prime[j] == 0) &#123; break; &#125; &#125; &#125; return count; &#125; &#125; 该方法的时间复杂度为$O(n)$。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1061.Dating (20 分)]]></title>
    <url>%2F2019%2F04%2F30%2Fpat-advanced-1061%2F</url>
    <content type="text"><![CDATA[Sherlock Holmes received a note with some strange strings: Let&#39;s date! 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm. It took him only a minute to figure out that those strange strings are actually referring to the coded time Thursday 14:04 – since the first common capital English letter (case sensitive) shared by the first two strings is the 4th capital letter D, representing the 4th day in a week; the second common character is the 5th capital letter E, representing the 14th hour (hence the hours from 0 to 23 in a day are represented by the numbers from 0 to 9 and the capital letters from A to N, respectively); and the English letter shared by the last two strings is s at the 4th position, representing the 4th minute. Now given two pairs of strings, you are supposed to help Sherlock decode the dating time. Input Specification:Each input file contains one test case. Each case gives 4 non-empty strings of no more than 60 characters without white space in 4 lines. Output Specification:For each test case, print the decoded time in one line, in the format DAY HH:MM, where DAY is a 3-character abbreviation for the days in a week – that is, MON for Monday, TUE for Tuesday, WED for Wednesday, THU for Thursday, FRI for Friday, SAT for Saturday, and SUN for Sunday. It is guaranteed that the result is unique for each case. Sample Input:12343485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm Sample Output:1THU 14:04 分析：本题（与PAT乙级 1014.福尔摩斯的约会 (20 分)是同一道题）有以下四个需要注意的地方： （1）前面两个字符串中第 1 对相同的大写英文字母表示星期。一个星期7天，故其取值范围为A-G，而不是A-Z。 （2）前面两个字符串中第 2 对相同的字符（第 1 对相同的大写英文字母出现之后）表示钟点（小时）。一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示。 （3）后面两个字符串中第 1 对相同的英文字母出现的位置（从 0 开始计数）表示分钟。 （4）小时和分钟不足两位数时，需要在前面添0。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; char week[7][4] = &#123; "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN" &#125;; char str[4][61]; for (int i = 0; i &lt; 4; i++) &#123; scanf("%s", str[i]); &#125; int len0 = strlen(str[0]), len1 = strlen(str[1]); int len2 = strlen(str[2]), len3 = strlen(str[3]); int i = 0, j = 0; while (i &lt; len0 &amp;&amp; i &lt; len1) &#123; // 第一对相同的大写英文字母，取值范围为A-G if (str[0][i] == str[1][i] &amp;&amp; 'A' &lt;= str[0][i] &amp;&amp; str[0][i] &lt;= 'G') &#123; printf("%s ", week[str[0][i] - 'A']); break; &#125; i++; &#125; i += 1; while (i &lt; len0 &amp;&amp; i &lt; len1) &#123; // 第二对相同的字符，取值范围为0-9及A-N if (str[0][i] == str[1][i] &amp;&amp; (('A' &lt;= str[0][i] &amp;&amp; str[0][i] &lt;= 'N') || ('0' &lt;= str[0][i] &amp;&amp; str[0][i] &lt;= '9'))) &#123; if ('A' &lt;= str[0][i] &amp;&amp; str[0][i] &lt;= 'N') &#123; printf("%d:", str[0][i] - 'A' + 10); &#125; else &#123; printf("%02d:", str[0][i] - '0'); &#125; break; &#125; i++; &#125; while (j &lt; len2 &amp;&amp; j &lt; len3) &#123; // 第一对相同的英文字母 if (str[2][j] == str[3][j] &amp;&amp; (('A' &lt;= str[2][j] &amp;&amp; str[2][j] &lt;= 'Z') || ('a' &lt;= str[2][j] &amp;&amp; str[2][j] &lt;= 'z'))) &#123; printf("%02d\n", j); break; &#125; j++; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1014.福尔摩斯的约会 (20 分)]]></title>
    <url>%2F2019%2F04%2F30%2Fpat-basic-1014%2F</url>
    <content type="text"><![CDATA[大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式：输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。 输出格式：在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。 输入样例：12343485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm 输出样例：1THU 14:04 分析：本题有以下四个需要注意的地方： （1）前面两个字符串中第 1 对相同的大写英文字母表示星期。一个星期7天，故其取值范围为A-G，而不是A-Z。 （2）前面两个字符串中第 2 对相同的字符（第 1 对相同的大写英文字母出现之后）表示钟点（小时）。一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示。 （3）后面两个字符串中第 1 对相同的英文字母出现的位置（从 0 开始计数）表示分钟。 （4）小时和分钟不足两位数时，需要在前面添0。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; char week[7][4] = &#123; "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN" &#125;; char str[4][61]; for (int i = 0; i &lt; 4; i++) &#123; scanf("%s", str[i]); &#125; int len0 = strlen(str[0]), len1 = strlen(str[1]); int len2 = strlen(str[2]), len3 = strlen(str[3]); int i = 0, j = 0; while (i &lt; len0 &amp;&amp; i &lt; len1) &#123; // 第一对相同的大写英文字母，取值范围为A-G if (str[0][i] == str[1][i] &amp;&amp; 'A' &lt;= str[0][i] &amp;&amp; str[0][i] &lt;= 'G') &#123; printf("%s ", week[str[0][i] - 'A']); break; &#125; i++; &#125; i += 1; while (i &lt; len0 &amp;&amp; i &lt; len1) &#123; // 第二对相同的字符，取值范围为0-9及A-N if (str[0][i] == str[1][i] &amp;&amp; (('A' &lt;= str[0][i] &amp;&amp; str[0][i] &lt;= 'N') || ('0' &lt;= str[0][i] &amp;&amp; str[0][i] &lt;= '9'))) &#123; if ('A' &lt;= str[0][i] &amp;&amp; str[0][i] &lt;= 'N') &#123; printf("%d:", str[0][i] - 'A' + 10); &#125; else &#123; printf("%02d:", str[0][i] - '0'); &#125; break; &#125; i++; &#125; while (j &lt; len2 &amp;&amp; j &lt; len3) &#123; // 第一对相同的英文字母 if (str[2][j] == str[3][j] &amp;&amp; (('A' &lt;= str[2][j] &amp;&amp; str[2][j] &lt;= 'Z') || ('a' &lt;= str[2][j] &amp;&amp; str[2][j] &lt;= 'z'))) &#123; printf("%02d\n", j); break; &#125; j++; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1002.写出这个数 (20 分)]]></title>
    <url>%2F2019%2F04%2F30%2Fpat-basic-1002%2F</url>
    <content type="text"><![CDATA[读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。 输入格式：每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 $10^{100}​$。 输出格式：在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。 输入样例：11234567890987654321123456789 输出样例：1yi san wu 分析：由于$10^{100}$太大，因此需要以字符串的形式读入n。将字符串n中的每一位转换为整型，然后累加到sum中。 接着将sum转换为字符串str。最后，遍历字符串str中的每一位，输出其对应的汉语拼音。 将整型sum转换为字符串str时，可以采用以下两种方法： （1）使用C++中的to_string()函数； （2）使用一个字符数组str倒序存储sum的每一个数字。每次通过sum % 10操作得到sum的最后一位，然后令sum /= 10，重复进行上述操作，直至sum = 0。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/*#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123; string digits[10] = &#123; "ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu" &#125;; string n; cin &gt;&gt; n; int sum = 0; for (int i = 0; i &lt; n.size(); i++) &#123; sum += n[i] - '0'; &#125; string str = to_string(sum); for (int i = 0; i &lt; str.size(); i++) &#123; if (i &gt; 0) &#123; cout &lt;&lt; " "; &#125; cout &lt;&lt; digits[str[i] - '0']; &#125; cout &lt;&lt; endl; return 0;&#125;*/#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; char digits[10][5] = &#123; "ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu" &#125;; char n[102]; scanf("%s", n); int sum = 0; for (int i = 0; i &lt; strlen(n); i++) &#123; sum += n[i] - '0'; &#125; char str[5]; int index = 0; while (sum != 0) &#123; str[index++] = sum % 10 + '0'; sum /= 10; &#125; for (int i = index - 1; i &gt;= 0; i--) &#123; if (i &lt; index - 1) &#123; printf(" "); &#125; printf("%s", digits[str[i] - '0']); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1031.查验身份证 (15 分)]]></title>
    <url>%2F2019%2F04%2F29%2Fpat-basic-1031%2F</url>
    <content type="text"><![CDATA[一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下： 首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值： 12Z：0 1 2 3 4 5 6 7 8 9 10M：1 0 X 9 8 7 6 5 4 3 2 现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。 输入格式：输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。 输出格式：按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出All passed。 输入样例1：12345432012419880824005612010X19890101123411010819671130186637070419881216001X 输出样例1：12312010X19890101123411010819671130186637070419881216001X 输入样例2：1232320124198808240056110108196711301862 输出样例2：1All passed 分析：根据题意，当出现以下两种情况时，表示身份证号有问题： (1)前17位中出现非数字；（2）最后一位校验码与计算得到的校验码不一致。 可以编写一个isValid函数（其内部对上述两种情况进行判断），用于判断给定的身份证号是否有效，若有效，则返回true；否则，返回false。 使用布尔变量allPassed表示输入的身份证号是否全部有效，默认为true。若有一个身份证号无效，则allPassed被设置为false。 输入结束后，通过判断allPassed是否为true，决定是否输出All passed。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;char arr[12] = &#123; '1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2', '\0' &#125;;int weight[17] = &#123; 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 &#125;;bool isValid(char idcard[]) &#123; int sum = 0; for (int i = 0; i &lt; 17; i++) &#123; int temp = idcard[i] - '0'; // 若前17位中存在非数字，则该号码有问题 if (temp &lt; 0 || temp &gt; 9) &#123; return false; &#125; sum += weight[i] * temp; &#125; // 比较最后一位校验码是否一致 sum %= 11; return idcard[17] == arr[sum];&#125;int main() &#123; int n; scanf("%d", &amp;n); bool allPassed = true; while (n--) &#123; char idcard[19]; scanf("%s", idcard); if (!isValid(idcard)) &#123; allPassed = false; printf("%s\n", idcard); &#125; &#125; if (allPassed) &#123; printf("All passed\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1021.个位数统计 (15 分)]]></title>
    <url>%2F2019%2F04%2F29%2Fpat-basic-1021%2F</url>
    <content type="text"><![CDATA[给定一个 k 位整数 N=$d_{k−1} 10^{k−1}+⋯+d_1 10^1+d_0 (0≤d_i≤9, i=0,⋯,k−1, d_{k−1}&gt;0)$，请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。 输入格式：每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。 输出格式：对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。 输入样例：1100311 输出样例：1230:21:33:1 分析：用整型数组count表示每种个位数字的出现次数，其下标表示个位数字，值表示对应数字的出现次数。 以字符串的形式读入k位整数n。遍历该字符串的每一位，将其转换为整型x，并让count[x] += 1。 最后以 个位数字:出现次数 的格式，输出数组count中值不为0的项。 1234567891011121314151617#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; int count[10] = &#123; 0 &#125;; char n[1001]; scanf("%s", n); for (int i = 0; i &lt; strlen(n); i++) &#123; count[n[i] - '0'] += 1; &#125; for (int i = 0; i &lt; 10; i++) &#123; if (count[i] != 0) &#123; printf("%d:%d\n", i, count[i]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1006.换个格式输出整数 (15 分)]]></title>
    <url>%2F2019%2F04%2F29%2Fpat-basic-1006%2F</url>
    <content type="text"><![CDATA[让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12...n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。 输入格式：每个测试输入包含 1 个测试用例，给出正整数 n（&lt;1000）。 输出格式：每个测试用例的输出占一行，用规定的格式输出 n。 输入样例 1：1234 输出样例 1：1BBSSS1234 输入样例 2：123 输出样例 2：1SS123 分析：给定整数data（data &lt; 1000），通过求商和取模操作，分别得到其百位数b、十位数s和个位数n。然后按照题目要求循环输出即可。 1234567891011121314151617181920#include &lt;cstdio&gt;int main() &#123; int data; scanf("%d", &amp;data); int b = data / 100; int s = data % 100 / 10; int n = data % 10; for (int i = 0; i &lt; b; i++) &#123; printf("B"); &#125; for (int i = 0; i &lt; s; i++) &#123; printf("S"); &#125; for (int i = 1; i &lt;= n; i++) &#123; printf("%d", i); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 148.排序链表]]></title>
    <url>%2F2019%2F04%2F26%2Fleetcode-148-sort-list%2F</url>
    <content type="text"><![CDATA[题目描述在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 解决方案本题可以采用归并排序。 通过快慢指针，仅遍历一次链表就可以找到中间位置，将链表一分为二。 然后对得到的两个链表递归执行sortList方法，最后对两个有序链表进行二路归并。 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445/*public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;*/class Solution &#123; // 合并两个有序链表 public ListNode merge(ListNode p,ListNode q) &#123; ListNode head = new ListNode(-1); ListNode r = head; while(p != null &amp;&amp; q != null) &#123; if(p.val &lt; q.val) &#123; r.next = p; r = p; p = p.next; &#125; else &#123; r.next = q; r = q; q = q.next; &#125; &#125; if(p != null) &#123; r.next = p; &#125; if(q != null) &#123; r.next = q; &#125; return head.next; &#125; public ListNode sortList(ListNode head) &#123; if(head == null || head.next == null) &#123; return head; &#125; // 通过快慢指针，寻找中间位置，将链表一分为二 ListNode p = head,q=head,pre=head; while(q != null &amp;&amp; q.next != null) &#123; pre = p; p = p.next; q = q.next.next; &#125; pre.next = null; return merge(sortList(head),sortList(p)); &#125;&#125; 复杂度分析设链表的长度为n 时间复杂度：O(n log n) 空间复杂度：O(n) 算法效率执行用时 : 12 ms, 在Sort List的Java提交中击败了37.49% 的用户 内存消耗 : 44.2 MB, 在Sort List的Java提交中击败了63.30% 的用户]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1009.说反话 （20 分)]]></title>
    <url>%2F2019%2F04%2F24%2Fpat-basic-1009%2F</url>
    <content type="text"><![CDATA[给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。 输出格式：每个测试用例的输出占一行，输出倒序后的句子。 输入样例：1Hello World Here I Come 输出样例：1Come I Here World Hello 分析：本题有一种很直接的思路：顺序存储每个单词，然后逆序输出即可。 1234567891011121314151617#include &lt;cstdio&gt;int main() &#123; char str[81][81]; int index = 0; while (scanf("%s", str[index]) != EOF) &#123; index++; &#125; for (int i = index - 1; i &gt;= 0; i--) &#123; printf("%s", str[i]); if(i &gt; 0) &#123; printf(" "); &#125; &#125; printf("\n"); return 0;&#125; 另一种思路是先获取输入的字符串，然后从后往前，每碰到空格或者当下标为0时，输出一个单词。 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;int main() &#123; char str[81]; char c; int index = 0; // PAT的编译器不支持gets() while((c = getchar()) != '\n' &amp;&amp; c != EOF) &#123; str[index++] = c; &#125; int end = index; for (int i = index - 1; i &gt;= 0; i--) &#123; if (i == 0 || str[i] == ' ') &#123; int start = i == 0 ? i : i + 1; // 输出一个单词 for (int j = start; j &lt; end; j++) &#123; printf("%c", str[j]); &#125; if (i &gt; 0) &#123; printf(" "); &#125; end = i; &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1058.A+B in Hogwarts （20 分)]]></title>
    <url>%2F2019%2F04%2F22%2Fpat-advanced-1058%2F</url>
    <content type="text"><![CDATA[If you are a fan of Harry Potter, you would know the world of magic has its own currency system – as Hagrid explained it to Harry, “Seventeen silver Sickles to a Galleon and twenty-nine Knuts to a Sickle, it’s easy enough.” Your job is to write a program to compute A+B where A and B are given in the standard form of Galleon.Sickle.Knut (Galleon is an integer in [0,10^7], Sickle is an integer in [0, 17), and Knut is an integer in [0, 29)). Input Specification:Each input file contains one test case which occupies a line with A and B in the standard form, separated by one space. Output Specification:For each test case you should output the sum of A and B in one line, with the same format as the input. Sample Input:13.2.1 10.16.27 Sample Output:114.1.28 分析：题目大意：在一种新的货币体系下，计算货币A、B之和。 思路： （1）一种很直接的思路是将输入的货币A、B转换为Knut的形式，然后相加，最后再转换成Galleon.Sickle.Knut格式。 这种解法需要注意的是，A、B之和sum可能会超过int的取值范围，因此，需要使用long long存储数据。 （2）另一种解法是相加进位。 用g、s、k分别表示A、B之和的Galleon、Sickle、Knut。先将A、B的Knut部分加到k上，若此时k大于等于29，则k -= 29，s+=1。然后将A、B的Sickle部分加到s上，若此时s大于等于17，则s -= 17，g+=1。最后将A、B的Galleon部分加到g上即可。 这里采用第二种解法，代码如下： 123456789101112131415161718192021#include &lt;cstdio&gt;int main() &#123; int g1, s1, k1, g2, s2, k2, g, s, k; scanf("%d.%d.%d %d.%d.%d", &amp;g1, &amp;s1, &amp;k1, &amp;g2, &amp;s2, &amp;k2); g = s = k = 0; k += k1 + k2; if (k &gt;= 29) &#123; //s += k / 29; k %= 29; k -= 29; s++; &#125; s += s1 + s2; if (s &gt;= 17) &#123; s -= 17; g++; &#125; g += g1 + g2; printf("%d.%d.%d\n", g, s, k); return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1027.Colors in Mars （20 分)]]></title>
    <url>%2F2019%2F04%2F21%2Fpat-advanced-1027%2F</url>
    <content type="text"><![CDATA[People in Mars represent the colors in their computers in a similar way as the Earth people. That is, a color is represented by a 6-digit number, where the first 2 digits are for Red, the middle 2 digits for Green, and the last 2 digits for Blue. The only difference is that they use radix 13 (0-9 and A-C) instead of 16. Now given a color in three decimal numbers (each between 0 and 168), you are supposed to output their Mars RGB values. Input Specification:Each input file contains one test case which occupies a line containing the three decimal color values. Output Specification:For each test case you should output the Mars RGB value in the following format: first output #, then followed by a 6-digit number where all the English characters must be upper-cased. If a single color is only 1-digit long, you must print a 0 to its left. Sample Input:115 43 71 Sample Output:1#123456 分析：题目大意：给定三个十进制数，将它们转换为13进制数输出。 已知给定的十进制数x不超过168，转换成13进制后，不超过两位（13进制下CC = 168）。 针对本题，一个比较巧妙的办法如下： 设置一个字符数组radix，将其初始化为“0123456789ABC”，这样，下标0对应字符’0’，下标13对应字符‘A’…转换后的13进制数可以由radix[x / 13]和radix[x % 13]拼接而成。 1234567891011#include &lt;cstdio&gt;int main() &#123; char radix[14] = "0123456789ABC"; int r, g, b; scanf("%d %d %d", &amp;r, &amp;g, &amp;b); printf("#"); printf("%c%c", radix[r / 13], radix[r % 13]); printf("%c%c", radix[g / 13], radix[g % 13]); printf("%c%c\n", radix[b / 13], radix[b % 13]);&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1019.General Palindromic Number （20 分)]]></title>
    <url>%2F2019%2F04%2F20%2Fpat-advanced-1019%2F</url>
    <content type="text"><![CDATA[A number that will be the same when it is written forwards or backwards is known as a Palindromic Number. For example, 1234321 is a palindromic number. All single digit numbers are palindromic numbers. Although palindromic numbers are most often considered in the decimal system, the concept of palindromicity can be applied to the natural numbers in any numeral system. Consider a number N&gt;0 in base b≥2, where it is written in standard notation with k+1 digits $a_i$ as $∑_{i=0}^k(a_i b^i)$. Here, as usual, 0≤$a_i$&lt;b for all i and $a_k$ is non-zero. Then N is palindromic if and only if $a_i=a_{k−i}$ for all i. Zero is written 0 in any base and is also palindromic by definition. Given any positive decimal integer N and a base b, you are supposed to tell if N is a palindromic number in base b. Input Specification:Each input file contains one test case. Each case consists of two positive numbers N and b, where 0&lt;N≤$10^9​$ is the decimal number and 2≤b≤$10^9​$ is the base. The numbers are separated by a space. Output Specification:For each test case, first print in one line Yes if N is a palindromic number in base b, or No if not. Then in the next line, print Nas the number in base b in the form “$a_k \ a_{k−1} \ … \ a_0$”. Notice that there must be no extra space at the end of output. Sample Input 1:127 2 Sample Output 1:12Yes1 1 0 1 1 Sample Input 2:1121 5 Sample Output 2:12No4 4 1 分析：题目要求：判断一个给定的十进制数n在b进制下，是否为回文数字（即从左到右与从右到左一样）。 思路：使用除基取余法，将十进制数n转换为b进制，并将结果反序保存在一个整型数组data中(低位在前，高位在后)。设转换后该数的长度为index，判断数组data的第i个元素与第index - i - 1个元素是否相等，若有一组不相等，则说明其不是回文数字。若全部相等，则说明其是回文数字。 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;int main() &#123; int n, b, index = 0; scanf("%d %d", &amp;n, &amp;b); int data[32]; do &#123; data[index++] = n % b; n /= b; &#125; while (n != 0); bool flag = true; for (int i = 0; i &lt; index; i++) &#123; if (data[i] != data[index - i - 1]) &#123; flag = false; break; &#125; &#125; if (flag) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; for (int i = index - 1; i &gt;= 0; i--) &#123; printf("%d", data[i]); if (i &gt; 0) &#123; printf(" "); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1037.在霍格沃茨找零钱 （20 分)]]></title>
    <url>%2F2019%2F04%2F19%2Fpat-basic-1037%2F</url>
    <content type="text"><![CDATA[如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱 P 和他实付的钱 A，你的任务是写一个程序来计算他应该被找的零钱。 输入格式：输入在 1 行中分别给出 P 和 A，格式为 Galleon.Sickle.Knut，其间用 1 个空格分隔。这里 Galleon 是 [0, 10^7] 区间内的整数，Sickle 是 [0, 17) 区间内的整数，Knut 是 [0, 29) 区间内的整数。 输出格式：在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。 输入样例 1：110.16.27 14.1.28 输出样例 1：13.2.1 输入样例 2：114.1.28 10.16.27 输出样例 2：1-3.2.1 分析：用g1.s1.k1表示应付的价钱price，g2.s2.k2表示实付的钱money，change表示应该被找的零钱。 首先，将输入的钱均转换为以纳特(Knut)为单位。转换规则：十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可。 然后，用money减去price得到change，若change小于0，则表示没带够钱，那么就输出一个负号，然后change取反。 最后，按照Galleon.Sickle.Knut的格式输出change即可。 12345678910111213141516171819#include &lt;cstdio&gt;const int Galleon = 17 * 29;const int Sickle = 29;int main() &#123; int g1, s1, k1, g2, s2, k2; scanf("%d.%d.%d %d.%d.%d", &amp;g1, &amp;s1, &amp;k1, &amp;g2, &amp;s2, &amp;k2); int price = g1 * Galleon + s1 * Sickle + k1; int money = g2 * Galleon + s2 * Sickle + k2; int change = money - price; if (change &lt; 0) &#123; printf("-"); change = -change; &#125; printf("%d.%d.%d\n", change / Galleon, change % Galleon / Sickle, change % Sickle); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“进制转换”编程题总结]]></title>
    <url>%2F2019%2F04%2F18%2Fprogramming-test-radix-conversion%2F</url>
    <content type="text"><![CDATA[在日常生活中我们一般使用十进制数字，而计算机使用的却是二进制。此外，常见的进制还有八进制、十六进制等。对于两个不同进制，应该如何进行相互转换呢？这里总结下该问题的解题思路。 对于一个P进制的数，如果要转换为Q进制（2 ≤ P , Q ≤ 16），可以分为两步： （1）将P进制数x转换为十进制数y。 （2）将十进制数y转换为Q进制数z。 将P进制数x转换为十进制数y一个P进制数$x=a_1 a_2 \dots a_n$，写成如下形式后，使用十进制的加法和乘法，就可以转换为十进制数y：$$y = a_1 \times P^{n-1} + a_2 \times p^{n-2} + \dots + a_{n-1} \times P + a_n$$这个公式可以用下面的代码实现： 123456int y = 0, product = 1;while (x != 0) &#123; y += (x % 10) * product; x /= 10;//每循环一次丢弃一位 product *= p;&#125; 将十进制数y转换为Q进制数z可以采用”除基取余法“。这里的“基”，是指要转换成的进制Q。因此除基取余的意思就是每次将待转换数除以Q，然后将得到的余数作为低位存储，而商则继续除以Q并继续进行上面的操作，直到商为0时，退出循环。此时，将所有位从后向前输出就可以得到z。 上述过程可以用下面的代码实现： 12345int z[20], i = 0;do &#123; z[i++] = y % Q; y /= Q;&#125; while (y != 0); 执行完后，数组z从高位i-1到低位0即为Q进制整数z。这里之所以采用do…while循环而不采用while循环，是因为当y恰好等于0时，while循环不会执行，导致结果出错。 参考文献[1] 胡凡，曾磊.《算法笔记》[M].北京：机械工业出版社，2016]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“日期处理”编程题总结]]></title>
    <url>%2F2019%2F04%2F18%2Fprogramming-test-date-handle%2F</url>
    <content type="text"><![CDATA[日期处理是一类令人感到头疼的编程题，这里总结下该问题的解题思路。 要解决它，必须先处理好平年和闰年，以及由此产生的二月天数不同、大月和小月等基本问题。 首先，我们可以使用一个二维数组months表示平年和闰年中每月的天数： 123int month[13][2] = &#123; &#123; 0, 0 &#125;, &#123; 31, 31 &#125;, &#123; 28, 29 &#125;, &#123; 31, 31 &#125;, &#123; 30, 30 &#125;, &#123;31, 31 &#125;, &#123; 30, 30 &#125;, &#123; 31, 31 &#125;, &#123; 31, 31 &#125;, &#123; 30, 30 &#125;, &#123; 31, 31 &#125;, &#123;30, 30 &#125;, &#123; 31, 31 &#125; &#125;; 然后，我们还需要解决平年和闰年的判别问题： 123bool isLeap(int year) &#123; return year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0);&#125; 处理好了这些基本问题，接下来我们探讨下“日期处理”问题的各个类别及其对应的解题思路。 ”日期处理“编程题大致可以分为以下几类： 求日期之间相差天数求解这类问题有一个很直接的思路，即令日期不断加1天，直到第一个日期等于第二个日期为止。 具体做法是，如果加了1天之后天数d等于当前月份m所拥有的天数加1，那么就令月份加1，同时将天数d重置为1（即把日期变为下一个月的1号）；如果此时月份m变为了13，那么就令年份y加1，同时将月份m重置为1（即把日期变为下一年的1月）。 假设给定的两个日期分别为y1年m1月d1日、y2年m2月d2日，求解该问题的算法如下： 12345678910111213int count = 0;while (y1 &lt; y2 || m1 &lt; m2 || d1 &lt; d2) &#123; d1++; if (d1 == month[m1][isLeap(y1)] + 1) &#123; m1++; d1 = 1; &#125; if (m1 == 13) &#123; y1++; m1 = 1; &#125; count++;&#125; 上述方法虽然简单，但可能会比较慢。如果想要加快速度，只需要先把第一个日期的年份不断加1，直到与第二个日期的年份差1为止，期间根据平年或闰年来累加365天或者366天即可。之后再进行不断令天数加1的操作。改进后的算法如下： 1234567891011121314151617181920int count = 0;while(y1 &lt; y2 - 1) &#123; y1++; count += 365; if(isLeap(y1)) &#123; count += 1; &#125;&#125;while (y1 &lt; y2 || m1 &lt; m2 || d1 &lt; d2) &#123; d1++; if (d1 == month[m1][isLeap(y1)] + 1) &#123; m1++; d1 = 1; &#125; if (m1 == 13) &#123; y1++; m1 = 1; &#125; count++;&#125; 该问题还有另一种变体：给定一个日期和相差的天数，求该日期加上（减去）给定天数后的日期。 假设给定的日期为y年m月d日，相差的天数为days天，求解该问题的算法如下： 12345678910111213// 日期累加算法// for(int i=days;i&gt;0;i--)while (days--) &#123; d++; if (d == month[m][isLeap(y)] + 1) &#123; m++; d = 1; &#125; if (m == 13) &#123; y++; m = 1; &#125;&#125; 求某天是星期几这类问题，其实可以转换为求日期之间相差天数。 具体做法是，计算给定日期y年m月d日与已知星期week的日期两者之间相差的天数days，然后让相差天数days对7取模（一周七天），求得余数r，计算r与week之间的间隔，从而得到最终的星期w。 假设已知某个日期date1是星期w1，要求日期date2（假设晚于date1）是星期w，两者相差days天，求解该问题的算法如下： 123int r = days % 7;// 这里星期日用0表示w = (w1 + r) % 7; 若要求的日期date2早于已知日期date1，只需要按如下方式修改上面第三行代码即可。 1w = (w1 - r + 7) % 7; 求某天是几月几日给定年份和第几天，求该天是几月几号。这类问题与问题一“求日期之间相差天数”的变体十分类似。 具体做法是，从1月0日开始，每次加1天，然后调整月份（或年份），直至用完给定的天数。 假设给定的年份为year，天数为days，求解该问题的算法如下： 123456789101112int m = 1, d = 0;while (days--) &#123; d++; if (d == month[m][isLeap(y)] + 1) &#123; m++; d = 1; &#125; if (m == 13) &#123; y++; m = 1; &#125;&#125; 参考文献[1] 胡凡，曾磊.《算法笔记》[M].北京：机械工业出版社，2016]]></content>
      <categories>
        <category>程序设计</category>
      </categories>
      <tags>
        <tag>程序设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1022.D进制的A+B （20 分)]]></title>
    <url>%2F2019%2F04%2F17%2Fpat-basic-1022%2F</url>
    <content type="text"><![CDATA[输入两个非负 10 进制整数 A 和 B (≤2^30−1)，输出 A+B 的 D (1&lt;D≤10)进制数。 输入格式：输入在一行中依次给出 3 个整数 A、B 和 D。 输出格式：输出 A+B 的 D 进制数。 输入样例：1123 456 8 输出样例：11103 分析：设sum = a + b，采用“除基取余法”，将每次sum % d的结果存储在int数组data中，然后令 sum /= d，直至sum==0成立为止。此时数组data中，倒序保存着sum在d进制下每一位的结果。 123456789101112131415161718#include &lt;cstdio&gt;int main() &#123; int a, b, d, sum; int data[32]; scanf("%d %d %d", &amp;a, &amp;b, &amp;d); sum = a + b; int i = 0; do &#123; data[i++] = sum % d; sum /= d; &#125; while (sum != 0); for (int j = i - 1; j &gt;= 0; j--) &#123; printf("%d", data[j]); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1031.Hello World for U （20 分)]]></title>
    <url>%2F2019%2F04%2F15%2Fpat-advanced-1031%2F</url>
    <content type="text"><![CDATA[Given any string of N (≥5) characters, you are asked to form the characters into the shape of U. For example, helloworld can be printed as: 1234h de ll rlowo That is, the characters must be printed in the original order, starting top-down from the left vertical line with n1characters, then left to right along the bottom line with n2 characters, and finally bottom-up along the vertical line with n3 characters. And more, we would like U to be as squared as possible – that is, it must be satisfied that n1=n3=max { k | k≤n2 for all 3≤n2≤N } with n1+n2+n3−2=N. Input Specification:Each input file contains one test case. Each case contains one string with no less than 5 and no more than 80 characters in a line. The string contains no white space. Output Specification:For each test case, print the input string in the shape of U as specified in the description. Sample Input:1helloworld! Sample Output:1234h !e dl llowor 分析：题目要求：将输入的字符串以U型图案的方式输出。n1和n3分别是U型图案左右两条竖线的字符数，n2是底部横线的字符数。 约束条件： 1.n1=n3 2.n1≤n2 3.U型图案尽可能方，即n1在满足上述条件的情况下尽可能大 思路：字符串长度n=n1+n2+n3-2，从而2×n1+n2=n+2，下面分情况讨论： 1.若(n+2) % 3 == 0，即n+2刚好被3整除，此时n1=n2=n3； 2.若(n+2) % 3 == 1，由于n1=n3且n1≤n2，故n1=n2=(n+2) / 3，n2=(n+2) / 3 + 1； 3.若(n+2) % 3 == 2，故n1=n2=(n+2) / 3，n2=(n+2) / 3 + 2。 因此，n1=n3=(n+2) / 3，n2 = (n+2) / 3 + (n+2) % 3。 12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; char str[81]; scanf("%s", str); int n = strlen(str); int n1, n2, n3; n1 = n3 = (n + 2) / 3; n2 = (n + 2) / 3 + (n + 2) % 3; //输出U型图案的左右两侧(不包括属于底部横线的部分) for (int i = 0; i &lt; n1 - 1; i++) &#123; printf("%c", str[i]); for (int j = 0; j &lt; n2 - 2; j++) &#123; printf(" "); &#125; printf("%c\n", str[n - i - 1]); &#125; //输出底部的横线 for (int i = 0; i &lt; n2; i++) &#123; printf("%c", str[n1 + i - 1]); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1027.打印沙漏 （20 分)]]></title>
    <url>%2F2019%2F04%2F14%2Fpat-basic-1027%2F</url>
    <content type="text"><![CDATA[本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 12345***** *** * ******** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。 输入格式:输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。 输出格式:首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。 输入样例:119 * 输出样例:123456***** *** * ********2 分析：设沙漏的行数为x，则组成沙漏需要的符号数为$$\begin{align}m &amp;= 1 + 2\times(3+5+\dots+x)\\&amp;=2(1+3+5+\dots+x)-1\end{align}$$下面我们来推导下奇数求和公式：$$\begin{align}sum &amp;= 1+3+5+\dots+x\\&amp;=1+2+3+4+\dots+x-(2+4+\dots+x-1)\\&amp;=1+2+3+\dots+x-2(1+2+\dots+\frac{x-1}{2})\\&amp;=\frac{x(x+1)}{2} - 2\times\frac{\frac{x-1}{2}(\frac{x-1}{2}+1)}{2}\\&amp;=\frac{(x+1)^2}{4}\end{align}$$因此，组成沙漏需要的符号数$m=2 \times \frac{(x+1)^2}{4} - 1 = \frac{(x+1)^2}{2} - 1$ 在给定符号数n的情况下，要找出所能组成的最大沙漏，只需要找出满足m&lt;=n的最大x即可。 沙漏的上半部分有$\frac{x}{2}+1$行，每行的符号数为$x-2i$，i表示行号(从0开始)，左侧空格数为$i$。 沙漏的下半部分有$\frac{x}{2}​$行，每行的符号数为$2i+1​$，i表示行号(从0开始)，左侧空格数为$\frac{x-(2i+1)}{2}​$。 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;int main() &#123; int n, x = 1; char c; scanf("%d %c", &amp;n, &amp;c); //寻找所能组成的最大沙漏 while ((x + 1) * (x + 1) / 2 - 1 &lt;= n) &#123; x += 2; &#125; x -= 2; //输出沙漏的上半部分 for (int i = 0; i &lt; x / 2 + 1; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; printf(" "); &#125; for (int j = 0; j &lt; x - 2 * i; j++) &#123; printf("%c", c); &#125; printf("\n"); &#125; //输出沙漏的下半部分 for (int i = 1; i &lt; x / 2 + 1; i++) &#123; for (int j = 0; j &lt; (x - (2 * i + 1)) / 2; j++) &#123; printf(" "); &#125; for (int j = 0; j &lt; 2 * i + 1; j++) &#123; printf("%c", c); &#125; printf("\n"); &#125; printf("%d\n", n - ((x + 1) * (x + 1) / 2 - 1)); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1036.跟奥巴马一起编程 （15 分)]]></title>
    <url>%2F2019%2F04%2F12%2Fpat-basic-1036%2F</url>
    <content type="text"><![CDATA[美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014 年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！ 输入格式：输入在一行中给出正方形边长 N（3≤N≤20）和组成正方形边的某种字符 C，间隔一个空格。 输出格式：输出由给定字符 C 画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。 输入样例：110 a 输出样例：12345aaaaaaaaaaa aa aa aaaaaaaaaaa 分析：“为了让结果看上去更像正方形，我们输出的行数实际上是列数的 50%（四舍五入取整）。” 设列数为n，行数为row。 当n为奇数（n % 2 == 1）时，row = n / 2 + 1； 当n为偶数（n % 2 == 0）时，row = n / 2。 因此，我们可以得出row = n / 2 + n % 2。 首先输出第一行的n个c。然后输出中间row-2行，此时只有最左边和最右边各有一个c，中间有n-2个空格。最后输出最后一行的n个c。 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;int main() &#123; int n, row; char c; scanf("%d %c", &amp;n, &amp;c); //若n为奇数，则n % 2 == 1,row = n / 2 + 1; //若n为偶数，则row = n / 2; row = n / 2 + n % 2; for (int i = 0; i &lt; n; i++) &#123; printf("%c", c); &#125; printf("\n"); for (int i = 1; i &lt; row - 1; i++) &#123; printf("%c", c); for (int j = 0; j &lt; n - 2; j++) &#123; printf(" "); &#125; printf("%c\n", c); &#125; for (int i = 0; i &lt; n; i++) &#123; printf("%c", c); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1036.Boys vs Girls （25 分)]]></title>
    <url>%2F2019%2F04%2F12%2Fpat-advanced-1036%2F</url>
    <content type="text"><![CDATA[This time you are asked to tell the difference between the lowest grade of all the male students and the highest grade of all the female students. Input Specification:Each input file contains one test case. Each case contains a positive integer N, followed by N lines of student information. Each line contains a student’s name, gender, ID and grade, separated by a space, where name and ID are strings of no more than 10 characters with no space, gender is either F (female) or M (male), and gradeis an integer between 0 and 100. It is guaranteed that all the grades are distinct. Output Specification:For each test case, output in 3 lines. The first line gives the name and ID of the female student with the highest grade, and the second line gives that of the male student with the lowest grade. The third line gives the difference $grade_F−grade_M$. If one such kind of student is missing, output Absent in the corresponding line, and output NAin the third line instead. Sample Input 1:12343Joe M Math990112 89Mike M CS991301 100Mary F EE990830 95 Sample Output 1:123Mary EE990830Joe Math9901126 Sample Input 2:121Jean M AA980920 60 Sample Output 2:123AbsentJean AA980920NA 分析：1.定义结构体类型Person，包含学生姓名name、性别gender、学号id以及成绩grade。 2.用boy、girl分别表示分数最低的男生、分数最高的女生。并为他们的成绩grade字段初始化，boy的成绩grade赋值为101，girl的成绩grade赋值-1。用person接受每次输入的信息。 3.若当前person为男性、且成绩低于boy，则将其赋给boy。若当前person为女性，且成绩高于girl，则将其赋给girl。 4.在输出前，需要分别判断boy.grade == 101、girl.grade == -1 是否成立。若成立，则表示不存在该性别的同学，对应行要输出“Absent”。以上两个条件只要有一个成立，最后girl与boy的分数差就输出“NA”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;struct Person &#123; char name[11]; char gender; char id[11]; int grade;&#125;;int main() &#123; int n; scanf("%d", &amp;n); //boy表示分数最低的男学生、girl表示分数最高的女学生 Person boy, girl, person; boy.grade = 101; girl.grade = -1; for (int i = 0; i &lt; n; i++) &#123; scanf("%s %c %s %d", person.name, &amp;person.gender, person.id, &amp;person.grade); if (person.gender == 'M' &amp;&amp; person.grade &lt; boy.grade) &#123; boy = person; &#125; if (person.gender == 'F' &amp;&amp; person.grade &gt; girl.grade) &#123; girl = person; &#125; &#125; bool isMissing = false; if (girl.grade == -1) &#123; isMissing = true; printf("Absent\n"); &#125; else &#123; printf("%s %s\n", girl.name, girl.id); &#125; if (boy.grade == 101) &#123; isMissing = true; printf("Absent\n"); &#125; else &#123; printf("%s %s\n", boy.name, boy.id); &#125; if (isMissing) &#123; printf("NA\n"); &#125; else &#123; printf("%d\n", girl.grade - boy.grade); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1006.Sign In and Sign Out （25 分)]]></title>
    <url>%2F2019%2F04%2F11%2Fpat-advanced-1006%2F</url>
    <content type="text"><![CDATA[At the beginning of every day, the first person who signs in the computer room will unlock the door, and the last one who signs out will lock the door. Given the records of signing in’s and out’s, you are supposed to find the ones who have unlocked and locked the door on that day. Input Specification:Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format: 1ID_number Sign_in_time Sign_out_time where times are given in the format HH:MM:SS, and ID_number is a string with no more than 15 characters. Output Specification:For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space. Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment. Sample Input:12343CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40 Sample Output:1SC3021234 CS301133 分析：题目要求：输出最早来的人和最晚走的人的id_number。 1.定义结构体类型Person，存储人的编号idNumber、第一次打卡（Sign in）时间signIn、第二次打卡（Sign out）时间signOut。 2.用unlock、lock分别表示开门和关门的人。 3.每当输入一个人的编号及其sign in和sign out时间，若其sign in比unlock早，则将其赋给unlock，若其sign out比lock晚，则将其赋给lock。 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;struct Person &#123; char idNumber[16]; char signIn[9]; char signOut[9];&#125;;int main() &#123; int m; scanf("%d", &amp;m); Person persons[m]; Person unlock, lock; strcpy(unlock.signIn, "23:59:59"); strcpy(lock.signOut, "00:00:00"); for (int i = 0; i &lt; m; i++) &#123; scanf("%s %s %s", persons[i].idNumber, persons[i].signIn, persons[i].signOut); if (strcmp(unlock.signIn, persons[i].signIn) &gt; 0) &#123; unlock = persons[i]; &#125; if (strcmp(lock.signOut, persons[i].signOut) &lt; 0) &#123; lock = persons[i]; &#125; &#125; printf("%s %s\n", unlock.idNumber, lock.idNumber); return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1011.World Cup Betting （20 分)]]></title>
    <url>%2F2019%2F04%2F11%2Fpat-advanced-1011%2F</url>
    <content type="text"><![CDATA[With the 2010 FIFA World Cup running, football fans the world over were becoming increasingly excited as the best players from the best teams doing battles for the World Cup trophy in South Africa. Similarly, football betting fans were putting their money where their mouths were, by laying all manner of World Cup bets. Chinese Football Lottery provided a “Triple Winning” game. The rule of winning was simple: first select any three of the games. Then for each selected game, bet on one of the three possible results – namely W for win, T for tie, and L for lose. There was an odd assigned to each result. The winner’s odd would be the product of the three odds times 65%. For example, 3 games’ odds are given as the following: 1234 W T L1.1 2.5 1.71.2 3.1 1.64.1 1.2 1.1 To obtain the maximum profit, one must buy W for the 3rd game, T for the 2nd game, and T for the 1st game. If each bet takes 2 yuans, then the maximum profit would be (4.1×3.1×2.5×65%−1)×2=39.31 yuans (accurate up to 2 decimal places). Input Specification:Each input file contains one test case. Each case contains the betting information of 3 games. Each game occupies a line with three distinct odds corresponding to W, T and L. Output Specification:For each test case, print in one line the best bet of each game, and the maximum profit accurate up to 2 decimal places. The characters and the number must be separated by one space. Sample Input:1231.1 2.5 1.71.2 3.1 1.64.1 1.2 1.1 Sample Output:1T T W 39.31 分析：题目要求：给定三场比赛，及每场比赛赢W、平分T、输L的赔率，选取每场比赛赔率最大的结果下注（赔率分别记为a、b、c），以期获得最大收益。 分别输出三场比赛的下注情况（W、T 或 L），然后按照（a × b × c × 0.65 - 1）× 2计算收益。 12345678910111213141516171819202122232425#include &lt;cstdio&gt;int main() &#123; const int n = 3; char results[n + 1] = &#123; "WTL" &#125;; double x; double rate = 0.65; int perBetMoney = 2; double product = 1.0; for (int i = 0; i &lt; n; i++) &#123; double maxValue = 0.0; int maxChar = 0; for (int j = 0; j &lt; n; j++) &#123; scanf("%lf", &amp;x); if (x &gt; maxValue) &#123; maxValue = x; maxChar = j; &#125; &#125; product *= maxValue; printf("%c ", results[maxChar]); &#125; printf("%.2f\n", (product * rate - 1) * perBetMoney); return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1032.挖掘机技术哪家强 （20 分)]]></title>
    <url>%2F2019%2F04%2F11%2Fpat-basic-1032%2F</url>
    <content type="text"><![CDATA[为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。 输入格式：输入在第 1 行给出不超过 10^5 的正整数 N，即参赛人数。随后 N 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。 输出格式：在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。 输入样例：123456763 652 801 1002 703 403 0 输出样例：12 150 分析：用数组scores保存每个学校的编号及其对应的分数，数组下标为学校编号，值为对应的分数。 用maxNo、maxScore表示总得分最高的学校的编号、及其总分，均初始化为0。 每当输入一个编号no和分数score时，让scores[no]增加score，然后与maxScore进行比较，若比maxScore大，则将no、scores[no]分别赋给maxNo、maxScore。 12345678910111213141516171819#include &lt;cstdio&gt;int main() &#123; int n; scanf("%d", &amp;n); int scores[100001] = &#123; 0 &#125;; int maxNo, maxScore, no, score; maxNo = maxScore = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%d %d", &amp;no, &amp;score); scores[no] += score; if (scores[no] &gt; maxScore) &#123; maxNo = no; maxScore = scores[no]; &#125; &#125; printf("%d %d\n", maxNo, maxScore); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1028.人口普查 （20 分)]]></title>
    <url>%2F2019%2F04%2F10%2Fpat-basic-1028%2F</url>
    <content type="text"><![CDATA[某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。 这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。 输入格式：输入在第一行给出正整数 N，取值在(0,10^5]；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 yyyy/mm/dd（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。 输出格式：在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。 输入样例：1234565John 2001/05/12Tom 1814/09/06Ann 2121/01/30James 1814/09/05Steve 1967/11/20 输出样例：13 Tom John 分析：1.定义结构体类型Person，存储人的姓名name、出生年year、月month、日day。 2.设定年龄的左右边界，用maxPerson表示具有合理的最大年龄（1814年9月6日）的人，current表示具有合理的最小年龄（2014年9月6日）的人。用youngest表示镇上最年轻的人，oldest表示镇上最年长者，并对他们初始化，分别赋值为maxPerson和current。用count表示输入有效生日的个数。 3.每当读入一个人的信息时，需要先判断其年龄是否合理（不小于current的年龄，且不超过maxPerson的年龄）。若合理，则将其年龄分别与youngest、oldest的年龄比较。若其年龄比youngest小，则将其赋给youngest。若其年龄比oldest大，则将其赋给oldest。然后count增加1。 需要注意的是，最终得到的count有可能为0，即输入的测试用例均为无效生日，此时count后没有空格，否则会因为多出一个空格而报“格式错误”。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;struct Person &#123; char name[6]; int year; int month; int day;&#125;;//若p1比p2的年龄大，则返回1；若一样大，返回0；否则，返回-1；int old(Person p1, Person p2) &#123; if (p1.year &lt; p2.year) &#123; return 1; &#125; if (p1.year == p2.year) &#123; if (p1.month &lt; p2.month) &#123; return 1; &#125; if (p1.month == p2.month) &#123; if (p1.day &lt; p2.day) &#123; return 1; &#125; if (p1.day == p2.day) &#123; return 0; &#125; &#125; &#125; return -1;&#125;int main() &#123; int n; int currentYear = 2014, currentMonth = 9, currentDay = 6, maxAge = 200; scanf("%d", &amp;n); Person youngest, oldest, current, maxPerson; maxPerson.year = currentYear - maxAge; maxPerson.month = currentMonth; maxPerson.day = currentDay; current.year = currentYear; current.month = currentMonth; current.day = currentDay; oldest = current; youngest = maxPerson; Person person[n]; int count = 0; for (int i = 0; i &lt; n; i++) &#123; scanf("%s %d/%d/%d", person[i].name, &amp;person[i].year, &amp;person[i].month, &amp;person[i].day); if (old(person[i], current) &gt;= 0 &amp;&amp; old(maxPerson, person[i]) &gt;= 0) &#123; if (old(person[i], oldest) == 1) &#123; oldest = person[i]; &#125; if (old(youngest, person[i]) == 1) &#123; youngest = person[i]; &#125; count++; &#125; &#125; printf("%d", count); if (count &gt; 0) &#123; printf(" %s %s", oldest.name, youngest.name); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1004.成绩排名 （20 分)]]></title>
    <url>%2F2019%2F04%2F10%2Fpat-basic-1004%2F</url>
    <content type="text"><![CDATA[读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式：每个测试输入包含 1 个测试用例，格式为 12345第 1 行：正整数 n第 2 行：第 1 个学生的姓名 学号 成绩第 3 行：第 2 个学生的姓名 学号 成绩 ... ... ...第 n+1 行：第 n 个学生的姓名 学号 成绩 其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式：对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。 输入样例：12343Joe Math990112 89Mike CS991301 100Mary EE990830 95 输出样例：12Mike CS991301Joe Math990112 分析：1.定义一个结构体类型Student，存储学生的姓名name、学号no和成绩grade。 2.定义两个Student型变量maxGradeStu、minGradeStu分别表示成绩最高、最低的学生，并为maxGradeStu和minGradeStu的成绩grade初始化，分别设为101和0。 3.每读入一个学生信息，就将其成绩grade与maxGradeStu、minGradeStu的成绩比较，若高于maxGradeStu，则将该学生信息赋给maxGradeStu，若低于minGradeStu，则将该学生赋给minGradeStu。 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;struct Student &#123; char name[11]; char no[11]; int grade;&#125;;int main() &#123; int n; scanf("%d", &amp;n); Student stu[n]; Student maxGradeStu, minGradeStu; maxGradeStu.grade = 0; minGradeStu.grade = 101; for (int i = 0; i &lt; n; i++) &#123; scanf("%s %s %d", stu[i].name, stu[i].no, &amp;stu[i].grade); if (maxGradeStu.grade &lt; stu[i].grade) &#123; maxGradeStu = stu[i]; &#125; if (minGradeStu.grade &gt; stu[i].grade) &#123; minGradeStu = stu[i]; &#125; &#125; printf("%s %s\n", maxGradeStu.name, maxGradeStu.no); printf("%s %s\n", minGradeStu.name, minGradeStu.no); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1041.考试座位号 （15 分)]]></title>
    <url>%2F2019%2F04%2F10%2Fpat-basic-1041%2F</url>
    <content type="text"><![CDATA[每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。 输入格式：输入第一行给出一个正整数 N（≤1000），随后 N 行，每行给出一个考生的信息：准考证号 试机座位号 考试座位号。其中准考证号由 16 位数字组成，座位从 1 到 N 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。 考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M 个待查询的试机座位号码，以空格分隔。 输出格式：对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。 输入样例：123456743310120150912233 2 43310120150912119 4 13310120150912126 1 33310120150912002 3 223 4 输出样例：123310120150912002 23310120150912119 1 分析：根据题目要求，可先定义如下的Struct类型 1234struct Student &#123; long long permitNo;//16位数字，超过了int的存储范围 int examSeatNumber;&#125;; 可以采用哈希表的思想，将输入的“试机座位号”作为Student数组的下标，以方便查找考试座位号等信息。 12345678910111213141516171819202122232425#include &lt;cstdio&gt;struct Student &#123; long long permitNo; int examSeatNumber;&#125;;int main() &#123; int n, m, testSeatNumber, examSeatNumber; long long permitNo; scanf("%d", &amp;n); Student stus[n + 1];//座位号从1到N编号，故定义数组时增加一个长度 for (int i = 0; i &lt; n; i++) &#123; scanf("%lld %d %d", &amp;permitNo, &amp;testSeatNumber, &amp;examSeatNumber); stus[testSeatNumber].permitNo = permitNo; stus[testSeatNumber].examSeatNumber = examSeatNumber; &#125; scanf("%d", &amp;m); while (m--) &#123; scanf("%d", &amp;testSeatNumber); printf("%lld %d\n", stus[testSeatNumber].permitNo, stus[testSeatNumber].examSeatNumber); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1009.Product of Polynomials （25 分)]]></title>
    <url>%2F2019%2F04%2F08%2Fpat-advanced-1009%2F</url>
    <content type="text"><![CDATA[This time, you are supposed to find A×B where A and B are two polynomials. Input Specification:Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: $K N_1 a_{N1} N_2 a_{N2} … N_K a_{NK}$ where K is the number of nonzero terms in the polynomial, $N_i​$ and $a_{Ni}​$ (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，$0≤N_K&lt;⋯&lt;N_2&lt;N_1≤1000​$. Output Specification:For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input:122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output:13 3 3.6 2 6.0 1 1.6 分析：题目要求：计算两个多项式A、B的乘积。 思路：多项式的乘法运算可以转换为多项式的加法运算（多项式加法运算请参看PAT甲级 1002.A+B for Polynomials （25 分)）。 用double型的数组polynomial存储输入的第一个多项式A，用double型数组polynomial2表示多项式A、B的乘积。 可以采用哈希表的思想，数组polynomial的下标表示指数，值表示系数，如polynomial[n]表示一个指数为n、系数为polynomial[n]的单项式，数组polynomial2亦如此。 在输入第二个多项式B时，每输入一项（指数exponent和系数coefficient）时，用该项乘以多项式A，即乘以数组polynomial中值不为零的项。当B中的一项乘以A中的第j项时，将数组polynomial2对应下标为 j + exponent的值增加polynomial[j] ×coefficient，即polynomial2[j+exponent] += polynomial[j] ×coefficient。 需要注意的是，指数N≤1000，两个多项式相乘得到的结果中，指数最大为2000，故polynomial2的长度应设置为2001。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;int main() &#123; //指数不超过1000 const int MAX = 1000; int k, exponent; double coefficient; double polynomial[MAX + 1] = &#123; 0 &#125;, polynomial2[2 * MAX + 1] = &#123; 0 &#125;; scanf("%d", &amp;k); for (int i = 0; i &lt; k; i++) &#123; scanf("%d %lf", &amp;exponent, &amp;coefficient); polynomial[exponent] = coefficient; &#125; scanf("%d", &amp;k); for (int i = 0; i &lt; k; i++) &#123; scanf("%d %lf", &amp;exponent, &amp;coefficient); for (int j = 0; j &lt; MAX + 1; j++) &#123; if (polynomial[j] != 0) &#123; polynomial2[j + exponent] += polynomial[j] * coefficient; &#125; &#125; &#125; int count = 0; for (int i = 0; i &lt; 2 * MAX + 1; i++) &#123; if (polynomial2[i] != 0) &#123; count++; &#125; &#125; printf("%d", count); for (int i = 2 * MAX; i &gt;= 0; i--) &#123; if (polynomial2[i] != 0) &#123; printf(" %d %.1f", i, polynomial2[i]); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1002.A+B for Polynomials （25 分)]]></title>
    <url>%2F2019%2F04%2F08%2Fpat-advanced-1002%2F</url>
    <content type="text"><![CDATA[This time, you are supposed to find A+B where A and B are two polynomials. Input Specification:Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: $K N_1 a_{N1} N_2 a_{N2} … N_K a_{NK}$ where K is the number of nonzero terms in the polynomial, $N_i​$ and $a_{Ni}​$ (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，$0≤N_K&lt;⋯&lt;N_2&lt;N_1≤1000​$. Output Specification:For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input:122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output:13 2 1.5 1 2.9 0 3.2 分析：题目要求：计算两个多项式A、B的和。 可以采用哈希表的思想来实现，使用一个double型的数组polynomial（长度为1001，指数N≤1000）来存储多项式，其下标表示指数，值表示该指数对应的系数，如polynomial[n]表示一个指数为n、系数为polynomial[n]的单项式。 经过两次输入的累加操作后，polynomial中存储着两个多项式的和。 输出前，先遍历一次polynomial得到其中非零项的个数。然后从后往前遍历数组polynomial，输出值不为零的下标（指数）及其对应值（系数）。 12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;int main() &#123; int k, exponent; int line = 2; const int MAX = 1001; double coefficient; double polynomials[MAX] = &#123; 0 &#125;; while (line--) &#123; scanf("%d", &amp;k); for (int i = 0; i &lt; k; i++) &#123; scanf("%d %lf", &amp;exponent, &amp;coefficient); polynomials[exponent] += coefficient; &#125; &#125; int len = 0; for (int i = 0; i &lt; MAX; i++) &#123; if (polynomials[i] != 0) &#123; len++; &#125; &#125; printf("%d", len); for (int i = MAX - 1; i &gt;= 0; i--) &#123; if (polynomials[i] != 0) &#123; printf(" %d %.1f", i, polynomials[i]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1010.一元多项式求导 （25 分)]]></title>
    <url>%2F2019%2F04%2F07%2Fpat-basic-1010%2F</url>
    <content type="text"><![CDATA[设计函数求一元多项式的导数。（注：$x^n$（n为整数）的一阶导数为$nx^{n−1}$。） 输入格式:以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。 输出格式:以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 0 0。 输入样例:13 4 -5 2 6 1 -2 0 输出样例:112 3 -10 1 6 0 分析：高中数学告诉我们：$ax^b$的一阶导数为$abx^{b-1}$。 用coefficient和exponent分别表示多项式非零项的系数和指数，则该单项式的一阶导数为$coefficient \times exponent\ x^{exponent - 1}​$。 若单项式的指数exponent = 0，其一阶导数为0，不需要输出。故循环输入时，只需考虑指数exponent != 0的情况即可。 用bool型的变量flag表示是否已经有过输出，默认为false，即没有输出。若已有输出，即flag == true，则在本次输出之前，先输出一个空格，以此保证结尾不会有多余空格。 值得注意的是，输入的测试用例可能为零多项式。因此，在程序的最后需要判断flag == false是否成立，若成立，则表示输入的多项式为零多项式，此时需输出“0 0”。 123456789101112131415161718192021#include &lt;cstdio&gt;int main() &#123; int coefficient; int exponent; //判断是否已经有过输出 bool flag = false; while (scanf("%d %d", &amp;coefficient, &amp;exponent) != EOF) &#123; if (exponent != 0) &#123; if (flag) &#123; printf(" "); &#125; printf("%d %d", coefficient * exponent, exponent - 1); flag = true; &#125; &#125; if(!flag) &#123; printf("0 0"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1065.A+B and C (64bit) （20 分)]]></title>
    <url>%2F2019%2F04%2F06%2Fpat-advanced-1065%2F</url>
    <content type="text"><![CDATA[Given three integers A, B and C in [−2^63,2^63], you are supposed to tell whether A+B&gt;C. Input Specification:The first line of the input gives the positive number of test cases, T (≤10). Then T test cases follow, each consists of a single line containing three integers A, B and C, separated by single spaces. Output Specification:For each test case, output in one line Case #X: true if A+B&gt;C, or Case #X: false otherwise, where X is the case number (starting from 1). Sample Input:123431 2 32 3 49223372036854775807 -9223372036854775808 0 Sample Output:123Case #1: falseCase #2: trueCase #3: false 分析：在计算机组成原理中，如果两个正数之和等于负数或是两个负数之和等于正数，那么就是溢出。 A、B、C的取值范围为 [−2^63,2^63]，而long long的取值范围为[-2^63,2^63)（经测试，测试用例中没有出现2^63的情况，怀疑是题目写错了），故可以采用long long 存储A、B和C。 设sum=A+B， 如果A &gt; 0 , B &gt; 0，则sum可能会发生正溢出。long long可表示的最大值为2^63-1，A+B最大为2^64-2，正溢出后sum的取值范围为[-2^63,-2]（由(2^64-2) % (2^64) = -2可得右边界），此时A+B必定大于C ； 如果A &lt; 0 , B &lt; 0 ，则sum可能会发生负溢出。负溢出后sum的取值范围[0,2^63)（由(-2^64) % (2^64) = 0可得左边界），此时A+B必定小于C； 如果A &gt; 0 , B &lt; 0 或者 A &lt; 0 , B &gt; 0 ，则sum不会溢出，此时直接判断sum &gt; C是否成立即可。 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;int main() &#123; int t; scanf("%d", &amp;t); long long a, b, c; long long sum; for (int i = 0; i &lt; t; i++) &#123; scanf("%lld %lld %lld", &amp;a, &amp;b, &amp;c); sum = a + b; bool flag = false; if (a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; sum &lt; 0) &#123; flag = true; &#125; else if (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; sum &gt;= 0) &#123; flag = false; &#125; else if (sum &gt; c) &#123; flag = true; &#125; if (flag) &#123; printf("Case #%d: true\n", i + 1); &#125; else &#123; printf("Case #%d: false\n", i + 1); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1046.Shortest Distance （20 分)]]></title>
    <url>%2F2019%2F04%2F05%2Fpat-advanced-1046%2F</url>
    <content type="text"><![CDATA[The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits. Input Specification:Each input file contains one test case. For each case, the first line contains an integer N (in [3,105]), followed by N integer distances D1 D2 ⋯ DN, where Di is the distance between the i-th and the (i+1)-st exits, and DN is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (≤104), with M lines follow, each contains a pair of exits numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 107. Output Specification:For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits. Sample Input:123455 1 2 4 14 931 32 54 1 Sample Output:1233107 分析：声明一个数组distances，distances[i]存储从第一个结点，沿顺时针方向，到第i个结点的距离。 使用sum表示所有结点形成的环的总长度。 计算结点start和end之间的最短距离时，只需比较shortestDistance = distances[end]-distances[start]和sum-shortestDistance，取两者中的较小者即可。 需要注意的是，输入的start不一定比end小，故在计算最短距离前，让start为较小结点编号，end为较大结点的编号。 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;int main() &#123; int n, m; scanf("%d", &amp;n); // 存储从第一个结点，沿顺时针方向，到第i个结点的距离 // i=0这个位置空置不用 int distances[n+1]; int sum = 0, temp; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;temp); distances[i] = sum; sum += temp; &#125; int start, end; int shortestDistance; scanf("%d", &amp;m); while (m--) &#123; scanf("%d %d", &amp;start, &amp;end); if (start &gt; end) &#123; temp = start; start = end; end = temp; &#125; shortestDistance = distances[end] - distances[start]; // 若 shorestDistance &gt; totalDistance - shorestDistance if (sum &lt; 2 * shortestDistance) &#123; shortestDistance = sum - shortestDistance; &#125; printf("%d\n", shortestDistance); &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 21.合并两个有序链表]]></title>
    <url>%2F2019%2F04%2F05%2Fleetcode-21-merge-two-sorted-lists%2F</url>
    <content type="text"><![CDATA[题目描述将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 算法思想已知两个有序链表L1和L2，用p和q分别表示L1和L2的当前节点，用L表示合并后的链表，rear表示合并后的链表的最后一个节点。 当p != null &amp;&amp; q != null时，循环比较p和q的val值，若p大，则将p添加到新链表的末尾，然后p后移；否则将q添加到新链表的末尾，q后移。 上述循环结束后，p、q至少有一个已经为null。 若p != null，则将p添加到新链表的末尾。若q != null，则将q添加到新链表的末尾。 算法实现1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode l = new ListNode(0); ListNode p = l1,q = l2,r = l; ListNode newNode ; while(p != null &amp;&amp; q != null) &#123; if(p.val &lt;= q.val) &#123; newNode = p; p = p.next; &#125; else &#123; newNode = q; q = q.next; &#125; r.next = newNode; r = newNode; &#125; if(p != null) &#123; r.next = p; &#125; if(q != null) &#123; r.next = q; &#125; return l.next; &#125;&#125; 复杂度分析设两个有序链表L1和L2的长度分别为n、m。不妨设 n &lt; m，则 时间复杂度：由于该算法只有一个循环，且循环次数不超过n+m，故时间复杂度为O（n+m）。 空间复杂度：由于该算法只使用了常数的额外空间，故空间复杂度为O（1）。 算法效率执行用时 : 1 ms, 在Merge Two Sorted Lists的Java提交中击败了100.00% 的用户 内存消耗 : 36.8 MB, 在Merge Two Sorted Lists的Java提交中击败了0.97% 的用户]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 25.k个一组翻转链表]]></title>
    <url>%2F2019%2F04%2F04%2Fleetcode-25-reverse-nodes-in-k-group%2F</url>
    <content type="text"><![CDATA[题目描述给出一个链表，每 k 个节点一组进行翻转，并返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么将最后剩余节点保持原有顺序。 示例 : 给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明 : 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 算法思路首先，为需要返回的链表设置一个头结点list以及尾节点rear。 然后，使用整数count记录链表的节点个数，每当满足条件count % k == 0时，翻转这k个节点组成的部分链表。 使用start表示需要翻转的部分链表的第一个节点，用end表示需要翻转的部分链表的最后一个节点。 使用pre表示翻转后的部分链表的第一个节点，采用头插法，翻转部分链表。翻转完毕后，start成为了该部分链表的最后一个节点。 接着，让翻转后的链表成为rear的后继，即rear.next = pre，然后让rear = start，并将原链表的下一个节点赋给start，开启新一轮的翻转。 最后，待循环执行完毕后，若链表后面还有不足k个节点，即count % k != 0，直接让剩余的这部分链表成为rear的后继，即rear = start。 算法实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode reverseKGroup(ListNode head, int k) &#123; int count = 0; ListNode list = new ListNode(0); ListNode rear = list; rear.next = head; ListNode node = list.next; ListNode start = node,end; ListNode p,q,pre=null; while(node != null) &#123; count++; if(count % k == 0) &#123; end = node; node = node.next; //1.翻转当前的k个节点 end.next = null; p = start; while(p != null) &#123; q = p.next; p.next = pre; pre = p; p = q; &#125; //2.将翻转后的部分链表链接到原来的链表尾部 rear.next = pre; rear = start; //3.开启下一轮翻转 pre=null; start = node; &#125; else &#123; node = node.next; &#125; &#125; if(count % k != 0) &#123; rear.next = start; &#125; return list.next; &#125;&#125; 复杂度分析时间复杂度：该算法只遍历链表一次，故时间复杂度为O(n)。 空间复杂度：该算法只使用了常数的额外空间，故空间复杂度为O(1) 算法效率执行用时 : 2 ms, 在Reverse Nodes in k-Group的Java提交中击败了100.00% 的用户 内存消耗 : 37.6 MB, 在Reverse Nodes in k-Group的Java提交中击败了0.93% 的用户]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT甲级 1042.Shuffling Machine （20 分)]]></title>
    <url>%2F2019%2F04%2F03%2Fpat-advanced-1042%2F</url>
    <content type="text"><![CDATA[Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine. The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order: 12345S1, S2, ..., S13, H1, H2, ..., H13, C1, C2, ..., C13, D1, D2, ..., D13, J1, J2 where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13. Input Specification:Each input file contains one test case. For each case, the first line contains a positive integer K (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space. Output Specification:For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line. Sample Input:12236 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47 Sample Output:1S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5 分析：题目大意：模拟一个洗牌机。共有54张牌，其初始顺序为 12345S1, S2, ..., S13, H1, H2, ..., H13, C1, C2, ..., C13, D1, D2, ..., D13, J1, J2 给定洗牌次数K ( ≤20 )，以及第i张牌需要放置的位置j，输出洗完以后的牌顺序。 例如，假定只有五张牌：S3, H5, C1, D13 和 J2。洗牌顺序为{4, 2, 5, 3, 1}，洗完一次后的结果为： J2, H5, D13, S3, C1。若再洗一次，则结果为 C1, H5, S3, J2, D13。 思路： 使用二维数组arr[n][2]存储牌号([1,54])及该牌的当前位置，数组numbers[n]存储洗牌顺序。 每次洗牌，对所有牌执行arr[i][1]=numbers[i]，然后按照牌的当前位置升序排序，即对数组arr[n][2]第二维升序排序。 上述操作循环执行K次以后，得到最终的牌顺序。 输出时，按照牌号转换为对应的牌内容。先按照牌号得到其对应的字母编号，如牌号不大于13，则为字母编号为S…然后让牌号对13取模，若余数为0，则该牌的数字编号为13，否则该牌的数字编号为取模后的余数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;const int n = 54;void sort(int arr[n][2]) &#123; int temp = 0; for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = n - 1; j &gt;= i + 1; j--) &#123; if (arr[j][1] &lt; arr[j - 1][1]) &#123; temp = arr[j][1]; arr[j][1] = arr[j - 1][1]; arr[j - 1][1] = temp; temp = arr[j][0]; arr[j][0] = arr[j - 1][0]; arr[j - 1][0] = temp; &#125; &#125; &#125;&#125;int main() &#123; int k; scanf("%d", &amp;k); int arr[n][2] = &#123; 0 &#125;; int numbers[n]; for (int i = 0; i &lt; n; i++) &#123; arr[i][0] = i + 1; scanf("%d", &amp;numbers[i]); &#125; while (k--) &#123; for (int i = 0; i &lt; n; i++) &#123; arr[i][1] = numbers[i]; &#125; sort(arr); &#125; for (int i = 0; i &lt; n; i++) &#123; char c; if (arr[i][0] &lt;= 13) &#123; c = 'S'; &#125; else if (arr[i][0] &lt;= 26) &#123; c = 'H'; &#125; else if (arr[i][0] &lt;= 39) &#123; c = 'C'; &#125; else if (arr[i][0] &lt;= 52) &#123; c = 'D'; &#125; else &#123; c = 'J'; &#125; int r = arr[i][0] % 13; int data = r == 0 ? 13 : r; printf("%c%d", c, data); if (i &lt; n - 1) &#123; printf(" "); &#125; else &#123; printf("\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat甲级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1018.锤子剪刀布 （20 分)]]></title>
    <url>%2F2019%2F04%2F01%2Fpat-basic-1018%2F</url>
    <content type="text"><![CDATA[大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示： 现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。 输入格式：输入第 1 行给出正整数 N（≤10^5），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C 代表“锤子”、J 代表“剪刀”、B 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。 输出格式：输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。 输入样例：123456789101110C JJ BC BB BB CC CC BJ BB CJ J 输出样例：1235 3 22 3 5B B 分析：设win、draw和defeat分别表示甲赢、平和输的次数，数组aCount[3]和bCount[3]分别表示甲、乙每个手势获胜的次数（下标0表示B，1表示C，2表示J）。 每次交锋，按照结果赢、平和输，分别改变win、draw和defeat，结果为win时，甲相应手势获胜次数加1；结果为defeat（乙win）时，乙相应手势获胜次数加1。 最后按照题目要求输出即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;char getMaxGesture(int wins[]) &#123; int max, maxIndex; max = maxIndex = 0; for (int i = 0; i &lt; 3; i++) &#123; if (wins[i] &gt; max) &#123; max = wins[i]; maxIndex = i; &#125; &#125; if (maxIndex == 0) &#123; return 'B'; &#125; if (maxIndex == 1) &#123; return 'C'; &#125; return 'J';&#125;int main() &#123; int n, win, draw, defeat; win = draw = defeat = 0; int aCount[3] = &#123; 0 &#125;, bCount[3] = &#123; 0 &#125;; //0-C,1-J,2-B scanf("%d", &amp;n); while (n--) &#123; char a, b; scanf(" %c %c", &amp;a, &amp;b); if ((a == 'C' &amp;&amp; b == 'J') || (a == 'J' &amp;&amp; b == 'B') || (a == 'B' &amp;&amp; b == 'C')) &#123; win++; if (a == 'B') &#123; aCount[0]++; &#125; else if (a == 'C') &#123; aCount[1]++; &#125; else &#123; aCount[2]++; &#125; &#125; else if (a == b) &#123; draw++; &#125; else &#123; defeat++; if (b == 'B') &#123; bCount[0]++; &#125; else if (b == 'C') &#123; bCount[1]++; &#125; else &#123; bCount[2]++; &#125; &#125; &#125; printf("%d %d %d\n", win, draw, defeat); printf("%d %d %d\n", defeat, draw, win); printf("%c %c\n", getMaxGesture(aCount), getMaxGesture(bCount)); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1012.数字分类 （20 分)]]></title>
    <url>%2F2019%2F04%2F01%2Fpat-basic-1012%2F</url>
    <content type="text"><![CDATA[给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字： A1 = 能被 5 整除的数字中所有偶数的和； A2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n1−n2+n3−n4⋯； A3 = 被 5 除后余 2 的数字的个数； A4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位； A5 = 被 5 除后余 4 的数字中最大数字。 输入格式：每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。 输出格式：对给定的 N 个正整数，按题目要求计算 A1~A5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。 若其中某一类数字不存在，则在相应位置输出 N。 输入样例 1：113 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例 1：130 11 2 9.7 9 输入样例 2：18 1 2 4 5 6 7 9 16 输出样例 2：1N 11 2 N 9 分析：按照题目要求，对不同数字执行不同的计算即可。 以下两点需要注意： 1.输出时行末不得有多余空格； 2.若其中某一类数字不存在，则在相应位置输出 N。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cmath&gt;int main() &#123; int n, a1, a2, a3, a5, a2Index, a4Count; a1 = a2 = a3 = a5 = a2Index = a4Count = 0; double a4 = 0; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; int x; scanf("%d", &amp;x); if (x % 10 == 0) &#123; a1 += x; &#125; else if (x % 5 == 1) &#123; a2 += pow(-1, a2Index++) * x; &#125; else if (x % 5 == 2) &#123; a3 += 1; &#125; else if (x % 5 == 3) &#123; a4 += x; a4Count++; &#125; else if (x % 5 == 4) &#123; if (x &gt; a5) &#123; a5 = x; &#125; &#125; &#125; if (!a1) &#123; printf("N "); &#125; else &#123; printf("%d ", a1); &#125; if (!a2Index) &#123; printf("N "); &#125; else &#123; printf("%d ", a2); &#125; if (!a3) &#123; printf("N "); &#125; else &#123; printf("%d ", a3); &#125; if (!a4Count) &#123; printf("N "); &#125; else &#123; printf("%.1f ", a4 / a4Count); &#125; if (!a5) &#123; printf("N"); &#125; else &#123; printf("%d", a5); &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1046.划拳 （15 分)]]></title>
    <url>%2F2019%2F03%2F31%2Fpat-basic-1046%2F</url>
    <content type="text"><![CDATA[划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。 下面给出甲、乙两人的划拳记录，请你统计他们最后分别喝了多少杯酒。 输入格式：输入第一行先给出一个正整数 N（≤100），随后 N 行，每行给出一轮划拳的记录，格式为： 1甲喊 甲划 乙喊 乙划 其中喊是喊出的数字，划是划出的数字，均为不超过 100 的正整数（两只手一起划）。 输出格式：在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格分隔。 输入样例：12345658 10 9 125 10 5 103 8 5 1212 18 1 134 16 12 15 输出样例：11 2 分析:设aCount和bCount分别表示甲、乙两人喝酒的杯数，aSay和bSay分别表示甲、乙喊出的数字，aGive和bGive分别表示甲、乙划出的数字。 本题共有四种情况，对应三种结果： 1.甲、乙同赢(aGive == aSay + bSay &amp;&amp; bGive == aSay + bSay)或同输(aGive != aSay + bSay &amp;&amp; bGive != aSay + bSay)：继续下一轮； 2.甲赢(aGive == aSay + bSay)：乙喝酒，即bCount++； 3.乙赢(bGive == aSay + bSay)：甲喝酒，即aCount++。 12345678910111213141516171819202122232425#include &lt;cstdio&gt;int main() &#123; int n, aCount, bCount; aCount = bCount = 0; scanf("%d", &amp;n); while (n--) &#123; int aSay, aGive, bSay, bGive; scanf("%d %d %d %d", &amp;aSay, &amp;aGive, &amp;bSay, &amp;bGive); //1.同赢或同输 if ((aGive == aSay + bSay &amp;&amp; bGive == aSay + bSay) || (aGive != aSay + bSay &amp;&amp; bGive != aSay + bSay)) &#123; continue; &#125; //2.甲赢 if (aGive == aSay + bSay) &#123; bCount++; &#125; else if (bGive == aSay + bSay) &#123; //3.乙赢 aCount++; &#125; &#125; printf("%d %d\n", aCount, bCount); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1026.程序运行时间 （15 分)]]></title>
    <url>%2F2019%2F03%2F28%2Fpat-basic-1026%2F</url>
    <content type="text"><![CDATA[要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。 这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。 输入格式：输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 &lt; C2，并且取值在 [0,10^7]。 输出格式：在一行中输出被测函数运行的时间。运行时间必须按照 hh:mm:ss（即2位的 时:分:秒）格式输出；不足 1 秒的时间四舍五入到秒。 输入样例：1123 4577973 输出样例：112:42:59 分析：由于题目要求“不足 1 秒的时间四舍五入到秒”，所以C2-C1后，先加上50，这样如果（C2-C1）/ 100的小数位大于等于0.5则会进位，小于0.5则会被舍去，从而保证四舍五入到秒。 然后再除以100，得到以秒为单位的总时间n =（C2-C1+50）/ 100。 n / 3600 得到小时数hour，n % 3600 / 60 则得到了分钟数minute ，n % 3600 % 60则得到了秒数second。 123456789101112#include &lt;cstdio&gt;int main() &#123; int c1, c2; scanf("%d %d", &amp;c1, &amp;c2); int n = (c2 - c1 + 50) / 100; int hour = n / 3600; n = n % 3600; int minute = n / 60, second = n % 60; printf("%02d:%02d:%02d\n", hour, minute, second); return 0;&#125; 另一种解法： 使用浮点数来存储以秒为单位的总时间，为最后的秒数second加上0.5，从而保证大于等于0.5的小数位能进位。 12345678910111213#include &lt;cstdio&gt;int main() &#123; int c1, c2; double CLK_TCK = 100.0; scanf("%d %d", &amp;c1, &amp;c2); double seconds = (c2 - c1) / CLK_TCK; int h = seconds / (60 * 60); int m = (seconds - h * 60 * 60) / 60; int s = seconds - h * 60 * 60 - m * 60 + 0.5; printf("%02d:%02d:%02d\n", h, m, s); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1016.部分A+B （15 分)]]></title>
    <url>%2F2019%2F03%2F28%2Fpat-basic-1016%2F</url>
    <content type="text"><![CDATA[正整数 A 的“$D_A​$（为 1 位整数）部分”定义为由 A 中所有 $D_A​$ 组成的新整数 $P_A​$。例如：给定 A=3862767，$D_A​$=6，则 A的“6 部分”$P_A​$是66，因为 A 中有 2 个 6。 现给定 A、$D_A$、B、$D_A$，请编写程序计算 $P_A+P_B$。 输入格式：输入在一行中依次给出 A、$D_A​$、B、$D_B​$，中间以空格分隔，其中 0&lt;A,B&lt;$10^{10}​$。 输出格式：在一行中输出$P_A+P_B​$ 的值。 输入样例 1：13862767 6 13530293 3 输出样例 1：1399 输入样例 2：13862767 1 13530293 8 输出样例 2：10 分析：首先以字符数组（或者字符串）的形式输入A和B， 然后遍历A和B中的每一个字符， 通过减去’0’得到字符的数字形式， 接着，判断其是否等于$D_A$、$D_B$，若等于，则进行进位累加操作。 (1)若从前往后遍历字符数组（或字符串），则累加语句为： pa = 10 * pa + da； (2)若从后往前遍历字符数组（或字符串），则累加语句为 pa += da * carray; carry *= 10;（carry表示进位，初值为1）。 循环结束后，得到$P_A$和$P_B​$ 。 需要注意的是$10^{10}$超过了int的取值范围，故应使用long long 申明$P_A$和$P_B$。 12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;cstring&gt;long long getP(char a[], int da) &#123; long long pa = 0; long long carry = 1;//进位 for (int i = strlen(a) - 1; i &gt;= 0; i--) &#123; if ((a[i] - '0') == da) &#123; pa += da * carry; carry *= 10; &#125; &#125; return pa;&#125;int main() &#123; char a[10], b[10]; int da, db; scanf("%s %d %s %d", a, &amp;da, b, &amp;db); printf("%lld\n", getP(a, da) + getP(b, db)); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1011.A+B 和 C （15 分)]]></title>
    <url>%2F2019%2F03%2F28%2Fpat-basic-1011%2F</url>
    <content type="text"><![CDATA[给定区间 [−2^31,2^31] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。 输入格式：输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行，顺序给出 A、B 和 C。整数间以空格分隔。 输出格式：对每组测试用例，在一行中输出 Case #X: true 如果 A+B&gt;C，否则输出 Case #X: false，其中 X 是测试用例的编号（从 1 开始）。 输入样例：1234541 2 32 3 42147483647 0 21474836460 -2147483648 -2147483647 输出样例：1234Case #1: falseCase #2: trueCase #3: trueCase #4: false 分析：本题有两点需要注意： 1.给定的取值范围为 [−2^31,2^31]，因此，A+B有可能会超过int的取值范围，故A、B和C应申明为long long； 2.输出时编号从1开始。 12345678910111213141516#include &lt;cstdio&gt;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; long long a, b, c; scanf("%d %d %d", &amp;a, &amp;b, &amp;c); if (a + b &gt; c) &#123; printf("Case #%d: true\n", i); &#125; else &#123; printf("Case #%d: false\n", i); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1001.害死人不偿命的(3n+1)猜想 （15 分)]]></title>
    <url>%2F2019%2F03%2F28%2Fpat-basic-1001%2F</url>
    <content type="text"><![CDATA[卡拉兹(Callatz)猜想： 对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？ 输入格式：每个测试输入包含 1 个测试用例，即给出正整数 n 的值。 输出格式：输出从 n 计算到 1 需要的步数。 输入样例：13 输出样例：15 分析：使用count记录总的步数， 如果n为偶数，则令n=n/2； 如果n为奇数，则令n=(3*n+1)/2， 然后步数count++， 直至n==1结束循环。 12345678910111213141516#include &lt;cstdio&gt;int main() &#123; int n, count = 0; scanf("%d", &amp;n); while (n != 1) &#123; if (n % 2 == 0) &#123; n /= 2; &#125; else &#123; n = (3 * n + 1) / 2; &#125; count++; &#125; printf("%d\n", count); return 0;&#125;]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++中char * a="xxx"引发的警告]]></title>
    <url>%2F2019%2F03%2F21%2Fc-or-cpp-char-pointer-string-constant-unmodified%2F</url>
    <content type="text"><![CDATA[在c++中，当char * 指向字符常量时（以下面的程序为例） 1234567#include &lt;cstdio&gt;int main() &#123; char *a = "I love China!"; printf("%s\n",a); return 0;&#125; 编译时，将产生如下warning： 12345ProblemC.cpp:4:12: warning: conversion from string literal to 'char *' is deprecated [-Wc++11-compat-deprecated-writable-strings] char *a = "I love China!"; ^1 warning generated. 为什么会产生该warning呢？ 因为此时a中存储的是“I love China!”在内存中的首地址，而“I love China!”是字符常量，存放在只读区中。程序员有可能通过a去修改“I love China!”的值，从而导致error。 如何解决该warning呢？ 在定义a时，使用const修饰，表明a所指地址中的内容不允许被修改。示例如下： 1234567#include &lt;cstdio&gt;int main() &#123; const char *a = "I love China!"; printf("%s\n",a); return 0;&#125;]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT乙级 1008.数组元素循环右移问题 （20 分)]]></title>
    <url>%2F2019%2F03%2F15%2Fpat-basic-1008%2F</url>
    <content type="text"><![CDATA[一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（$A_0 A_1⋯A_{N−1}$）变换为（$A_{N-M}⋯A_{N−1} A_0 A_1⋯A_{N−M−1}$）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输入格式:每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。 输出格式:在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 输入样例:126 21 2 3 4 5 6 输出样例:15 6 1 2 3 4 解法一：直接法 算法思路：每次向右移动一位，循环执行m次 代码实现 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int arr[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; for (int i = 0; i &lt; m; i++) &#123; //保存数组的最后一位 int temp = arr[n - 1]; //自后向前，循环后移一位 for (int j = n - 2; j &gt;= 0; j--) &#123; arr[j + 1] = arr[j]; &#125; arr[0] = temp; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i]; if (i != n - 1) &#123; cout &lt;&lt; " "; &#125; &#125;&#125; 时间复杂度：每次向右移动一位，需要执行n次赋值操作，这个过程循环执行m次，所以共执行nm次赋值操作，时间复杂度为O(nm) 解法二：反转法 算法思想 假设N&gt;=M（若N&lt;M，只需令M=M%N即可），数组A中的数据为$A_0 A_1⋯A_{N−1}$，现在需要将数组A循环向右移M个位置，即将$A_{N-M}⋯A_{N−1}$移到数组的前面。 我们可以将数组A中的数据分为两个部分$A_0 A_1⋯A_{N−M-1}$和$A_{N-M}⋯A_{N−1}$来看， （1）先将$A_0 A_1⋯A_{N−M-1}​$反转，得到$A_{N−M-1} ⋯A_1 A_0​$； （2）再将$A_{N-M}⋯A_{N−1}​$反转，得到$A_{N-1}⋯A_{N−M}​$ （3）经过（1）和（2）后，数组A中的数据为$A_{N−M-1} ⋯A_1 A_0 A_{N-1}⋯A_{N−M}$，将数组A中的数据反转，此时数组A中的数据顺序为$A_{N-M}⋯A_{N−1} A_0 A_1⋯A_{N−M−1}$ 代码实现 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; int arr[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; if(m &gt; n) &#123; m = m % n; &#125; int temp = 0; // 反转前n-m项 for(int i=0;i&lt;(n-m)/2;i++) &#123; temp = arr[n-m-i-1]; arr[n-m-i-1] = arr[i]; arr[i] = temp; &#125; // 反转后m项 for(int i=n-m;i&lt;n-m/2;i++) &#123; temp = arr[2*n-m-i-1]; arr[2*n-m-i-1] = arr[i]; arr[i] = temp; &#125; // 反转整个数组 for(int i=0;i&lt;n/2;i++) &#123; temp = arr[n-i-1]; arr[n-i-1] = arr[i]; arr[i] = temp; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; arr[i]; if (i != n - 1) &#123; cout &lt;&lt; " "; &#125; &#125;&#125; 时间复杂度 三次反转操作，共执行 $3 \times \frac{n-m}{2}+3 \times [n-\frac{m}{2}-(n-m)]+3 \times \frac{n}{2}=3n$次赋值操作，故时间复杂度为O(n)]]></content>
      <categories>
        <category>pat乙级</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《推荐系统实践》4.推荐系统冷启动问题]]></title>
    <url>%2F2019%2F03%2F14%2Frecommender-system-cold-start%2F</url>
    <content type="text"><![CDATA[推荐系统需要根据用户的历史行为和兴趣预测用户未来的行为和兴趣，因此大量的用户行为数据就成为推荐系统的重要组成部分和先决条件。 如何在没有大量用户数据的情况下设计个性化推荐系统并且让用户对推荐结果满意从而愿意使用推荐系统，就是冷启动问题（cold start）。 冷启动分类 用户冷启动：如何给新用户做个性化推荐。 物品冷启动：如何将新的物品推荐给可能对它感兴趣的用户。 系统冷启动：如何在一个新开发的网站上（还没有用户，也没有用户行为，只有一些物品的信息）设计个性化推荐系统，从而在网站刚发布时就让用户体验到个性化推荐服务。 利用用户注册信息1.利用用户的注册信息可以很好地解决注册用户的冷启动问题。 当新用户刚注册时，我们不知道他喜欢什么物品，于是只能给他推荐一些热门的商品。但如果我们知道她是一位女性，那么可以给她推荐女性都喜欢的热门商品。虽然这种个性化的粒度很粗，因为所有刚注册的女性看到的都是同样的结果，但相对于不区分男女的方式，这种推荐的精度已经大大提高了。 2.用户的注册信息分3种： 人口统计学信息：包括用户的年龄、性别、职业、民族、学历和居住地。 用户兴趣的描述：有一些网站会让用户用文字描述他们的兴趣。 从其他网站导入的用户站外行为数据：比如用户通过豆瓣、新浪微博的账号登录，就可以在得到用户同意的情况下获取用户在豆瓣或者新浪微博的一些行为数据和社交网络数据。 3.基于注册信息的个性化推荐流程基本如下: (1) 获取用户的注册信息; (2) 根据用户的注册信息对用户分类; (3) 给用户推荐他所属分类中用户喜欢的物品。 4.基于用户注册信息的推荐算法的核心问题是计算每种特征的用户喜欢的物品。也就是说，对于 每种特征f，计算具有这种特征的用户对各个物品的喜好程度preference(f, i)。 preference( f ,i ) 可以简单地定义为物品i在具有特征f的用户中的热门程度：$$preference(f,i) = |N(i) \cap U(f)| \tag{1}$$其中，N(i)是喜欢物品i的用户集合，U(f)是具有特征f的用户集合。 上面这种定义可以比较准确地预测具有某种特征的用户是否喜欢某个物品。但是，在这种定义下，往往热门的物品会在各种特征的用户中都具有比较高的权重。 因此，我们可以将 preference(f,i) 定义为喜欢物品i的用户中具有特征f的比例:$$preference(f,i) = \frac{|N(i) \cap U(f)|}{|N(i)|+ \alpha} \tag{2}$$这里分母中使用参数$\alpha​$的目的是解决数据稀疏问题。比如有一个物品只被1个用户喜欢过，而这个用户刚好就有特征f，那么就有preference(f,i)=1 。但是，这种情况并没有统计意义，因此我们为分母加上一个比较大的数，可以避免这样的物品产生比较大的权重。 选择合适的物品启动用户的兴趣解决用户冷启动问题的另一个方法是在新用户第一次访问推荐系统时，不立即给用户展示推荐结果，而是给用户提供一些物品，让用户反馈他们对这些物品的兴趣，然后根据用户反馈给提供个性化推荐。 该方法的首要问题是如何选择物品让用户进行反馈。 一般来说，能够用来启动用户兴趣的物品需要具有以下特点: 比较热门 如果要让用户对一个物品进行反馈，前提是用户知道这个物品是什么东西。 以电影为例，如果一开始让用户进行反馈的电影都很冷门，而用户不知道这些电影的情节和内容，也就无法对它们做出准确的反馈。 具有代表性和区分性： 启动用户兴趣的物品不能是大众化或老少咸宜的，因为这样的物品对用户的兴趣没有区分性。 启动物品集合需要有多样性： 在冷启动时，我们不知道用户的兴趣，而用户兴趣的可能性非常多，为了匹配多样的兴趣，我们需要提供具有很高覆盖率的启动物品集合，这些物品能覆盖几乎所有主流的用户兴趣。 利用物品的内容信息对于基于物品的协同过滤算法（以下简称ItemCF）算法来说，物品冷启动是一个严重的问题了。因为ItemCF算法的原理是给用户推荐和他之前喜欢的物品相似的物品。ItemCF算法会每隔一段时间利用用户行为计算物品相似度表(一般一天计算一次)，在线服务时ItemCF算法会将之前计算好的物品相关度矩阵放在内存中。因此，当新物品加入时，内存中的物品相关表中不会存在这个物品，从而ItemCF算法无法推荐新的物品。 解决这一问题的办法是频繁更新物品相似度表，但基于用户行为计算物品相似度是非常耗时的事情，主要原因是用户行为日志非常庞大。而且，新物品如果不展示给用户，用户就无法对它产生行为，通过行为日志计算是计算不出包含新物品的相关矩阵的。为此，我们只能利用物品的内容信息计算物品相关表，并且频繁地更新相关表(比如半小时计算一次)。 一般来说，物品的内容可以通过向量空间模型表示，该模型会将物品表示成一个关键词向量。 从文本生成关键词向量的主要步骤： （1）对于中文，首先要对文本进行分词，将字流变成词流； （2）然后从词流中检测出命名实体(如人名、地名、组织名等)，这些实体和一些其他重要的词将组成关键词集合； （3）最后对关键词进行排名，计算每个关键词的权重，从而生成关键词向量。 对物品d，它的内容表示成一个关键词向量如下:$$d_i = {\left((e_1, w_1),(e_2, w_2),\dots \right)} \tag{3}$$其中，$e_i​$是关键词，$w_i​$是关键词对应的权重。 在给定物品内容的关键词向量后，物品的内容相似度可以通过向量之间的余弦相似度计算$$w_{ij} = \frac{d_i \cdot d_j}{\sqrt{||d_i||\times||d_j||}} \tag{4}$$得到物品的相似度之后，可以利用ItemCF算法的思想，给用户推荐和他历史上喜欢的物品内容相似的物品。]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《推荐系统实践》3.基于物品的协同过滤算法]]></title>
    <url>%2F2019%2F03%2F13%2Frecommender-system-item-based-collaborative-filtering%2F</url>
    <content type="text"><![CDATA[基于物品的协同过滤算法（item-based collaborative filtering，以下简称ItemCF）算法思想：给用户推荐那些和他们之前喜欢的物品相似的物品。 不过，ItemCF算法并不利用物品的内容属性计算物品之间的相似度，它主要通过分析用户的行为记录计算物品之间的相似度。该算法认为，物品A和物品B具有很大的相似度是因为喜欢物品A的用户大都也喜欢物品B。 基于物品的协同过滤算法可以利用用户的历史行为给推荐结果提供推荐解释，比如给用户推荐《天龙八部》的解释可以是因为用户之前喜欢《射雕英雄传》。 ItemCF算法主要分为两步。(1) 计算物品之间的相似度。(2) 根据物品的相似度和用户的历史行为给用户生成推荐列表。 计算物品相似度可以用下面的公式定义物品的相似度:$$w_{ij} = \frac {|N(i) \cap N(j)|} {|N(i)|}$$这里，分母|N(i)|是喜欢物品i的用户数，而分子 $|N(i) \cap N(j)|​$ 是同时喜欢物品i和物品j的用户数。因此，上述公式可以理解为喜欢物品i的用户中有多少比例的用户也喜欢物品j。 如果物品j很热门，很多人都喜欢， 那么$w_{ij}​$就会很大，接近1。因此，该公式会造成任何物品都会和热门的物品有很大的相似度。为了避免推荐出热门的物品，可以用下面的公式:$$w_{ij} = \frac{|N(i) \cap N(j)|}{\sqrt{|N(i)||N(j)|}}$$这个公式惩罚了物品j的权重，因此减轻了热门物品会和很多物品相似的可能性。 计算物品相似度时可以首先建立用户—物品倒排表(即对每个用户建立一个包含他喜欢的物品的列表)，然后对于每个用户，将他物品列表中的物品两两在共现矩阵C中加1。 1234567891011121314151617181920212223242526272829import mathfrom collections import defaultdictdef item_similarity(self, trainset): # 物品相似度矩阵 item_similarity_matrix = &#123;&#125; # 物品流行度 item_popularity = &#123;&#125; for user, items in trainset.items(): for item1 in items: # 构造物品相似度矩阵，计算物品共现次数 item_similarity_matrix.setdefault(item1, defaultdict(int)) for item2 in items: if item1 == item2: continue item_similarity_matrix[item1][item2] += 1 # 统计喜欢item1的用户数 if item1 not in item_popularity: item_popularity[item1] = 0 item_popularity[item1] += 1 # 计算最终的相似度矩阵 for item1, releated_items in item_similarity_matrix.items(): for item2, count in releated_items.items(): self.item_similarity_matrix[item1][item2] = count / \ math.sqrt(item_popularity[item1] * item_popularity[item2])return item_similarity_matrix 产生推荐列表在得到物品之间的相似度后，ItemCF通过如下公式计算用户u对一个物品j的兴趣:$$Interestingness_{uj} = \sum_{i \in N(u) \cap S(j,K)} w_{ji}r_{ui}$$这里N(u)是用户喜欢的物品的集合，S(j,K)是和物品j最相似的K个物品的集合,$w_{ji}​$是物品j和i的相似度，$r_{ui}​$是用户u对物品i的兴趣(对于隐反馈数据集，如果用户u对物品i有过行为，即可令 $r_{ui}=1​$。)该公式的含义是，和用户历史上感兴趣的物品越相似的物品，越有可能在用户的推荐列表中获得比较高的排名。 关于物品相似度的一些改进 用户活跃度对物品相似度的影响 John S. Breese在论文“Empirical Analysis of Predictive Algorithms for Collaborative Filtering ”中提出了一个称为IUF(Inverse User Frequence)，即用户活跃度对数的倒数的参数，他认为活跃用户对物品相似度的贡献应该小于不活跃的用户，他提出应该增加IUF参数来修正物品相似度的计算公式：$$w_{ij} = \frac{\sum_{u \in N(i) \cap N(j)} \frac{1}{\log{(1+|N(u)|)}}}{\sqrt{|N(i)||N(j)|}}$$当然，上面的公式只是对活跃用户做了一种软性的惩罚，但对于很多过于活跃的用户，为了避免相似度矩阵过于稠密，我们在实际计算中一般直接忽略他的兴趣列表，而不将其纳入到相似度计算的数据集中。 物品相似度归一化 研究发现，如果将ItemCF的相似度矩阵按最大值归一化，可以提高推荐的准确率。如果已经得到了物品相似度矩阵w，那么可以用如下公式得到归一化之后的相似度矩阵w’:$$w_{ij}^{‘} = \frac{w_{ij}}{\max_j {w_{ij}}}$$归一化的好处不仅仅在于增加推荐的准确度，它还可以提高推荐的覆盖率和多样性。]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统常用评估指标]]></title>
    <url>%2F2019%2F03%2F04%2Frecommender-system-evaluation-metrics%2F</url>
    <content type="text"><![CDATA[评分预测预测用户对物品评分的行为称为评分预测（rating prediction）。 评分预测的预测准确度一般通过均方根误差(Root Mean Squared Error，简称RMSE)和平均绝对误差(Mean Absolute Error，简称MAE)计算。 对于测试集中的一个用户u和物品i，令$r_{ui}$是用户对物品i的实际评分，而$\hat{r}_{ui}$是推荐算法给出的预测评分。 RMSE$$RMSE = \sqrt{ \frac { \sum_{(u,i)\in Test} (r_{ui}-\hat{r}_{ui})^2 }{ \left \vert Test \right \vert }} \tag{1}$$ MAEMAE采用绝对值计算预测误差，它的定义为:$$MAE = \frac { \sum_{(u,i) \in Test}{|r_{ui}-\hat{r}_{ui}|}}{ \left \vert Test \right \vert} \tag{2}$$ TopN推荐网站在提供推荐服务时，一般是给用户一个个性化的推荐列表，这种推荐叫做TopN推荐。 在推荐系统的论文中，经常可以看到xx@N，它是xx at rank N的缩写。意为在TopN推荐中，该指标的值。 Precision/RecallTopN推荐的预测准确率一般通过准确率(precision)/召回率(recall)度量。 令R(u)是根据用户在训练集上的行为给用户作出的推荐列表，而T(u)是用户在测试集上的行为列表。那么，推荐结果的召回率定义为:$$\mathrm{Recall}@N = \frac { \sum_{u \in U}|R(u) \cap T(u)|} { \sum_{u \in U}|T(u)|} \tag{3}$$推荐结果的准确率定义为：$$\mathrm{Precision}@N = \frac { \sum_{u \in U}|R(u) \cap T(u)|} { \sum_{u \in U}|R(u)|} \tag{4}$$F1值$$\mathrm{F1} = \frac{ 2 \times Precision \times Recall}{ Precision + Recall} \tag{5}$$ AP/MAP精度均值（Average Precision，简称AP)$$AP@N = \frac{ \sum_{k=1}^N \mathrm{Precision@k \times rel(k)}}{ \min \{ N, \left \vert C_{\mathrm{adopted}} \right \vert \}} \tag{6}$$其中，rel(k)是指示函数，表示第k个物品是否被采纳$$\mathrm{rel(k)} =\begin{cases}1, &amp; I_k \in C_{\mathrm{adopted}} \\0, &amp; \mathrm{otherwise}\end{cases}$$平均精度均值（Mean Average Precision，简称MAP)$$\mathrm{MAP}@N = \frac{1}{ \left \vert U \right \vert}\sum_{u \in U} \mathrm{AP}@N \tag{7}$$ Hit Ratio命中率（Hit Ratio, 简称HR）$$\mathrm{HR}@N = \frac{ \mathrm{hits}}{ \left \vert U \right \vert} \tag{8}$$ ARHR平均命中排序倒数（Average Reciprocal Hit Rank，简称ARHR)$$\mathrm{ARHR}@N = \frac{1} { \left \vert U \right \vert}\sum_{i=1}^{hits} \frac{1}{ pos_i} \tag{9}$$其中，$pos_i$表示第i次命中时，测试物品在推荐列表中的位置。 NDCGNDCG源自于信息检索领域，用于评估排序质量。在理解NDCG前，需要弄明白CG、DCG以及IDCG的概念。 CG 累计收益（Cumulative Gain，简称CG）$$\mathrm{CG}@N = \sum_{i = 1}^N rel_i \tag{10}$$其中，$rel_i$是将物品i推荐给用户得到的“收益”。 DCG 直观的想法：“收益”越高的物品，在列表中的位置应该越靠前。 折扣累计收益（Discounted Cumulative Gain，简称DCG)在CG的基础上，加入了对物品位置的考虑：$$\mathrm{DCG}@N = \sum_{i =1}^N\frac{ rel_i}{ \log_2 (i + 1)} \tag{11}$$DCG的另一种形式：$$\mathrm{DCG}@N = \sum_{i =1}^N\frac{ 2^{rel_i} - 1}{ \log_2 (i + 1)} \tag{12}$$ DCG的第二种形式更常用。当$rel_i \in$ &#123;0,1&#125;时，公式(11)等价于(12)。 IDCG 理想的折扣累计收益（Ideal Discounted Cumulative Gain，简称IDCG）：在理想情况下，推荐列表中的物品应按照最终收益从高到低排序。$$\mathrm{IDCG}@N = \sum_{i =1}^{\left \vert REL_N \right \vert}\frac{ 2^{rel_i} - 1}{ \log_2 (i + 1)} \tag{13}$$其中，$REL_N$表示按照收益从高到低排序后的N个物品；$rel_i \in$ &#123;0,1&#125;。 NDCG 当采用DCG时，不同N下的结果无法直接进行比较。 为了解决该问题，可以对DCG进行归一化，得到归一化折扣累计收益（Normalized Discounted Cumulative Gain，简称NDCG)：$$\mathrm{NDCG}@N = \frac{DCG@N} {IDCG@N} \tag{14}$$$NDCG \in [0,1]$，其值越大，表示排序的质量越高。 当$rel_i \in$ &#123;0,1&#125;且采用留一法进行评估时，待测物品的收益rel=1，其理想位置j=1$$\mathrm{DCG}@N = \frac{1}{\log_2 (j + 1)} \\\mathrm{IDCG}@N = \frac{1}{\log_2 (1 + 1)} = \frac{1}{\log_2 (2)}$$从而：$$\mathrm{NDCG}@N = \frac{DCG@N} {IDCG@N} = \frac{ \log 2 }{ \log(j + 1) } \tag{15}$$ 示例 为了便于理解，下面举个例子（源自于维基百科）： 假设系统给用户u推荐了6部电影，推荐列表为：M1、M2、M3、M4、M5、M6， 用户u对这些电影的评分依次为：3, 2, 3, 0, 1, 2。 如果将用户的评分作为推荐该电影获得的收益，那么，该推荐列表的CG值为：$$\mathrm{CG}@6 = \sum_{i=1}^6 rel_i = 3 + 2 + 3 + 0 + 1 + 2 = 11$$ i $rel_i$ $\log_2 (i + 1)$ $\frac{rel_i}{\log_2 (i + 1)}$ 1 3 1 3 2 2 1.585 1.262 3 3 2 1.5 4 0 2.322 0 5 1 2.585 0.387 6 2 2.807 0.712 根据上表，计算得到：$$\mathrm{DCG}@6 = \sum_{i =1}^6\frac{ rel_i}{ \log_2 (i + 1)} = 6.861$$ 理想情况下，推荐列表中的电影按照评分从高到低排序：3, 3, 2, 2, 1, 0。从而：$$\begin{align}\mathrm{IDCG}@6 &amp;= \sum_{i =1}^6\frac{ rel_i}{ \log_2 (i + 1)} \\&amp;= \frac{3}{1} + \frac{3}{1.585} + \frac{2}{2} + \frac{2}{2.322} + \frac{1}{2.585} + \frac{0}{2.807} \\&amp;= 7.141\end{align}$$因此：$$\mathrm{NDCG}@6 = \frac{DCG@6} {IDCG@6} = \frac{6.861}{7.141} = 0.961$$ 参考资料 https://en.wikipedia.org/wiki/Discounted_cumulative_gain]]></content>
      <categories>
        <category>recommender systems</category>
      </categories>
      <tags>
        <tag>recommender systems</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 82.删除排序链表中的重复元素 II]]></title>
    <url>%2F2019%2F02%2F27%2Fleetcode-82-remove-duplicates-from-sorted-list-ii%2F</url>
    <content type="text"><![CDATA[题目描述给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 12输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 示例 2: 12输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 解决方案方法一：递归法 思路 按照递归的思想，该题可以分为以下三种情况： 1）待处理的排序链表为空，或者仅含有一个元素。此时，直接返回排序链表的头节点head即可。 2）待处理的排序链表头部节点head的值为重复元素head.val。此时，依次遍历链表，直至找到第一个值不等于head.val的节点node，对node递归执行deleteDuplicates方法。 3）第一个节点head的值不是重复元素。此时，对第二个节点递归执行deleteDuplicates方法即可，产生的新链表成为head的后继。 算法实现 1234567891011121314151617181920212223/*public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;*/class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; //1.如果链表为空或者仅含一个节点 if(head == null || head.next == null) &#123; return head; &#125; //2.如果链表的头部是重复出现的数字 if(head.val == head.next.val) &#123; while(head.next != null &amp;&amp; head.val == head.next.val) &#123; head = head.next; &#125; return deleteDuplicates(head.next); &#125; //3.如果链表首部节点不需要删除 head.next = deleteDuplicates(head.next); return head; &#125;&#125; 复杂度分析 设链表的长度为L 时间复杂度：O(L)，仅对链表执行一次遍历操作 空间复杂度：O(1)，没有使用额外的变量 算法效率 执行用时：1ms，战胜 98.69 % 的 java 提交记录 内存消耗：38.6 MB 方法二：非递归法 思路 首先我们仍将判断待处理的排序链表是否为空，或仅含有一个节点。 然后，我们将添加一个哑结点list作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如，需要删除链表的头部。 在遍历链表的同时，使用while循环寻找与当前节点node值不相等的第一个节点，若while循环得以成功执行，则让得到的新节点成为head的后继；否则，当前节点node与其后继节点值不相等，while循环未被执行，则该节点不需要被删除，head后移。 算法实现 1234567891011121314151617181920212223242526272829/*public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;*/class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head == null || head.next == null) &#123; return head; &#125; ListNode list = new ListNode(0); list.next = head; head = list; ListNode pre,node; while(head.next != null) &#123; pre = head.next; node = pre; while(node.next != null &amp;&amp; pre.val == node.next.val) &#123; node = node.next; &#125; if(node == pre) &#123; head = head.next; &#125; else &#123; head.next = node.next; &#125; &#125; return list.next; &#125;&#125; 复杂度分析 设链表的长度为L 时间复杂度：O(L)，仅对链表执行一次遍历操作 空间复杂度：O(1)，我们只用了常量级的额外空间 算法效率 执行用时：1ms，战胜 98.69 % 的 java 提交记录 内存消耗：35.2 MB]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 23.合并K个排序链表]]></title>
    <url>%2F2019%2F02%2F22%2Fleetcode-23-merge-k-sorted-lists%2F</url>
    <content type="text"><![CDATA[题目描述合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 算法思路已知K个有序链表，采用二路归并实现两个链表的合并，在此基础上，按照折半查找的思想，递归执行二路归并。 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class MergeKSortedLists23 &#123; public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; public ListNode mergeKLists(ListNode[] lists) &#123; if(lists == null || lists.length == 0) &#123; return null; &#125; if(lists.length == 1) &#123; return lists[0]; &#125; return merge(lists,0,lists.length-1); &#125; public ListNode merge(ListNode[] lists,int start,int end) &#123; if(start &gt; end) &#123; return null; &#125; if(start == end) &#123; return lists[start]; &#125; int mid = (start + end) / 2; ListNode l1 = merge(lists,start,mid); ListNode l2 = merge(lists,mid+1,end); return mergeTwoLists(l1,l2); &#125; public ListNode mergeTwoLists(ListNode l1,ListNode l2) &#123; ListNode head = new ListNode(0); ListNode p = l1, q=l2,node,rear = head; while(p != null &amp;&amp; q != null) &#123; if(p.val &lt;= q.val) &#123; node = new ListNode(p.val); p = p.next; &#125; else &#123; node = new ListNode(q.val); q = q.next; &#125; node.next = null; rear.next = node; rear = node; &#125; if(p != null) &#123; rear.next = p; rear = p; &#125; if(q != null) &#123; rear.next = q; rear = q; &#125; return head.next; &#125;&#125; 复杂度分析时间复杂度：O($n\log_2n​$) 空间复杂度：O($n​$) 算法效率执行用时: 11 ms, 在Merge k Sorted Lists的Java提交中击败了92.02% 的用户 内存消耗: 28.5 MB, 在Merge k Sorted Lists的Java提交中击败了80.66% 的用户]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>linked-list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS常用快捷键总结]]></title>
    <url>%2F2019%2F01%2F26%2Fmacos-keyboard-shortcut%2F</url>
    <content type="text"><![CDATA[2018年双十一期间，博主在京东入手了一台17版256G的MacBook Pro。由于一些外在原因，直到最近一段时间才真正使用上。经过最初的磨合，现在已经比较熟练了。这里总结下MacOS中的一些常用快捷键。 control-空格键：切换输入法 command-C：拷贝到剪切板 command-V：粘贴 command-X：剪切 command-Z：撤销上一个命令 command-D：复制（生成文件副本） command-tab：在打开的应用中切换到下一个最近使用的应用 command-delete：将所选项移到废纸篓（或者将废纸篓中的文件还回原处） shift-command-delete：清空废纸篓 shift-command-N：在”访达”中创建一个文件夹 shift-command-.:显示隐藏文件（或者恢复隐藏状态） enter：重命名 关于MacOS的更多快捷键，请参看这里。]]></content>
      <categories>
        <category>macos</category>
      </categories>
      <tags>
        <tag>macos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的异常处理]]></title>
    <url>%2F2019%2F01%2F17%2Fjava-exception-handle%2F</url>
    <content type="text"><![CDATA[Java异常处理 异常分类​ 在Java中，所有的异常都是继承自Throwable。 Java中的异常层次结构 ​ 派生于Error类或RuntimeException类的所有异常称为非受查（unchecked）异常，所有其他异常称为受查（check）异常。 声明异常​ 方法应该在其首部声明所有可能抛出的异常。语法如下： 1public FileInputStream(String name) throws FileNotFoundException 抛出异常创建异常捕获异常finally子句带资源的try语句]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的命令行工具javap]]></title>
    <url>%2F2019%2F01%2F15%2Fjava-command-javap%2F</url>
    <content type="text"><![CDATA[javap，全称java printer，是JDK中的一个基础命令行工具，用于反编译一个或多个class文件。其输出取决于使用的选项。如果未使用任何选项，则javap命令将打印具有包，protected和public权限的字段和方法，并将其输出打印到标准输出stdout。 关于javap的详细用法如下： 12345678910111213141516171819用法: javap &lt;options&gt; &lt;classes&gt;其中, 可能的选项包括: -help --help -? 输出此用法消息 -version 版本信息 -v -verbose 输出附加信息 -l 输出行号和本地变量表 -public 仅显示公共类和成员 -protected 显示受保护的/公共类和成员 -package 显示程序包/受保护的/公共类 和成员 (默认) -p -private 显示所有类和成员 -c 对代码进行反汇编 -s 输出内部类型签名 -sysinfo 显示正在处理的类的 系统信息 (路径, 大小, 日期, MD5 散列) -constants 显示最终常量 -classpath &lt;path&gt; 指定查找用户类文件的位置 -cp &lt;path&gt; 指定查找用户类文件的位置 -bootclasspath &lt;path&gt; 覆盖引导类文件的位置 其中，常用的选项有 123456-public-protected-package-p -private-c -s 以下面的程序为例，Main类包含了private、default(缺省)、protected和public四种访问权限的字段和方法。 123456789101112131415161718192021222324252627282930313233343536public class Main &#123; private int number = 1; int UID = 1234; protected String name = "Main"; public String javaVersion = "1.8"; public Main() &#123; printNumber(); &#125; private void printNumber() &#123; System.out.println("number:"+number); &#125; void printUID() &#123; System.out.println("UID:"+UID); &#125; protected void printName() &#123; System.out.println("name:"+name); &#125; public void printVersion() &#123; System.out.println("javaVersion:"+javaVersion); &#125; public static void main(String[] args) &#123; Main main = new Main(); main.printUID(); main.printName(); main.printVersion(); &#125;&#125; 编译Main.java，得到Main.class文件 1.javap的默认选项为-package，只输出具有包、protected和public的字段和方法。在命令行中使用javap或者javap -package查看Main.class，输出的内容如下： 123456789101112hgs:~ hegongshan$ javap Main.class Compiled from "Main.java"public class Main &#123; int UID; protected java.lang.String name; public java.lang.String javaVersion; public Main(); void printUID(); protected void printName(); public void printVersion(); public static void main(java.lang.String[]);&#125; 2.使用javap -public将只输出class文件中的public字段和方法。以Main.class为例，输出内容如下： 12345678hgs:~ hegongshan$ javap -public Main.classCompiled from "Main.java"public class com.hegongshan.Main &#123; public java.lang.String javaVersion; public com.hegongshan.Main(); public void printVersion(); public static void main(java.lang.String[]);&#125; 3.javap -protected将输出类中的public和protected的字段和方法。以Main.class为例，输出内容如下： 12345678910hgs:~ hegongshan$ javap -protected Main.classCompiled from "Main.java"public class com.hegongshan.Main &#123; protected java.lang.String name; public java.lang.String javaVersion; public com.hegongshan.Main(); protected void printName(); public void printVersion(); public static void main(java.lang.String[]);&#125; 4.javap -p或者javap -private将输出类中的所有字段和方法。以Main.class为例，输出内容如下： 1234567891011121314hgs:~ hegongshan$ javap -p Main.classCompiled from "Main.java"public class com.hegongshan.Main &#123; private int number; int UID; protected java.lang.String name; public java.lang.String javaVersion; public com.hegongshan.Main(); private void printNumber(); void printUID(); protected void printName(); public void printVersion(); public static void main(java.lang.String[]);&#125; 5.javap -c将对class文件进行反编译。以Main.class为例，输出内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485hgs:~ hegongshan$ javap -c Main.classCompiled from "Main.java"public class com.hegongshan.Main &#123; int UID; protected java.lang.String name; public java.lang.String javaVersion; public com.hegongshan.Main(); Code: 0: aload_0 1: invokespecial #14 // Method java/lang/Object."&lt;init&gt;":()V 4: aload_0 5: iconst_1 6: putfield #16 // Field number:I 9: aload_0 10: sipush 1234 13: putfield #18 // Field UID:I 16: aload_0 17: ldc #20 // String Main 19: putfield #22 // Field name:Ljava/lang/String; 22: aload_0 23: ldc #24 // String 1.8 25: putfield #26 // Field javaVersion:Ljava/lang/String; 28: aload_0 29: invokespecial #28 // Method printNumber:()V 32: return void printUID(); Code: 0: getstatic #35 // Field java/lang/System.out:Ljava/io/PrintStream; 3: new #41 // class java/lang/StringBuilder 6: dup 7: ldc #62 // String UID: 9: invokespecial #45 // Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V 12: aload_0 13: getfield #18 // Field UID:I 16: invokevirtual #48 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder; 19: invokevirtual #52 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 22: invokevirtual #56 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 25: return protected void printName(); Code: 0: getstatic #35 // Field java/lang/System.out:Ljava/io/PrintStream; 3: new #41 // class java/lang/StringBuilder 6: dup 7: ldc #65 // String name: 9: invokespecial #45 // Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V 12: aload_0 13: getfield #22 // Field name:Ljava/lang/String; 16: invokevirtual #67 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: invokevirtual #52 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 22: invokevirtual #56 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 25: return public void printVersion(); Code: 0: getstatic #35 // Field java/lang/System.out:Ljava/io/PrintStream; 3: new #41 // class java/lang/StringBuilder 6: dup 7: ldc #71 // String javaVersion: 9: invokespecial #45 // Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V 12: aload_0 13: getfield #26 // Field javaVersion:Ljava/lang/String; 16: invokevirtual #67 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 19: invokevirtual #52 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 22: invokevirtual #56 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 25: return public static void main(java.lang.String[]); Code: 0: new #1 // class com/hegongshan/Main 3: dup 4: invokespecial #75 // Method "&lt;init&gt;":()V 7: astore_1 8: aload_1 9: invokevirtual #76 // Method printUID:()V 12: aload_1 13: invokevirtual #78 // Method printName:()V 16: aload_1 17: invokevirtual #80 // Method printVersion:()V 20: return&#125; 6.javap -s将输出内部类型签名。以Main.class为例，输出内容如下： 123456789101112131415161718192021222324hgs:~ hegongshan$ javap -s Main.classCompiled from "Main.java"public class com.hegongshan.Main &#123; int UID; descriptor: I protected java.lang.String name; descriptor: Ljava/lang/String; public java.lang.String javaVersion; descriptor: Ljava/lang/String; public com.hegongshan.Main(); descriptor: ()V void printUID(); descriptor: ()V protected void printName(); descriptor: ()V public void printVersion(); descriptor: ()V public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V&#125; 上述输出内容中，对于字段，descriptor:后的字符，表示字段的类型，对应关系如下： 12345678910B : byteC : charD : doubleF : floatI : intJ : longL类名; : 引用类型,如Ljava/lang/String; 表示 String类型S : shortZ : boolean[ : 数组,如[Ljava/lang/String; 表示String[] 对于方法，descriptor:后的字符(参数类型描述)返回值类型描述，表示方法的参数类型及其返回值的类型。 1V : void,表示没有返回值]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内部类实现原理分析]]></title>
    <url>%2F2019%2F01%2F14%2Fjava-inner-class-implementation-principle%2F</url>
    <content type="text"><![CDATA[​ 本文通过分析编译后的class文件，来揭秘Java中内部类的实现原理。 在解开内部类的神秘面纱之前，让我们先来看如下代码： 12345678910111213141516171819202122232425262728293031public class OuterClass &#123; private String name; public OuterClass(String name) &#123; this.name = name; System.out.println("OuterClass初始化"); System.out.println("name："+this.name); &#125; class InnerClass &#123; public InnerClass() &#123; System.out.println("InnerClass初始化"); &#125; public void print() &#123; if(name.equals("hegongshan.com")) &#123; name = "software engineering"; System.out.println("InnerClass.print()"); System.out.println("更新后的name："+name); &#125; &#125; &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass("hegongshan.com"); OuterClass.InnerClass inner = outer.new InnerClass(); inner.print(); &#125;&#125;输出结果：OuterClass初始化name：hegongshan.comInnerClass初始化InnerClass.print()更新后的name：software engineering 上述程序编译之后生成了如下两个class文件： 12OuterClass$InnerClass.classOuterClass.class 可以看到，编译器将内部类InnerClass翻译成了名为OuterClass$InnerClass.class的class文件。 下面我们在命令行中使用javap命令来查看下编译之后的OuterClass$InnerClass.class文件（关于javap的更多描述请参看《Java中的命令行工具javap》） 12//在UNIX中，需要对$转义，其他系统中不需要加\javap -p OuterClass\$InnerClass.class 输出内容如下： 123456Compiled from "OuterClass.java"class OuterClass$InnerClass &#123; final OuterClass this$0; public OuterClass$InnerClass(OuterClass); public void print();&#125; 可以清楚地看到，编译器为了引用外部类，生成了一个使用final修饰的外部类变量，命名为this$0（名字this$0是由编译器合成的，在自己编写的代码中不能够引用它）。 另外，可以看到构造器的参数，在InnerClass中，我们并没有写构造方法，编译器为InnerClass自动生成了一个带参数的构造方法，传入一个外部类对象的引用。 开篇提到，内部类可以访问外围类中的所有方法和变量，即使这些方法和变量声明为private。既然内部类可以被编译器翻译为名字古怪的普通类（虚拟机对此一无所知），内部类如何管理那些额外的访问特权呢？ 再次使用javap命令查看生成的Outerclass.class,结果如下： 12345678Compiled from "OuterClass.java"public class OuterClass &#123; private java.lang.String name; public OuterClass(java.lang.String); public static void main(java.lang.String[]); static java.lang.String access$0(OuterClass); static void access$1(OuterClass, java.lang.String);&#125; 我们注意到，编译器在外围类中添加了两个静态方法access$0和access$1，它们均需要传入一个外围类对象的引用。此外，access$1还需要传入一个字符串变量。（方法名可能稍有不同，如access$00，这取决于你的编译器。） 内部类通过调用access$0方法，从而实现对外围类的私有属性name的访问；通过调用access$1方法，从而实现对外围类的私有属性name的修改。 如果编译器能够自动地进行转换，那么我们能不能编写程序实现这种机制呢？ 1234567891011121314151617181920212223242526272829303132333435public class Main &#123; public static void main(String[] args) &#123; Outer outer = new Outer("hegongshan.com"); Inner inner = new Inner(outer); inner.print(); &#125;&#125;class Inner &#123; final Outer outer; public Inner(Outer outer) &#123; this.outer = outer; System.out.println("Inner初始化"); &#125; public void print() &#123; System.out.println("name:"+Outer.getName(outer)); if(Outer.getName(outer).equals("hegongshan.com")) &#123; Outer.setName(outer, "software engineering"); System.out.println("更新后的name:"+Outer.getName(outer)); &#125; &#125;&#125;class Outer &#123; private String name; public Outer(String name) &#123; this.name = name; System.out.println("Outer初始化"); System.out.println("name:"+name); &#125; static String getName(Outer outer) &#123; return outer.name; &#125; static void setName(Outer outer,String name) &#123; outer.name = name; &#125;&#125; 输出结果： 12345Outer初始化name:hegongshan.comInner初始化name:hegongshan.com更新后的name:software engineering 可以看到，通过模仿编译后的class文件中的代码，在Outer中添加一些特殊的方法，在Inner类中添加特殊的构造器，我们在Inner类中访问和修改了Outer类中的私有属性。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的内部类继承]]></title>
    <url>%2F2019%2F01%2F13%2Fjava-inner-class-extends%2F</url>
    <content type="text"><![CDATA[由于Java中的匿名内部类不能被继承，而局部内部类和静态内部类的继承，与普通类继承没有区别。故本文主要描述成员内部类的继承问题。 成员内部类的继承可分为以下三种情况： 内部类及其子类在同一个外围类中 内部类及其子类在不同的外围类中 内部类的子类不是内部类 下面对这三种情况逐一分析 内部类及其子类在同一个外围类中在这种情况下，内部类和子类都是同一个外围类的内部类，此时成员内部类的继承与普通类的继承没有区别。下面通过一个示例来说明这个问题： 1234567891011121314151617181920212223class WithInner &#123; class Inner&#123; public Inner() &#123; System.out.println("Inner"); &#125; &#125; class InheritInner extends Inner &#123; public InheritInner() &#123; System.out.println("InheritInner"); &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; WithInner wi = new WithInner(); WithInner.InheritInner ii = wi.new InheritInner(); &#125;&#125;输出如下：InnerInheritInner 上述程序编译后，生成了如下的class文件 1234Main.classWithInner$InheritInner.classWithInner$Inner.classWithInner.class 在《Java内部类实现原理分析》中，我们已经知道编译器会为内部类自动添加一个声明为final的外围类字段，并为内部类自动生成一个带参数的构造方法，就像下面这样： 12345Compiled from "Main.java"class WithInner$InheritInner extends WithInner$Inner &#123; final WithInner this$0; public WithInner$InheritInner(WithInner);&#125; 由于WithInner$InheritInner类和WithInner$Inner类都在WithInner类中，编译器会为WithInner$InheritInner类自动添加声明为final的WithInner，故WithInner$InheritInner类继承WithInner$Inner类时，我们并不需要做什么额外的工作，就像普通类继承一样。 内部类及其子类在不同的外围类中先来看下面的程序 12345678910111213141516171819202122232425class WithInner &#123; class Inner&#123; public Inner() &#123; System.out.println("Inner"); &#125; &#125;&#125;class Outer &#123; class InheritInner extends WithInner.Inner &#123; public InheritInner(WithInner wi) &#123; wi.super(); System.out.println("InheritInner"); &#125; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; WithInner wi = new WithInner(); Outer outer = new Outer(); Outer.InheritInner ii = outer.new InheritInner(wi); &#125;&#125;输出如下：InnerInheritInner InheritInner继承自内部类WithInner.Inner，由于InheritInner不在WithInner中，编译器不会为其自动添加具有WithInner参数的构造器，当要生成一个构造器时，必须传入一个指向外围类对象的引用。此外，还必须在构造器内使用如下语法，显式地调用其父类WithInner.Inner的构造器： 1enclosingClassReference.super(); 否则，将会产生如下错误： 123No enclosing instance of type WithInner is accessible to invoke the super constructor. Must define a constructor and explicitly qualify its super constructor invocationwith an instance of WithInner (e.g. x.super() where x is an instance of WithInner). 翻译过来就是 123没有外围类WithInner的实例，无法调用父类构造器。必须定义一个构造器，并且用WithInner的实例显式地调用父类构造器。（如，x.super(),其中x是WithInner的一个实例） 上述程序编译后，生成了如下的class文件 12345Main.classOuter$InheritInner.classOuter.classWithInner$Inner.classWithInner.class 使用javap -p查看Outer$InheritInner.class,输出内容如下： 12345Compiled from "Main.java"class Outer$InheritInner extends WithInner$Inner &#123; final Outer this$0; public Outer$InheritInner(Outer, WithInner);&#125; 不难想到，编译之后的Outer$InheritInner应该是下面这个样子: 123456789class Outer$InheritInner extends WithInner$Inner &#123; final Outer this$0; public Outer$InheritInner(Outer outer, WithInner wi) &#123;//先初始化父内部类，从而初始化父内部类中的final WithInner this$0，继而通过继承得到对WithInner的引用 wi.super(wi); this$0 = outer; ... &#125;&#125; 内部类的子类不是内部类下面通过一个示例来说明这个问题： 1234567891011121314class WithInner &#123; class Inner&#123;&#125;&#125;class InheritInner extends WithInner.Inner&#123; public InheritInner(WithInner wi) &#123; wi.super(); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; WithInner wi = new WithInner(); InheritInner ii = new InheritInner(wi); &#125;&#125; 和“内部类及其子类在不同的外围类中”的情况一样，当内部类的子类不是一个内部类时，我们也必须显式地添加一个带外围类对象的构造器，并在构造器内使用如下语法： 1enclosingClassReference.super(); 否则，会产生如下错误： 1No enclosing instance of type WithInner is available due to some intermediate constructor invocation 翻译过来就是 1由于一些中间构造器的调用，没有外围类WithInner的实例可用]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的内部类]]></title>
    <url>%2F2019%2F01%2F12%2Fjava-inner-class%2F</url>
    <content type="text"><![CDATA[将一个类的定义放在另一个类的定义内部，这就是内部类。如下所示 123456class OuterClass &#123; ... class InnerClass &#123; ... &#125;&#125; 从总体上来讲，Java中的内部类可以分为： 静态内部类（static inner class）：声明为static的内部类 非静态内部类（non-static inner class） 123456789class OuterClass &#123; ... static class StaticInnerClass &#123; ... &#125; class InnerClass &#123; ... &#125;&#125; 其中，非静态内部类又可细分为以下三种： 成员内部类：作为外部类的成员定义 局部内部类（local inner class）：在外部类的方法中定义 匿名内部类（anonymous inner class）：没有名字的内部类 内部类是一种编译器现象，与虚拟机无关。它可以访问外部类中定义的所有方法和域，即使这些方法和域声明为private。此外，内部类可以使用访问说明符public、protected和private修饰。 非静态内部类非静态内部类中不能声明static方法，声明的所有静态域都必须是final。 内部类的特殊语法要想实例化一个非静态内部类，需要使用一种特殊的语法.new，就像下面这样： 1234567public class OuterClass &#123; class InnerClass &#123;&#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); InnerClass inner = outer.new InnerClass(); &#125;&#125; 在外部类的作用域之外，可以这样引用内部类： 1OuterClass.InnerClass 下面是示例展示了如何在外部类的作用域之外，实例化它的内部类。 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); OuterClass.InnerClass inner = outer.new InnerClass(); &#125;&#125;class OuterClass &#123; class InnerClass &#123; public InnerClass() &#123; System.out.println("InnerClass实例化"); &#125; &#125;&#125;输出结果：InnerClass实例化 在内部类中，如果需要使用外部类对象的引用，可以使用外部类的名字后紧跟圆点和this，就像这样OuterClass.this​,下面是一个简单的示例： 1234567891011121314151617public class OuterClass &#123; public void print() &#123; System.out.println("OuterClass.print()"); &#125; class InnerClass &#123; public OuterClass getOuter() &#123; return OuterClass.this; &#125; &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); InnerClass inner = outer.new InnerClass(); inner.getOuter().print(); &#125;&#125;输出结果：OuterClass.print() 成员内部类成员内部类是最常见的内部类，也称为普通内部类。成员内部类作为外部类的成员来定义，如下所示： 12345public class OuterClass &#123; class InnerClass &#123; &#125;&#125; 局部内部类在外围类的方法中声明的类，称为局部内部类。下面是一个简单的例子 123456789101112131415161718192021222324252627public class Outer &#123; private int count = 0; public void start() &#123; class LocalInnerClass &#123; public void service() &#123; System.out.println(count); count++; &#125; &#125; LocalInnerClass inner = new LocalInnerClass(); for (int i = 0; i &lt; 5; i++) &#123; inner.service(); &#125; &#125; public static void main(String[] args) &#123; Outer main = new Outer(); main.start(); &#125;&#125;输出结果：01234 局部内部类不能用public、protected或private访问说明符声明。它的优势是对外部世界可以完全地隐藏起来，除了start方法之外，Outer的其他地方均不能访问它。 匿名内部类匿名内部类，顾名思义，就是没有命名的内部类。语法格式如下 123new SuperType(construction parameters) &#123; 方法和属性&#125; 下面是匿名内部类的一个示例。 12345678910111213141516171819202122232425262728293031interface Counter &#123; int next();&#125;public class Outer &#123; private int count = 0; Counter getCounter(final String name) &#123; return new Counter() &#123; &#123; System.out.println("Counter()"); &#125; public int next() &#123; System.out.print(name); return count++; &#125; &#125;; &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Counter c = outer.getCounter(); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(c.next()); &#125; &#125;&#125;输出结果：Counter()01234 在上面的程序中，由于getCounter方法中的name这个变量不是外围类中定义的属性，所以必须声明为final类型，才能在匿名内部类中使用（对于局部内部类，情况也是一样的），否则，将产生如下的语法错误： 1Cannot refer to the non-final local variable name defined in an enclosing scope 由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。因此，将参数传递给超类（父类）构造器。在匿名内部类实现接口的时候，不能有任何构造参数。 静态内部类静态内部类，就是声明为static的内部类。实例化静态内部类，不需要其外围类对象。下面是一个静态内部类的示例： 12345678910111213141516171819202122public class Outer &#123; private int count = 0; private static String className = "OUTER"; public static class StaticInnerClass &#123; public StaticInnerClass(String name) &#123; System.out.println(name); System.out.println("outer class name:"+className); &#125; &#125; public static void main(String[] args) &#123; Outer main = new Outer(); //下面两种实例化方法是等价的 StaticInnerClass inner = new StaticInnerClass("inner"); Outer.StaticInnerClass inner2 = new Outer.StaticInnerClass("inner2"); &#125;&#125;输出结果：innerouter class name:OUTERinner2outer class name:OUTER 值得一提的是，静态内部类不能访问外围类中的非静态的域和方法。以上面的程序为例，StaticInnerClass类可以访问到Outer类的className属性，因为className声明为static，但StaticInnerClass类不能访问count。 什么时候使用静态内部类？在内部类不需要访问外围类对象的时候，应该使用静态内部类。 内部类标识符对于成员内部类和静态内部类，编译器将会把它编译成文件名为外围类名$内部类名.class的class文件。 对于匿名内部类，编译器会将它编译名为外围类名$n.class的class文件；对于局部内部类，则被编译为外围类名$n内部类名的class文件。（n是由编译器简单生成的一个数字） 下面通过一个简单的例子来展示这四种内部类的字节码文件的命名规则 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152interface Counter &#123; int next();&#125;public class Outer &#123; private int count = 0; class NormalCounter implements Counter &#123; public int next() &#123; return count++; &#125; &#125; Counter getCounter(final String name) &#123; class LocalCounter implements Counter &#123; static final String name = ""; public LocalCounter() &#123; System.out.println("LocalCounter()"); &#125; public int next() &#123; System.out.print(name); return count++; &#125; &#125; return new LocalCounter(); &#125; Counter getCounter2(final String name) &#123; return new Counter() &#123; &#123; System.out.println("Counter()"); &#125; public int next() &#123; System.out.print(name); return count++; &#125; &#125;; &#125; static class StaticInnerClass&#123; &#125; public static void main(String[] args) &#123; Outer lic = new Outer(); Counter c1 = lic.getCounter("Local inner class "); Counter c2 = lic.getCounter2("Anonymous inner class "); for (int i = 0; i &lt; 5; i++) &#123; System.out.println(c1.next()); &#125; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(c2.next()); &#125; &#125;&#125; Outer.java编译之后，生成了如下几个class文件： 123456Counter.classOuter$1.classOuter$1LocalCounter.classOuter$NormalCounter.classOuter$StaticInnerClass.classOuter.class]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的final关键字]]></title>
    <url>%2F2019%2F01%2F10%2Fjava-final%2F</url>
    <content type="text"><![CDATA[​ 在Java中，final关键字可以用于域、方法和类的声明，所处位置不同，其作用也不同。 final域使用final声明的域，在使用前必须被初始化，且一旦被初始化便无法改变。下面是一个简单的例子： 1234567public class Main &#123; final int number = 1; public static void main(String[] args) &#123; Main main = new Main(); //main.number = 2; &#125;&#125; 当我们想改变number的值时，产生了如下错误： 1The final field Main.number cannot be assigned 空白final空白final是指被声明为final但又未给定初始值的域。必须在构造器中对空白final进行赋值，以确保空白final在使用前被初始化。下面是空白final的一个例子： 1234567891011public class Main &#123; final int x = 20; final int number;//空白final public Main(int number) &#123; this.number = number; &#125; public static void main(String[] args) &#123; Main main = new Main(2); &#125;&#125; 因此，综合空白final和定义时已被初始化的final字段，我们可以说：final字段必须在域的定义处或者构造器中被初始化。 static final域和final域的区别当域声明为static final时，表示该字段在类装载时已被初始化，而不是每次创建新对象时都初始化。此外，声明为static final的字段，在该类的所有对象中值是唯一的且不能改变。而final域是在创建对象时才被初始化，每个对象中该字段的值不一定相同，但在同一对象中，该字段的值是唯一的。下面的例子直白地说明了二者的区别： 1234567891011121314151617181920public class Main &#123; public static final int CAPACITY = 10; private final int id; public Main(int id) &#123; this.id = id; &#125; public String toString() &#123; return "id=" + id + ",CAPACITY=" + CAPACITY; &#125; public static void main(String[] args) &#123; Main main = new Main(2); System.out.println(main); Main main2 = new Main(3); System.out.println(main2); System.out.println(main); &#125;&#125; 输出结果： 123id=2,CAPACITY=10id=3,CAPACITY=10id=2,CAPACITY=10 final参数Java允许在参数列表中以声明的方式将参数指明为final。这一特性主要用来向匿名类传递数据。 123456789101112public class Main &#123; public void say(final String name) &#123; System.out.println("hello "+name); //name = "new"+name; &#125; public static void main(String[] args) &#123; Main main = new Main(); main.say("hgs"); &#125;&#125; 当我们想改变name的值时，将产生如下错误： 1The final local variable name cannot be assigned. It must be blank and not using a compound assignment final方法使用final声明的方法，表示在子类中不允许被覆盖。下面我们尝试下覆盖父类中的final方法 12345678910class Parent &#123; public final void say(String word) &#123; System.out.println(word); &#125;&#125;class Child extends Parent &#123; /*public void say(String word) &#123; &#125;*/&#125; 产生了如下错误： 1Cannot override the final method from Parent final和private 关键字类中所有的private方法都隐式地指定为是final的。可以将private方法声明为final，但这并不会给方法增加任何额外的意义。 final类当某个类用final声明时，表明这个类不允许被继承。由于final类禁止继承，所以final类中所有的方法都隐式指定为是final的，但类中的域并不会自动地成为final。 123456789101112131415161718192021222324252627public class Main &#123; public static void main(String[] args) &#123; FinalClass fc = new FinalClass("final class"); System.out.println("number="+fc.number); System.out.println("name="+fc.getName()); fc.setName("name"); System.out.println("name="+fc.getName()); //fc.number += 1; //The final field FinalClass.number cannot be assigned &#125;&#125;final class FinalClass &#123; private String name; public final int number = 1; public FinalClass(String name) &#123; this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;//class ChildFinalClass extends FinalClass&#123;&#125;//The type ChildFinalClass cannot subclass the final class FinalClass 输出结果如下： 123number=1name=final classname=name 在final类中可以给方法添加final修饰符，但这并不会增添任何意义。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年度总结]]></title>
    <url>%2F2019%2F01%2F04%2F2018-year-end-summary%2F</url>
    <content type="text"><![CDATA[目标明确，才能不迷失方向！是时候总结下过去一年的收获了，顺便给新的一年制定下计划。 2018年度总结 3月27日，武汉大学计算机学院硕士研究生拟录取结果公布 4月12日，进入朱卫平老师的智慧爬虫小组 7月3日，“乐渔”课程教学系统 软件著作权申请（10月15日审批通过） 9月5日，进入丁立新老师的课题组（原国软的老师不能带原计算机的学生） 11月22日，结束考研辅导（6月1日开始） 12月5日，“锐捷杯”华中区研究生程序设计大赛一轮游(accept 3/10)，rank 34/105 12月16日，第十五次CSP 130分 2019年度计划 1-2月，项目开发（软著） 3月17日，第十六次CSP，目标300 5月，CET6，标500+ 5月25日，软考系统分析师 9月22日，第十七次CSP，目标400 10月，CCSP竞赛，目标铜牌 11月9日，软考系统架构设计师 12月，“锐捷杯”华中区研究生程序设计大赛，目标三等奖]]></content>
      <categories>
        <category>任重而道远</category>
      </categories>
      <tags>
        <tag>任重而道远</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx返回413 Request Entity Too Large]]></title>
    <url>%2F2018%2F10%2F14%2Fnginx-413-request-entity-too-large%2F</url>
    <content type="text"><![CDATA[问题描述 晚上9点55分，前老板在讨论组中截了一张图片，显示的是课程网站上传文件失败的弹框，弹框内容如下 1SyntaxError: JSON.parse: unexpected character at line2 column 1 of the JSON data 下意识以为是自己代码写的有问题，赶紧在本机测试了下，发现很小的文件都能正常上传，但是稍大一点的文件就会出现如下错误 1SyntaxError: Unexpected token &lt; in JSON at position 1 浏览器控制台报错内容如下 1413 Request Entity Too Large 查看了下Spring MVC的配置文件，上传大小写的足够大，这显然不是Spring MVC的问题。后来发现可能是Nginx的问题，试着改了下本地Nginx的配置文件，果然就传成功了。 原因 nginx服务器做反向代理时，对上传的文件大小有限制，默认为2M 解决办法 在nginx.conf的http{}中，添加一行 1client_max_body_size 200m; 文件大小限制可以根据需求自行改变。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL中的空值处理(null)]]></title>
    <url>%2F2018%2F09%2F19%2Fsql-null-value%2F</url>
    <content type="text"><![CDATA[SQL中的空值处理主要分为以下两种情况： 1.涉及空值的条件判断；2.涉及空值的更新操作。 涉及空值的条件判断where子句中不能使用 = null 来进行空值判断，必须使用 is null 和 is not null 。 示例： 某些学生选修某门课程后没有参加考试，所以有选课记录，但没有考试成绩。 试查询缺少成绩的学生的学号和相应的课程号。 123select sno,cnofrom scwhere grade is null; 注意，” grade is null “不能写为“ grade = null”。 查所有有成绩记录的学生的学号和相应的课程号。 123select sno,cnofrom scwhere grade is not null; 涉及空值的更新操作在update语句的set中，使用 = null 设置某列为空。 将选修“高级算法分析与设计”课不及格的学生成绩设置为空值。 1234567update scset grade = nullwhere grade &lt; 60 and cno in ( select cno from course where cname = "高级算法分析与设计");]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL中删除表中数据的几种方法]]></title>
    <url>%2F2018%2F09%2F19%2Fsql-drop-delete-and-truncate-table%2F</url>
    <content type="text"><![CDATA[SQL中删除表数据有以下三种方法： 1.使用drop table语句；2. 使用delete语句；3. 使用truncate table语句。 drop table1drop table 表名; 功能：删除表，表的结构、表中的数据以及索引等全部被删除。 delete1delete from 表名 [where 条件]; 功能：根据条件删除表中的数据，但不删除表的定义。 truncate table1truncate table 表名; 功能：清空表中的全部数据，但不删除表的定义。 truncate table 与delete语句不同的地方在于， 1.truncate table语句没有where条件。 2.truncate table语句会使表回到刚创建的初始状态，如重置表中的自增值等，而delete 语句不会。 3.truncate table语句不会触发触发器，而delete语句会触发触发器。 若要清空表中的数据，但不删除表，推荐使用 truncate table语句。]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL中的字符匹配（like）]]></title>
    <url>%2F2018%2F09%2F19%2Fsql-like%2F</url>
    <content type="text"><![CDATA[like可以用于字符串的匹配，其一般语法如下： 1[not] like '&lt;匹配串&gt;' [escape '&lt;换码字符&gt;'] 其含义是查找指定的属性列值与&lt;匹配串&gt;相匹配的元组。&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符 % 和 _ 。 %：匹配任意长度(长度可以为0)的字符串 _：匹配任意单个字符(一个汉字占两个字符) 示例： 1.查询所有姓刘的学生的姓名、学号和性别。 123select sname,sno,sexfrom studentwhere sname like '刘%'; 2.查询所有姓“贺”且全名为两个汉字的学生的姓名 123select snamefrom studentwhere sname like '贺__'; 由于一个汉字占两个字符，所以贺字后需要跟两个_ 3.查询名字中第二个字为“扬”字的学生姓名和学号 123select sname,snofrom studentwhere sname like '__扬%'; ４.查询名字中包含”山”的学生姓名 123select snamefrom studentwhere sname like '%山%'; ５.查询所有不姓刘的学生姓名 123select snamefrom studentwhere sname not like '刘%' 如果需要查询的匹配字符串本身就含有%和_，可以使用escape ‘&lt;换码字符&gt;’对通配符进行转义。 示例： 6.查询Algorithms_Design课程的课程号和学分 123select cno,creditfrom coursewhere cname like 'Algorithms\_Design' escape '\'; 7.查询课程名以“算法_”开头，且倒数第二个汉字为“设”的课程详情。 123select *from coursewhere cname like '算法\_%设__' escape '\'; 注意：换码字符是可以变化的，一般取不常用的符号。若匹配串中本身含有 “ \ ”，则换码字符可取 “ ? ”等。]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL中的各种join]]></title>
    <url>%2F2018%2F09%2F14%2Fsql-join%2F</url>
    <content type="text"><![CDATA[SQL中的连接操作很多，这里总结一下。 假设有以下两张表 教师表teacher teacher_id teacher_name 1 刘娟 2 朱卫平 3 刘婧 4 李春葆 课程表course course_id course_name teacher_id 1 商务智能 2 2 高级算法分析与设计 1 3 程序设计方法学 3 4 模式识别 2 sql如下： 1234567891011121314151617181920create table teacher ( teacher_id int, teacher_name varchar(32), primary key(teacher_id));insert into teacher(teacher_id,teacher_name) values (1,'刘娟');insert into teacher(teacher_id,teacher_name) values (2,'朱卫平');insert into teacher(teacher_id,teacher_name) values (3,'刘婧');insert into teacher(teacher_id,teacher_name) values (4,'李春葆');create table course( course_id int, course_name varchar(32), teacher_id int, primary key(course_id), foreign key(teacher_id) references teacher(teacher_id));insert into course(course_id,course_name,teacher_id) values (1,'商务智能',2);insert into course(course_id,course_name,teacher_id) values (2,'高级算法分析与设计',1);insert into course(course_id,course_name,teacher_id) values (3,'程序设计方法学',3);insert into course(course_id,course_name,teacher_id) values (4,'模式识别',2); cross join交叉连接(cross join)：如果不带where子句，它将会返回被连接的两个表的笛卡尔积，返回结果的行数等于两个表行数的乘积。 语法： 1234select 列名,...from table1cross join table2[where 条件] 示例： 1select * from teacher cross join course; 输出： 1234567891011121314151617181920+------------+--------------+-----------+-----------------------------+------------+| teacher_id | teacher_name | course_id | course_name | teacher_id |+------------+--------------+-----------+-----------------------------+------------+| 1 | 刘娟 | 1 | 商务智能 | 2 || 2 | 朱卫平 | 1 | 商务智能 | 2 || 3 | 刘婧 | 1 | 商务智能 | 2 || 4 | 李春葆 | 1 | 商务智能 | 2 || 1 | 刘娟 | 2 | 高级算法分析与设计 | 1 || 2 | 朱卫平 | 2 | 高级算法分析与设计 | 1 || 3 | 刘婧 | 2 | 高级算法分析与设计 | 1 || 4 | 李春葆 | 2 | 高级算法分析与设计 | 1 || 1 | 刘娟 | 3 | 程序设计方法学 | 3 || 2 | 朱卫平 | 3 | 程序设计方法学 | 3 || 3 | 刘婧 | 3 | 程序设计方法学 | 3 || 4 | 李春葆 | 3 | 程序设计方法学 | 3 || 1 | 刘娟 | 4 | 模式识别 | 2 || 2 | 朱卫平 | 4 | 模式识别 | 2 || 3 | 刘婧 | 4 | 模式识别 | 2 || 4 | 李春葆 | 4 | 模式识别 | 2 |+------------+--------------+-----------+-----------------------------+------------+ inner join等值连接（inner join或join）:返回两张表中相互匹配的行。 语法： 1234select 列名,...from table1[inner] join table2on table1.column_name = table2.column_name; 其中的inner是可省略的。 示例： 查询每门课程的的课程号、课程名称、教师编号以及教师姓名。 123select course.*,teacher.teacher_name from courseinner join teacheron course.teacher_id = teacher.teacher_id; 输出： 12345678+-----------+-----------------------------+------------+--------------+| course_id | course_name | teacher_id | teacher_name |+-----------+-----------------------------+------------+--------------+| 2 | 高级算法分析与设计 | 1 | 刘娟 || 1 | 商务智能 | 2 | 朱卫平 || 4 | 模式识别 | 2 | 朱卫平 || 3 | 程序设计方法学 | 3 | 刘婧 |+-----------+-----------------------------+------------+--------------+ natural join自然连接(natural join)：在等值连接的基础上，去掉重复的列名。 语法： 123select 列名,...from table1natural join table2; 示例： 12select * from coursenatural join teacher 输出： 由于course表中已经包含了teacher_id，所以，在进行自然连接时，自动去掉了teacher表中多余的teacher_id。 12345678+------------+-----------+-----------------------------+--------------+| teacher_id | course_id | course_name | teacher_name |+------------+-----------+-----------------------------+--------------+| 1 | 2 | 高级算法分析与设计 | 刘娟 || 2 | 1 | 商务智能 | 朱卫平 || 2 | 4 | 模式识别 | 朱卫平 || 3 | 3 | 程序设计方法学 | 刘婧 |+------------+-----------+-----------------------------+--------------+ left join左外连接(left outer join)：返回左表中的所有行及右表中满足on条件的行，如果右表没有匹配的行，对应列填充NULL。 其中outer是可省略的，即可写为left join。 示例： 查询所有的教师信息，即使他尚未被安排课程 123select course.*,teacher.teacher_name from teacherleft outer join courseon course.teacher_id = teacher.teacher_id; 输出： 123456789+-----------+-----------------------------+------------+--------------+| course_id | course_name | teacher_id | teacher_name |+-----------+-----------------------------+------------+--------------+| 2 | 高级算法分析与设计 | 1 | 刘娟 || 1 | 商务智能 | 2 | 朱卫平 || 4 | 模式识别 | 2 | 朱卫平 || 3 | 程序设计方法学 | 3 | 刘婧 || NULL | NULL | NULL | 李春葆 |+-----------+-----------------------------+------------+--------------+ right join右外连接(right outer join)：返回右表有行和左表中满足on条件的行，如果左表没有匹配的行，对应列填充NULL。 其中outer是可省略的，即可写为right join。 示例： 查询所有的教师信息，即使他尚未被安排课程 123select * from courseright outer join teacheron course.teacher_id = teacher.teacher_id; 输出： 123456789+-----------+-----------------------------+------------+------------+--------------+| course_id | course_name | teacher_id | teacher_id | teacher_name |+-----------+-----------------------------+------------+------------+--------------+| 2 | 高级算法分析与设计 | 1 | 1 | 刘娟 || 1 | 商务智能 | 2 | 2 | 朱卫平 || 4 | 模式识别 | 2 | 2 | 朱卫平 || 3 | 程序设计方法学 | 3 | 3 | 刘婧 || NULL | NULL | NULL | 4 | 李春葆 |+-----------+-----------------------------+------------+------------+--------------+ full join全外连接(full outer join或full join)：返回左表和右表中的所有行。若某一张表中的行在另一张表中没有匹配的行，对应列填充NULL。 123select * from coursefull outer join teacheron course.teacher_id = teacher.teacher_id; 注意：MySQL不支持full outer join，可以使用左连接和右连接的并来实现。 1234567select * from courseleft join teacheron course.teacher_id = teacher.teacher_idunion select * from courseright join teacheron course.teacher_id = teacher.teacher_id; 输出： 123456789+-----------+-----------------------------+------------+------------+--------------+| course_id | course_name | teacher_id | teacher_id | teacher_name |+-----------+-----------------------------+------------+------------+--------------+| 2 | 高级算法分析与设计 | 1 | 1 | 刘娟 || 1 | 商务智能 | 2 | 2 | 朱卫平 || 4 | 模式识别 | 2 | 2 | 朱卫平 || 3 | 程序设计方法学 | 3 | 3 | 刘婧 || NULL | NULL | NULL | 4 | 李春葆 |+-----------+-----------------------------+------------+------------+--------------+]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL中的并运算(union)]]></title>
    <url>%2F2018%2F09%2F12%2Fsql-union%2F</url>
    <content type="text"><![CDATA[union用于合并两个或多个select语句的结果集。 需要注意的是，union合并的两个或多个表必须有相同的列数，且相应的列必须取自同一个域（即数据类型相似，如都是数值型），此外，每条select语句中列的顺序必须相同。 语法123select 列名 from table1union select 列名 from table2 注意：union会去除重复行，如果需要保留重复的行，可使用union all。 示例假设有以下两张雇员表 123456789101112131415161718create table employee_cn( eno int, name varchar(32), primary key(eno));insert into employee_cn values(1,'San Zhang');insert into employee_cn values(2,'Xindong Wu');insert into employee_cn values(3,'Gongshan he');insert into employee_cn values(4,'Jiawei Han');create table employee_us( eno int, name varchar(32), primary key(eno));insert into employee_us values(1,'Jiawei Han');insert into employee_us values(2,'Xindong Wu');insert into employee_us values(3,'Bill Gates');insert into employee_us values(4,'Steve Jobs'); 查询中国和美国的所有雇员的姓名 123select name from employee_cnunionselect name from employee_us; 结果： 12345678910+-------------+| name |+-------------+| San Zhang || Xindong Wu || Gongshan he || Jiawei Han || Bill Gates || Steve Jobs |+-------------+ 可以看到，union无法查询出所有的中国和美国雇员，一旦出现同名的雇员，则只有一个被列出。 下面使用union all。 123select name from employee_cnunion allselect name from employee_us; 结果: 123456789101112+-------------+| name |+-------------+| San Zhang || Xindong Wu || Gongshan he || Jiawei Han || Jiawei Han || Xindong Wu || Bill Gates || Steve Jobs |+-------------+]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL简单总结]]></title>
    <url>%2F2018%2F09%2F08%2Fsql-summary%2F</url>
    <content type="text"><![CDATA[结构化查询语言（structured query language, 简称SQL）分为四类： 数据定义语句（Data Definition Language，简称DDL）、数据查询语句（Data Query Language，简称DQL）、数据更新语句（Data Manipulation Language，简称DML）以及数据控制语句。 DDL 表的创建 1234create table 表名 ( 列名 数据类型 列级完整性约束, ...[,表级完整性约束]); 表的删除 1drop table 表名 [cascade | restrict]; 表的扩充和修改 1.增加新列 1alter table 表名 add (列名 数据类型,...); 2.删除已存在的某个列 1alter table 表名 drop 列名 [cascade | restrict]; 3.修改原有列的类型 1alter table 表名 modify 列名 数据类型; DQL12345select [all | distinct]from 表名或视图名[,表名或视图名...][where 条件表达式][group by 列名1 [having 条件表达式]][order by 列名2 [asc | desc]]; DML 插入数据 1.插入一条数据 1insert into 表名 [(列名,列名,...)] values(常量1[,常量2,...]); 2.插入子查询结果 1insert into 表名 [(列名,列名,...)] 查询语句; 修改数据 123update 表名 set 列名 = 表达式[,列名 = 表达式,...][where 条件]; 删除数据 1delete from 表名 [where 条件];]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇异值分解]]></title>
    <url>%2F2018%2F08%2F28%2Fmatrix-singular-value-decomposition%2F</url>
    <content type="text"><![CDATA[奇异值分解（Singular Value Decomposition，简称SVD），是一种矩阵分解技术，可以用于机器学习中数据集的降维。 预备知识 单位矩阵 主对角元素全为1，其余元素全为0的n阶矩阵，称为单位矩阵，记为$E_{n}$或$I_{n}$，通常用$E$或$I$表示。 自看机器学习以来，看到好多次$I$这个符号，以前一直不知道是啥意思，原来就是本科线性代数里单位矩阵$E$的另一种表示符号。 正交矩阵 如果n阶实矩阵满足$$A^{T}A = AA^{T} = I$$则称$A$为正定矩阵。 正规矩阵 设$A \in C^{\ m \times n}​$，如果$$A^{H}A = AA^{H}$$则称$A$ 为正规矩阵。 酉矩阵 如果n阶复矩阵$A​$满足$$A^{H}A = AA^{H} = I$$则称$A$为酉矩阵。 奇异值分解设$A \in C^{\ m \times n}$，如果存在非负实数$\sigma$和非零向量$u \in C^{n}，v \in C^{m}$使得$$Au = \sigma v，A^{H}v = \sigma u$$则称$\sigma$为$A$的奇异值，$u$和$v$分别称为$A$对应于奇异值$\sigma$的右奇异向量和左奇异向量。$$A^{H}Au = \sigma A^{H} v = \sigma^{2} u$$ $$A A^{H} v = \sigma A u = \sigma^{2}v$$ 因此，$\sigma^{2}$是$A^{H} A$的特征值，也是$A A^{H}$的特征值，而$u$和$v$分别是$A^{H}A$和$A A^{H}$对应于特征值$\sigma^{2}$的特征向量。 设$A \in C^{\ m \times n}$，rank（A）=r，且$A^{H}A$的特征值为$\lambda_{1} \geq \lambda_{2} \geq \dots \geq \lambda_{n}$。$$\lambda_{1} \geq \dots \geq \lambda_{r} &gt; \lambda_{r+1} = \dots = \lambda_{n} = 0$$记$k = \min\{m,n\}$，也称$\sigma_{i} = \sqrt{\lambda_{i}} （i=1,\dots,k）$为$A$的奇异值，特别地，称$\sigma_{1}，\dots，\sigma_{r}$为$A$的正奇异值。 定理：若$A$是正规矩阵，则$A$的奇异值是$A$的特征值的模。 定理：设$A$是$m \times n$矩阵，且rank（A）= r，则存在m阶酉矩阵$V$和n阶酉矩阵$U$，使得$$V^{H}AU =\begin{bmatrix}\Sigma &amp; 0 \\0 &amp; 0\end{bmatrix}$$其中，$\Sigma = diag（\sigma_{1}，\dots，\sigma_{r}）$，且$\sigma_{1} \geq \dots \geq \sigma_{r} &gt; 0$。 $U$的列向量是$A^{H}A$的标准正交特征向量，$U$的前 r 列向量是$A^{H}A$对应于r个非零特征值$\sigma_{1}^{2},\dots,\sigma_{r}^{2}$的标准正交特征向量；而$V$的列向量是$AA^{H}$的标准正交特征向量，前 r 列向量恰是$AA^{H}$对应于特征值$\sigma_{1}^{2},\dots,\sigma_{r}^{2}$的标准正交特征向量。 例题 设$$A =\begin{bmatrix}0 &amp; 1 \\-1 &amp; 0 \\0 &amp; 2 \\1 &amp; 0 \\\end{bmatrix}$$作出矩阵$A$的奇异值分解。 解：$$A^{H}A =\begin{bmatrix}2 &amp; 0 \\0 &amp; 5\end{bmatrix},AA^{H} =\begin{bmatrix}1 &amp; 0 &amp; 2 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; -1 \\2 &amp; 0 &amp; 4 &amp; 0 \\0 &amp; -1 &amp; 0 &amp; 1\end{bmatrix},$$则$A$的非零奇异值为$\sqrt{2}，\sqrt{5}$ . $A^{H} A $对应于特征值5和2的标准正交特征向量为$$u_1 =\begin{pmatrix}0 \\ 1\end{pmatrix}，u_2 =\begin{pmatrix}1 \\ 0\end{pmatrix}$$$AA^{H}$对应于特征值5和2的标准正交特征向量为$$v_1 =\begin{bmatrix}\frac{1}{\sqrt{5}} \\ 0 \\ \frac{2}{\sqrt{5}} \\ 0\end{bmatrix},v_2 =\begin{bmatrix}0 \\ -\frac{1}{\sqrt{2}} \\ 0 \\ \frac{1}{\sqrt{2}}\end{bmatrix}$$$AA^{H}$对应于特征值0的标准正交特征向量为$$v_3 =\begin{bmatrix}-\frac{2}{\sqrt{5}} \\ 0 \\ \frac{1}{\sqrt{5}} \\ 0\end{bmatrix},v_4 =\begin{bmatrix}0 \\ \frac{1}{\sqrt{2}} \\ 0 \\ \frac{1}{\sqrt{2}}\end{bmatrix}$$因此，$A$的奇异值分解为$$A =\begin{bmatrix}0 &amp; 1 \\-1 &amp; 0 \\0 &amp; 2 \\1 &amp; 0 \\\end{bmatrix}=\begin{bmatrix}\frac{1}{\sqrt{5}} &amp; 0 &amp; -\frac{2}{\sqrt{5}} &amp; 0\\0 &amp; -\frac{1}{\sqrt{2}} &amp; 0 &amp; \frac{1}{\sqrt{2}}\\\frac{2}{\sqrt{5}} &amp; 0 &amp; \frac{1}{\sqrt{5}} &amp; 0\\0 &amp; \frac{1}{\sqrt{2}} &amp; 0 &amp; \frac{1}{\sqrt{2}}\end{bmatrix}\begin{bmatrix}\sqrt{5} &amp; 0 \\0 &amp; \sqrt{2} \\0 &amp; 0 \\0 &amp; 0\end{bmatrix}\begin{pmatrix}0 &amp; 1 \\1 &amp; 0\end{pmatrix}^{H}$$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>矩阵论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向量和矩阵的范数]]></title>
    <url>%2F2018%2F08%2F27%2Fvector-and-matrix-norm%2F</url>
    <content type="text"><![CDATA[阅读《机器学习》和《机器学习实战》的时候，都碰到过范数（norm）这个概念，这里记录一下。 向量范数 定义 设V是数域P上的线性空间，$\lVert \alpha \rVert$是以V中的向量$\alpha$为自变量的非负实值函数，如果它满足以下三个条件： （1）非负性：当$\alpha \neq 0$时，$\lVert \alpha \rVert &gt; 0$；当$\alpha = 0$时，$\lVert \alpha \rVert = 0$； （2）齐次性：对任意$k \in P，\alpha \in V$，有$\lVert k \alpha \rVert = \lvert k \rvert\ \lVert\alpha \rVert $； （3）三角不等式：对任意$\alpha，\beta \in V$，有$\lVert \alpha + \beta \rVert \leq \lVert \alpha \rVert + \lVert \beta \rVert$， 则称$\lVert \alpha \rVert$ 为向量$\alpha$的范数，并称定义了范数的线性空间为赋范线性空间。 什么是数域？ 设P是包含0和1在内的数集，如果P中任意两个数的和、差、积、商（除数不为0）仍是P中的数，则称P为一个数域。 常见的向量范数 在n维向量空间$C^n$中，对任意的向量$x = (x_1,x_2,\dots,x_n)^{T} \in C^{n} $,有$$\lVert x \rVert_{1} = \sum_{i=1}^{n} \lvert x_{i} \rvert \tag{1}$$ $$\lVert x \rVert_{2} = (\sum_{i=1}^{n} \lvert x_{i} \rvert^{2})^{\frac{1}{2}} \tag{2}$$ $$\lVert x \rVert_{\infty} = \max_{1 \leq i \leq n} \lvert x_{i} \rvert \tag{3}$$ 其中，$\lVert x \rVert_{1}、\lVert x \rVert_{2}、\lVert x \rVert_{\infty}$分别称为1范数，2范数（Euclid范数或欧式范数）和$\infty$范数。 对$1\leq p &lt; +\infty$，在$C^{n}$上定义$$\lVert x \rVert_{p} = (\sum_{i=1}^{n} \lvert x_{i} \rvert^{p})^{\frac{1}{p}}，1 \leq p &lt; +\infty \tag{4}$$$\lVert x \rVert_{p}$称为p范数。若未标明p，则默认为2范数。 矩阵范数 定义 设$\lVert \mathbf{A} \rVert$是以$C^{m \times n}$中的矩阵$\mathbf{A}$为自变量的非负实值函数，如果它满足以下三个条件： （1）非负性：当$\mathbf{A} \neq 0$时，$\lVert \mathbf{A} \rVert&gt; 0$；当$\mathbf{A}= 0$时，$\lVert \mathbf{A} \rVert = 0$； （2）齐次性：对任意$k \in C，\mathbf{A} \in C^{m \times n}$，有$\lVert k \mathbf{A} \rVert = \lvert k \rvert\ \lVert A \rVert $； （3）三角不等式：对任意$\mathbf{A}，\mathbf{B} \in C^{m \times n}$，有$\lVert \mathbf{A} + \mathbf{B} \rVert \leq \lVert \mathbf{A} \rVert + \lVert \mathbf{B} \rVert$， 则称$\lVert \mathbf{A} \rVert$ 为$m \times n$矩阵$\mathbf{A}$的范数。 常见的矩阵范数 对于$\mathbf{A} = (a_{ij}) \in \mathbf{C}^{m \times n}$，令$$\lVert \mathbf{A} \rVert_{1} \equiv \sum_{i=1}^{m}\sum_{j=1}^{n}\ \lvert a_{ij} \rvert \tag{5}$$ $$\lVert \mathbf{A} \rVert_{\infty} \equiv \max_{i,\ j}\ \lvert a_{ij} \rvert \tag{6}$$ $$\lVert \mathbf{A} \rVert_{F} \equiv (\sum_{i=1}^{m}\sum_{j=1}^{n}\ \lvert a_{ij} \rvert^{2})^{\frac{1}{2}}= (tr({\mathbf{A}^{H}\mathbf{A}}))^{\frac{1}{2}} \tag{7}$$ 其中，$\lVert \mathbf{A} \rVert_{F}$称为$\mathbf{A}$的Frobenius范数，$A^{H}$是$A$的共轭转置矩阵。 补充知识1.复矩阵：元素中含有复数的矩阵。 2.共轭矩阵： 当$A=(a_{ij})$为复矩阵时，用 $ \overline{a} $ 表示 $a $的共轭复数，记 $\overline{A} = (\overline{a_{ji}})$，则$\overline{A}$为A的共轭矩阵。 例如，$$A =\begin{vmatrix}3+i &amp; 5\\2-2i &amp; i\end{vmatrix}$$其共轭矩阵$\overline{A}$为$$\overline{A} =\begin{vmatrix}3-i &amp; 5 \\2+2i &amp; -i\end{vmatrix}$$3.共轭转置矩阵 当$A=(a_{ij})$为复矩阵时，用 $ \overline{a} $ 表示 $a $的共轭复数，记 $\overline{A} = (\overline{a_{ji}})$，则$（\overline{A}）^{T} = \overline{A^{T}}$为A的共轭转置矩阵。 还是用上面的例子，$$(\overline{A})^{T} =\begin{vmatrix}3-i &amp; 5 \\2+2i &amp; -i\end{vmatrix}^{T} =\begin{vmatrix}3-i &amp; 2+2i \\5 &amp; -i\end{vmatrix}$$ 4.Hermite矩阵 n阶复方阵A的对称元素互为共轭，即A的共轭转置矩阵等于它本身，则A是Hermite矩阵。 例如，$$B =\begin{vmatrix}3 &amp; 2+i \\2-i &amp; 2\end{vmatrix}$$B的共轭转置矩阵如下$$\overline{B}^{T} =\begin{vmatrix}3 &amp; 2-i \\2+i &amp; 2\end{vmatrix}^{T}=\begin{vmatrix}3 &amp; 2+i \\2-i &amp; 2\end{vmatrix} = B$$故，B是一个Hermite矩阵。 参考资料 戴华，矩阵论，科学出版社]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之PCA算法]]></title>
    <url>%2F2018%2F08%2F26%2Fmachine-learning-pca%2F</url>
    <content type="text"><![CDATA[主成分分析（Principal Component Analysis，简称PCA）。 $$\begin{align}\hline&amp; PCA算法 \\\hline&amp; 输入：样本集D=\{x_1,x_2,\dots,x_m\};低维空间维数d^{‘} \\&amp; 过程： \\&amp; 1. 对所有样本进行中心化：x_i \leftarrow x_i - \frac{1}{m} \sum_{i=1}^{m} x_i;\\&amp; 2.计算样本的协方差矩阵XX^{T}; \\&amp; 3.对协方差矩阵XX^{T}做特征值分解; \\&amp; 4.取最大的d^{‘}个特征值所对应的特征向量w_1,w_2,\dots,w_{d^{‘}}. \\&amp; 输出：投影矩阵W=(w_1,w_2,\dots,w_{d^{‘}})\end{align}$$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>降维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之PageRank算法]]></title>
    <url>%2F2018%2F08%2F25%2Fmachine-learning-pagerank%2F</url>
    <content type="text"><![CDATA[PageRank是一个搜索排名算法，由Sergey Brin和Larry Page在1998年第七届国际万维网大会上提出的。基于这一算法，他们创建了Google搜索引擎。 在介绍PageRank之前，先来了解一些主要概念。 页面i的入链（In-links of page i）：从其他网页链接到网页$i$的超链接数，通常不包括来自同一站点内网页的链接。 网页i的出链（Out-links of page i）：从网页$i$链接到其他网页的超链接数，通常不包括链接到同一站点内网页的超链接。 算法根据社交网络的排序声望原理，页面$i$的重要程度（页面$i$的PageRank分数），由所有指向页面i的所有页面的PageRank分数之和决定。因为一个页面可能指向很多其他的页面，它的声望分数应该被所有它指向的页面所共享。 将网络看做一个有向图G = (V , E)，其中V是所有顶点或结点的集合，例如，所有网页的集合，E是图中有向边的集合，例如，超链接。 设网络中的网页总数为n，网页i的PageRank分数为P(i)，$$P(i) = \sum_{(j,i) \in E} \frac{P(j)}{O_{j}} \tag{1}$$其中，$O_{j}$是网页$j$的出链数。 设P是一个由PageRank值组成的n维列向量（n-dimensional column vector）。$$P = (P(1),P(2),\dots,P(n))^{T} \tag{2}$$设A是图的邻接矩阵（adjacency matrix），$$A_{ij} =\begin{cases}\frac{1}{O_{j}},&amp; (i,j) \in E \\0, &amp; 其他\end{cases} \tag{3}$$由公式(1)~(3)，可以得到如下n阶方程组$$P = A^{T}P \tag{4}$$显然，P是一个特征值为1的特征向量（eigenvector）。 如果满足以下条件： 1.A是一个随机矩阵；2.A是不可约的；3.A是非周期的。 那么PageRank向量P就是对应矩阵A的最大特征值1的那个主特征向量。 实际上，公式(4)也可基于马尔科夫链（Markov chain）推导出来。 模型修正然而，Web图并不满足以上三个条件。 1.Web图中，A不是一个随机矩阵。 原因 有限马尔科夫链的状态转移矩阵是随机矩阵，它要求每个元素都是非负实数，且每行元素之和为1。这要求每一个网页至少要有一个出链，但实际上，很多网页根本就没有出链，从而导致状态转移矩阵A某些行全为0。这样的网页称为悬挂网页。 解决办法 从每个悬挂网页$i$向其他各个网页添加一条出链，将网页$i$到其他网页的转换概率均设为$\frac{1}{n}$。也就是说，将A中全为0的行用$\frac{\mathbf{ e}}{n}$（$\mathbf{e}$是元素全为1的n维向量）来替换。 2.Web图在一般情况下是可约的。 原因：Web图G不是强连通的。通常存在一些节点对&lt;u, v&gt;，没有从u到v的路径。 强连通图：若图G中的任意两个顶点$i$和$j$都连通，即从顶点$i$到顶点$j$和从顶点$j$到顶点$i$都存在路径，则图G是强连通图。 解决办法：同问题三 3.”A是非周期的”，并不一定成立。 周期图：状态$i$是周期的，并且具有周期$k&gt;1$，是指存在一个最小的正整数$k$，使得所有从状态$i$出发又回到状态$i$的路径长度都是$k$的整数倍。 如果一个状态不是周期的（或者$k=1$），那么它就是非周期的。如果一个马尔科夫链的所有状态都是非周期的，那么就说这个马尔科夫链是非周期的。 解决办法 从任一页面出发，到每个页面都加上一条链接，并给这一链接分配一个由参数$d$控制的微小转换概率。 通过以上修正，状态转换矩阵A满足之前的三个条件，从而得到了一个改进后的PageRank模型：$$P = \left[(1-d) \frac{E}{n} + d A^{T}\right]P \tag{5}$$其中，$E=ee^{T}$（e是元素全为1的列向量，从而E是一个nxn的元素全为1的矩阵），n是Web图中的节点总数。 公式（5）化简后，得到$$P = (1-d)e + dA^{T}P \tag{6}$$其中，e是全为1的列向量。 从而，可以得到$$P(i) = (1-d) + d \sum_{j=1}^{n} A_{ji} P(j) \tag{7}$$上式等价于$$P(i) = (1-d) + d \sum_{(j,i) \in E} \frac{P(j)}{O_{j}} \tag{8}$$其中，$d$称之为阻尼系数（damping factor），且$0 \leq d \leq 1$。一些论文中认为，$d = 0.85$是一个不错的选择。 可以使用幂迭代（power iteration）求解特征向量P，算法如下$$\begin{align}&amp; PageRank-Iterate(G) \\&amp; \quad P_{0} \leftarrow \frac{e}{n} \\&amp; \quad k \leftarrow 1 \\&amp; \quad repeat \\&amp; \qquad P_{k} \leftarrow (1-d)e+dA^{T}P_{k-1}; \\&amp; \qquad k \leftarrow k+1; \\&amp; \quad until\ \Vert P_{k} - P_{k-1} \Vert_{1} &lt; \epsilon \\&amp; \quad return\ P_{k}\end{align}$$ 参考资料 Xindong Wu，Top 10 algorithms in data mining，Knowledge and Information Systems，2008 （美）吴信东，库玛尔编著；李文波，吴素研译.数据挖掘十大算法，清华大学出版社，2013.5]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>链接挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之Apriori算法]]></title>
    <url>%2F2018%2F08%2F23%2Fmachine-learning-apriori%2F</url>
    <content type="text"><![CDATA[支持度(support)：数据集中包含该项集的记录所占的比例。 可信度或置信度（confidence）： $A \rightarrow B$的置信度为$$confidence（A\rightarrow B） = \frac{support(A , B)}{support(A)}$$Apriori原理：如果一个项集是非频繁的，那么它的所有超集也是非频繁的。 If an itemset is not frequent, any of its superset is never frequent. Apriori算法 1.从大小为k的频繁项集中生成大小为k+1的候选频繁项集$C_{k+1}$ 2.扫描数据库，计算每一个候选频繁项集的支持度 3.将满足最小支持度的频繁项集加到$F_{k+1}$中$$\begin{align}\hline&amp; 算法\ Apriori \\\hline \\&amp; F_1 = (大小为1的频繁项集); \\&amp; for(k = 1; F_k \neq \varnothing; k++)\ do\ begin \\&amp; \qquad C_{k+1} = apriori-gen(F_k);//新的候选频繁集 \\&amp; \qquad for\ 所有的交易记录t \in 数据集\ do\ begin \\&amp; \qquad \qquad C_{t}^{‘}= subset(C_{k+1},t);\ //包含在t中的候选集 \\&amp; \qquad \qquad for\ 所有的候选c \in C_{t}^{‘}\ do \\&amp; \qquad \qquad \qquad c.count ++; \\&amp; \qquad \qquad end \\&amp; \qquad \qquad F_{k+1} = \{C \in C_{k+1} |\ c.count \geq 最小的支持度 \} \\&amp; \qquad end \\&amp; end \\&amp; Answer \cup_{k} F_k;\end{align}$$算法第三行中的apriori-gen函数经过下面两步，从$F_k$生成$C_{k+1}$ 1.连接 通过合并两个大小为k，且前$k-1$项相同的频繁项集$P_k$和$Q_k$，生成大小为k+1的频繁项集$R_{k+1}$$$\begin{align}&amp; R_{k+1} = P_{k} \cup Q_{k} = \{items_{1},\dots ,items_{k-1},items_{k},items_{k^{‘}}\} \\&amp; P_{k} = \{items_{1},\dots ,items_{k-1},items_{k}\} \\&amp; Q_{k} = \{items_{1},\dots ,items_{k-1},items_{k^{‘}}\}\end{align}$$其中，$items_1 &lt; \dots &lt; items_k &lt; items_{k^{‘}}$ 2.剪枝 检查$R_{k+1}$中的所有大小为的项集中的所有大小为的项集是不是频繁的，删除中的所有大小为的项集中的所有大小为k的项集是不是频繁的，删除$R_{k+1}$中那些非频繁的项集，从而得到中那些非频繁的项集，从而得到$C_{k+1}$。因为$C_{k+1}$中大小为且非频繁的所有子集不是大小为中大小为k且非频繁的所有子集不是大小为k+1的频繁项集的子集。 示例： 假设最小支持度为2 数据库D TID Items 100 $1 \quad 3 \quad 4$ 200 $2 \quad 3 \quad 5$ 300 $1 \quad 2 \quad 3 \quad 5$ 400 $2 \quad 5$ $C_1$ {1} 2 {2} 3 {3} 3 {4} 1 {5} 3 $F_1$ 项集 支持度 {1} 2 {2} 3 {3} 3 {5} 3 $C_2$ 项集 支持度 { 1, 2 } 1 { 1, 3 } 2 { 1, 5 } 1 { 2, 3 } 2 { 2, 5 } 3 { 3, 5 } 2 $F_2$ 项集 支持度 { 1, 3 } 2 { 2, 3 } 2 { 2, 5 } 3 { 3, 5 } 2 $C_3$ 项集 支持度 { 1 , 2 , 3 } 1 { 1 , 2 , 5 } 1 { 1 , 3 , 5 } 1 { 2 , 3 , 5 } 2 $F_3$ 项集 支持度 { 2 , 3 , 5 } 2]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>关联分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的初始化块]]></title>
    <url>%2F2018%2F08%2F23%2Fjava-initialization-block%2F</url>
    <content type="text"><![CDATA[Java中的初始化代码块用一对花括号{}标明，初始化代码块在构造方法之前执行。 一个简单的例子： 12345678910111213public class Main &#123; public static void main(String[] args) &#123; Test test = new Test(); &#125;&#125;class Test &#123; &#123; System.out.println("Hello 初始化代码块"); &#125; public Test() &#123; System.out.println("执行构造方法"); &#125;&#125; 输出结果： 12Hello 初始化代码块执行构造方法 另外，Java中还有一个静态初始化代码块，用static{}来标明。静态初始化代码块在普通代码块之前被调用。 示例： 12345678910111213141516public class Main &#123; public static void main(String[] args) &#123; Test test = new Test(); &#125;&#125;class Test &#123; static&#123; System.out.println("执行静态代码块"); &#125; &#123; System.out.println("执行普通代码块"); &#125; public Test() &#123; System.out.println("执行构造方法"); &#125;&#125; 输出结果： 123执行静态代码块执行普通代码块执行构造方法 总的来说，执行顺序：静态初始化代码块&gt;普通初始化代码块&gt;构造方法]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的Object类]]></title>
    <url>%2F2018%2F08%2F22%2Fjava-object%2F</url>
    <content type="text"><![CDATA[java.lang.Object是Java中所有类的父类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Object &#123; private static native void registerNatives(); static &#123; registerNatives(); &#125; public final native Class&lt;?&gt; getClass(); public native int hashCode(); public boolean equals(Object obj) &#123; return (this == obj); &#125; protected native Object clone() throws CloneNotSupportedException; public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125; public final native void notify(); public final native void notifyAll(); public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout); &#125; public final void wait() throws InterruptedException &#123; wait(0); &#125; protected void finalize() throws Throwable &#123; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的枚举类型]]></title>
    <url>%2F2018%2F08%2F20%2Fjava-enum%2F</url>
    <content type="text"><![CDATA[枚举类的主要作用是便捷地定义静态常量，替代public static final xxx。 所有的枚举类型都是java.lang.Enum类的子类，java.lang.Enum的类结构如下： 12public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable 方法列表： 1234public final String name();public String toString();public static Enum valueOf(Class enumClass,String name);public final int ordinal(); 枚举类型的一个简单的例子： 123enum Week &#123; MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;&#125; 事实上，上面定义了一个类，它只有七个实例，这些实例只能在其他代码之前定义，并以封号结束。 如果需要的话，可以在枚举类型中添加一些构造器、方法和域。不过，枚举类型只能包含私有构造，且构造器只在构造枚举常量的时候被调用。 12345678910111213enum Week &#123; //只能在其他代码之前定义 MONDAY(1),TUESDAY(2),WEDNESDAY(3), THURSDAY(4),FRIDAY(5),SATURDAY(6),SUNDAY(7); private int day; //只在构造枚举常量的时候被调用 private Week(int day) &#123; this.day = day; &#125; public int getDay() &#123; return day; &#125;&#125; name()方法描述：返回枚举常量名。 12345678enum Week &#123; MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;&#125;public class Main &#123; public static void main(String[] args) &#123; System.out.println(Week.MONDAY.name()); &#125;&#125; 输出结果： 1MONDAY toString()方法描述：返回枚举常量名。 12345678enum Week &#123; MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;&#125;public class Main &#123; public static void main(String[] args) &#123; System.out.println(Week.MONDAY.toString()); &#125;&#125; 输出结果： 1MONDAY 通过查看源码，可以看到，toString()方法返回的是name属性。 123public String toString() &#123; return name;&#125; valueOf()1public static Enum valueOf(Class enumClass,String name); 方法描述：返回指定名字、给定类的枚举常量 123456789enum Week &#123; MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;&#125;public class Main &#123; public static void main(String[] args) &#123; Week week = Enum.valueOf(Week.class,"FRIDAY"); System.out.println(week); &#125;&#125; 输出结果： 1FRIDAY ordinal()方法描述：返回枚举常量在enum中声明的位置，位置从0开始计数。 12345678enum Week &#123; MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY,SUNDAY;&#125;public class Main &#123; public static void main(String[] args) &#123; System.out.println(Week.THURSDAY.ordinal()); &#125;&#125; 输出结果： 13 正如这个方法注释中描述的那样， 123Most programmers will have no use for this method. It is designed for use by sophisticated enum-based data structures,such as java.util.EnumSet and java.util.EnumMap. 大多数程序员用不到这个方法，它是为EnumSet和EnumMap这些基于枚举的复杂数据结构设计的。 values()每个枚举类都有一个静态方法values()，它返回一个包含全部枚举值的数组。 示例： 123456789101112131415161718192021enum Week &#123; MONDAY(1),TUESDAY(2),WEDNESDAY(3), THURSDAY(4),FRIDAY(5),SATURDAY(6),SUNDAY(7); private int day; private Week(int day) &#123; this.day = day; &#125; public int getDay() &#123; return day; &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; Week[] weeks = Week.values(); StringBuilder sb = new StringBuilder(); for(Week week : weeks) &#123; sb.append(week.getDay()+" "); &#125; System.out.println(sb); &#125;&#125; 输出结果： 11 2 3 4 5 6 7 equals()和==在比较两个枚举类型的值时，不需要调用equals，可以直接使用“==”。 查看源码，可以知道，Enum类的equals也是直接使用的”==”来比较。 123public final boolean equals(Object other) &#123; return this==other;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之局部加权线性回归]]></title>
    <url>%2F2018%2F08%2F17%2Fmachine-learning-locally-weighted-linear-regression%2F</url>
    <content type="text"><![CDATA[局部加权线性回归（Locally Weighted Linear Regression，LWLR）。 在该算法中，给预测点附近的每个点赋予一定的权重，在这个子集上基于最小均方差来进行普通的回归。 局部加权线性回归的均值误差可用下式表示$$\sum_{i=1}^{m} w_i (y_i - x_i^{T} \theta_i)^2$$其中，$w_i$是权重，$y_i$是真实值，$x_i$是输入值，$\theta_i$为对应的回归系数。 回归系数$w$为$$\hat w = (X^{T} W X )^{-1} X^{T} W y$$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之线性回归]]></title>
    <url>%2F2018%2F08%2F17%2Fmachine-learning-linear-regression%2F</url>
    <content type="text"><![CDATA[线性回归（linear regression），就是将输入项分别乘以一些常量，再将结果加起来得到预测值，而这些常量称之为回归系数。 线性回归可以用如下的等式来表示：$$Y = X^{T} w$$其中，$Y$为预测值，$X$为输入值，$w$是一个包含回归系数的向量 已知$X$和对应的$Y$，怎么才能找到$w$呢？一个常用的方法就是找出使误差最小的$w$。这里的误差是指预测Y值和真实Y值之间的差值，使用该误差的简单累加将使得正差值和负差值相互抵消，为了避免这种情况，可以使用平方误差。 平方误差可写为：$$\sum_{i=1}^{m} (y_i - x_i ^{T} w) ^2$$若用矩阵表示，则可写为：$$(Y - X w)^{T} (Y - Xw)$$令$$\begin{align}f(w) &amp;= (Y - X w)^{T} (Y - Xw) \\&amp;= Y^{T} Y - Y^{T} X w - w^{T} X^{T} Y + w^{T} X^{T} X w \\\end{align}$$f(w) 对$w$求导，得到$$\begin{align}\frac{\partial f(w)}{\partial w} &amp;= \frac{\partial (Y^{T} Y)} {\partial w} - \frac{\partial ( Y^{T} X w)} {\partial w} - \frac{\partial (w^{T} X^{T} Y)} {\partial w} + \frac{\partial (w^{T} X^{T} X w )} {\partial w} \\&amp;= 0 - X^{T} Y - X^{T} Y + 2 X^{T} X w \\&amp;= 2 X^{T} (Xw - Y)\end{align}$$令$\frac{\partial f(w)}{\partial w} = 0$，则$$X^{T} (X w - Y) = 0 \\=&gt; X^{T} X w = X^{T} Y \\$$两边左乘$(X^{T}X)^{-1}$，得$$\hat w = (X^{T} X )^{-1} X^{T} Y$$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵求导]]></title>
    <url>%2F2018%2F08%2F17%2Fmatrix-derivative%2F</url>
    <content type="text"><![CDATA[最近在学习机器学习的时候，经常会碰到矩阵求导，这里记录下矩阵的求导操作。 向量和矩阵的导数满足乘法法则（product rule）$$\frac {\partial x^{T} \alpha}{ \partial x } = \frac {\partial \alpha^{T} x }{ \partial x } = \alpha$$ $$\frac {\partial AB} {\alpha x} = \frac{\partial A} {\partial x} B + A \frac{\partial B} {\partial x}$$ 由于$A^{-1} A = I$和上式，逆矩阵的导数可表示为$$\frac {\partial A^{-1} } {\partial x} = - A^{-1} \frac {\partial A} {\partial x} A^{-1}$$证明：$$\begin{align}\frac{\partial I} {\partial x} &amp;= \frac{\partial A^{-1} A} {\partial x} \\&amp;= \frac{\partial A} {\partial x} A^{-1} + A \frac{\partial A^{-1} } {\partial x} \\&amp;= 0\end{align}$$从而，$$\begin{align}&amp;=&gt; -A \frac{\partial A^{-1} } {\partial x} = \frac{\partial A} {\partial x} A^{-1} \\&amp;=&gt; \frac{\partial A^{-1}} {\partial x} = -A^{-1} \frac{\partial A } {\partial x} A^{-1}\end{align}$$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux中存活下来之ssh和scp命令]]></title>
    <url>%2F2018%2F08%2F17%2Flinux-command-ssh-and-scp%2F</url>
    <content type="text"><![CDATA[前面我们讲了如何在Windows系统中登录Linux服务器，以及实现windows和Linux之间的文件传输操作。今天我们来讲下在Linux系统（如ubuntu）中如何登录Linux服务器及实现文件传输。 Linux中使用ssh命令登录其他的Linux，使用scp命令实现文件传输。 sshssh，全称Secure Shell，是一种用于远程登录的协议。 语法： 1ssh 用户名@IP地址 示例： 这里以root用户和 IP 地址118.190.95.35（从网上随便找的一个IP）为例 1ssh root@118.190.95.35 scpscp，全称secure copy，用于Linux之间复制文件和目录。 语法： 1scp [options] 源文件路径 目标路径 参数: -r：递归复制目录下的所有文件，包括目录本身 示例： 从本地上传文件到服务器 将本地的/home/hegongshan/Desktop/robots.txt文件上传到服务器118.190.95.35的/usr/local/tomcat/目录下 1scp /home/hegongshan/Desktop/xxx.txt root@118.190.95.35:/usr/local/tomcat/ 从服务器下载文件 从118.190.95.35将/usr/local/tomcat/webapps/ROOT.war下载到本机的/home/hegongshan/Desktop/目录下 1scp root@118.190.95.35:/usr/local/tomcat/webapps/ROOT.war /home/hegongshan/Desktop/ 从服务器复制目录（文件夹） 从118.190.95.35将/usr/local/tomcat/webapps/ROOT复制到本机的/home/hegongshan/Desktop/目录下 1scp -r root@118.190.95.35:/usr/local/tomcat/webapps/ROOT /home/hegongshan/Desktop/ 结果将是在/home/hegongshan/Desktop/下有一个ROOT文件夹。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用PuTTY实现Windows和Linux的文件传输]]></title>
    <url>%2F2018%2F08%2F17%2Fputty-file-upload-and-download%2F</url>
    <content type="text"><![CDATA[安装完PuTTY以后，进入命令行界面，就可以使用PuTTY的pscp命令进行文件传输。 pscp语法： 1pscp 源文件路径 目标文件路径 示例： 1pscp root@111.199.227.74:/mnt/files/abc.txt D:/file/ 值得一提的是，pscp命令只能用于文件的上传下载，若要进行文件夹（目录）的上传下载，可以先压缩，然后再使用pscp命令进行文件传输。 若命令行中显示找不到pscp命令，只需将PuTTY的安装路径添加到系统变量Path中即可。]]></content>
      <categories>
        <category>putty</category>
      </categories>
      <tags>
        <tag>putty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用PuTTY远程登录Linux服务器]]></title>
    <url>%2F2018%2F08%2F16%2Fputty-ssh%2F</url>
    <content type="text"><![CDATA[使用PuTTY已经很长时间了，是时候总结下PuTTY的用法了。 什么是PuTTY? 下面是PuTTY官网的介绍 PuTTY is an SSH and telnet client, developed originally by Simon Tatham for the Windows platform. 翻译过来就是说，PuTTY是Windows平台下的一个SSH客户端。 为什么要使用PuTTY？ 与商用的XShell相比，PuTTY是开源免费的&gt;_&lt;。 安装PuTTY从PuTTY官网下载合适的版本，目前的最新稳定版本是0.70。 成功安装后目录结构如下，我的安装路径为G:\putty 远程登录双击putty.exe，将会显示如下界面 在Host Name(or IP address)，也就是下图中红框标明的地方，输入远程Linux服务器的IP地址 然后点击Open按钮，将会显示如下界面。 在login as：后输入用户名 按照要求输入密码即可登录，值得一提的是，密码是不会显示的，这也很符合Linux设计的哲学。 小经验刚才那样的登录，每次都需要输入服务器IP地址，实际上，PuTTY提供了保存IP地址，下次自动导入的功能。 第一次登录时，输入IP地址，在Saved Sessions下的输入框中输入想保存的名字，然后点击Save按钮（图中用红框标明）。 这里以127.0.0.1为例，设置session的名字为server，点击Save按钮，Default Settings下出现了一个server 下一次登录时，只需要选择server，然后点击Load按钮，IP地址将会被自动导入。 如果不想再保存该IP地址了，则选中session的名字，然后点击Delete按钮即可删除存储的session。]]></content>
      <categories>
        <category>putty</category>
      </categories>
      <tags>
        <tag>putty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的定时器Timer]]></title>
    <url>%2F2018%2F08%2F02%2Fjava-timer%2F</url>
    <content type="text"><![CDATA[在Java中，定时任务功能使用的是Timer类，其主要作用是设置计划任务， 最近课题组的项目用到了Java中的定时器Timer类，这里记录下定时器Timer的相关知识。 Timer的构造方法如下： 1234567public Timer() public Timer(boolean isDaemon) public Timer(String name) public Timer(String name, boolean isDaemon) 方法列表如下： 123456789101112131415public void schedule(TimerTask task, long delay) public void schedule(TimerTask task, Date time) public void schedule(TimerTask task, long delay, long period) public void schedule(TimerTask task, Date firstTime, long period) public void scheduleAtFixedRate(TimerTask task, long delay, long period)public void scheduleAtFixedRate(TimerTask task, Date firstTime,long period)public void cancel()public int purge() 但封装任务的类却是TimerTask类，类结构如下： 1public abstract class TimerTask implements Runnable schedule(TimerTask task, Date time)执行任务的时间晚于当前时间，即任务在未来执行 12345678910111213141516171819202122232425import java.text.ParseException;import java.text.SimpleDateFormat;import java.time.Instant;import java.util.Date;import java.util.Timer;import java.util.TimerTask;public class TimerDemo &#123; private static Timer timer = new Timer(); static class Task extends TimerTask &#123; @Override public void run() &#123; System.out.println("成功执行！时间："+Date.from(Instant.now())); &#125; &#125; public static void main(String[] args) throws ParseException &#123; String taskTime = "2018-08-06 20:03:30"; System.out.println("计划执行任务时间：" + taskTime); Task task = new Task(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); System.out.println("当前时间：" + sdf.format(Date.from(Instant.now()))); timer.schedule(task, sdf.parse(taskTime)); &#125;&#125; 输出结果： 可以看到，任务虽然执行完了，但进程并未销毁。这是为什么呢？ 我们先来看下Timer的无参构造， 123public Timer() &#123; this("Timer-" + serialNumber());&#125; 其内部调用的是如下构造方法 1234public Timer(String name) &#123; thread.setName(name); thread.start();&#125; 从源代码可以得知，创建一个Timer就是启动一个新线程，这个新启动的线程并不是守护进程，它一直在运行。如果需要Timer执行完任务就结束，可以使用如下构造方法，并将参数isDaemon设置为true 1public Timer(boolean isDaemon) schedule(TimerTask task, long delay, long period)作用：以执行该方法的当前时间作为参考时间，在此基础上延迟指定的毫秒数，再以指定的时间间隔无限次执行某一任务。 cancel()作用：将任务队列中的全部任务清空。 （未完待续）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之AdaBoost]]></title>
    <url>%2F2018%2F08%2F02%2Fmachine-learning-adaboost%2F</url>
    <content type="text"><![CDATA[AdaBoost（adaptive boosting）算法是提升（boosting）方法的一个最流行版本，1995年由Freund和Schapire提出。其基本思想是使用多个弱分类器（即分类器的性能并不好，错误率较高）来构建一个强分类器。 运行过程训练数据集中的每个样本，并赋予其一个权重，这些权重构成了向量D。一开始，这些权重都初始化成相等值。首先在训练数据集上训练出一个弱分类器并计算该分类器的错误率，然后在同一数据集上再次训练弱分类器。在分类器的第二次训练中，将会重新调整每个样本的权重，其中第一次分对的样本的权重将会降低，而第一次分错的样本的权重将会提高。为了从所有弱分类器中得到最终的分类结果，AdaBoost为每个分类器都分配了一个权重值$\alpha$，这些$\alpha$值是基于每个若分类器的错误率进行计算的。 错误率$\epsilon$的定义如下：$$\epsilon = \frac{未正确分类的样本数目}{所有样本数目}$$$\alpha$的计算公式如下：$$\alpha = \frac{1}{2} \ln (\frac{1-\epsilon}{\epsilon})$$计算出$\alpha$值后，需要更新权重向量D，以使得那些正确分类的样本的权重降低而错分样本的权重升高。 D的计算方法如下：$$D_{i} ^{ ( t+1) } =\begin{cases}\frac { D_{i} ^{ (t) } e^{-\alpha} } { sum(D) }, &amp; i分类正确 \\\frac{ D_{i} ^{ (t) } e^{\alpha} }{ sum(D) }, &amp; i分类错误\end{cases}$$在计算出D之后，AdaBoost又开始进入下一轮迭代。AdaBoost算法会不断地重复训练分类器和调整权重的过程，直到训练错误率为0或者弱分类器的数目达到用户的指定值为止。 $\alpha$作为每个分类器分类结果$G_{m}(x)$的权重，对所有分类器的加权分类结果进行累加求和，$$f(x) = \sum_{m=1}^{N} \alpha_{m} G_{m}(x)$$从而得到最终的分类器 $$G(x) = sign(f(x)) = sign( \sum_{m=1}^{N} \alpha_{m} G_{m}(x) )$$ AdaBoost的例子 序号 1 2 3 4 5 6 7 8 9 10 x 0 1 2 3 4 5 6 7 8 9 y 1 1 1 -1 -1 -1 1 1 1 -1 可选的阈值有2.5，5.5和8.5 若阈值为2.5，则7、8、9分类错误，分类错误率为$e = \frac {3}{10}$ 若阈值为5.5， a.$$G(x) =\begin{cases}1, &amp; x &lt; 5.5 \\-1, &amp; x &gt; 5.5\end{cases}$$此时，4、5、６以及7、８、９分类错误，分类误差率为$e = \frac {6}{10}$ b.$$G(x) =\begin{cases}1, &amp; x &gt; 5.5 \\-1, &amp; x &lt; 5.5\end{cases}$$此时，1、2、3和10分类错误，分类误差率为$e = \frac {4} {10}$ 因此，最低误差率为0.4 若阈值为8.5， a.$$G(x) =\begin{cases}1, &amp; x &lt; 8.5 \\-1, &amp; x &gt; 8.5\end{cases}$$此时，4、5、6分类错误，分类误差率为$e = \frac {3} {10}$ 可以看到当阈值为2.5或8.5时，分类误差率最低，因此，我们可任取其中一个阈值，比如2.5。 基本分类器$$G(x) =\begin{cases}1, &amp; x &lt; 2.5 \\-1, &amp; x &gt; 2.5\end{cases}$$ 算法实现我们可以选择任一分类器作为AdaBoost算法的弱分类器，这里选择单层决策树（decision stump）作为弱分类器。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899"""基于单层决策树的AdaBoost分类器"""import numpy as npclass AdaBoost(): def loadDataSet(self,filename): """ 从文件中导入数据集 filename : 文件名 """ dataMat = [] labelMat = [] with open(filename) as file: for line in file.readlines(): numFeature = len(line.split('\t')) lineArr = [] currentLine = line.strip().split("\t") for i in range(numFeature-1): lineArr.append(float(currentLine[i])) dataMat.append(lineArr) labelMat.append(float(currentLine[-1])) return dataMat,labelMat def _stumpClassify(self,dataMatrix,dimension,threshold,thresholdInequality): arr = np.ones((np.shape(dataMatrix)[0],1)) if thresholdInequality == 'lt': arr[dataMatrix[:,dimension] &lt;= threshold] = -1.0 else: arr[dataMatrix[:,dimension] &gt; threshold] = -1.0 return arr def _buildStump(self,dataArr,classLabels,D): dataMatrix = np.mat(dataArr) labelMat = np.mat(classLabels).T m,n = np.shape(dataMatrix) numSteps = 10.0 bestStump = &#123;&#125; bestClassEst = np.mat(np.zeros((m,1))) minError = np.inf # 遍历每一个特征 for i in range(n): rangeMin = dataMatrix[:,i].min() rangeMax = dataMatrix[:,i].max() stepSize = (rangeMax-rangeMin)/numSteps for j in range(-1,int(numSteps)+1): for inequal in ['lt','gt']: threshold = (rangeMin + float(j) * stepSize) predictedVals = self._stumpClassify(dataMatrix,i,threshold,inequal) errArr = np.mat(np.ones((m,1))) errArr[predictedVals == labelMat] = 0 weightedError = D.T * errArr if weightedError &lt; minError: minError = weightedError bestClassEst = predictedVals.copy() bestStump['dimension'] = i bestStump['threshold'] = threshold bestStump['inequal'] = inequal return bestStump,minError,bestClassEst def adaBoostTrainDS(self,dataArr,classLabels,numIter=40): """AdaBoost训练过程""" weakClassArr = [] m = np.shape(dataArr)[0] D = np.mat(np.ones((m,1))/m) aggClassEst = np.mat(np.zeros((m,1))) for i in range(numIter): bestStump,error,classEst = self._buildStump(dataArr, classLabels, D) print("D:",D.T) alpha = float(0.5*np.log((1.0-error)/max(error,1e-16))) bestStump['alpha'] = alpha weakClassArr.append(bestStump) print("classEst:",classEst.T) expon = np.multiply(-1*alpha*np.mat(classLabels).T,classEst) D = np.multiply(D,np.exp(expon)) D = D/D.sum() aggClassEst += alpha*classEst print("aggClassEst:",aggClassEst.T) aggErrors = np.multiply(np.sign(aggClassEst) != np.mat(classLabels).T,np.ones((m,1))) errorRate = aggErrors.sum()/m print("total error:",errorRate,"\n") if errorRate == 0.0: break return weakClassArr,aggClassEst def adaClassify(self,dataToClass,classifierArr): """AdaBoost分类函数""" dataMatrix = np.mat(dataToClass) m = np.shape(dataMatrix)[0] aggClassEstimate = np.mat(np.zeros((m,1))) for i in range(len(classifierArr)): classEstimate = self.stumpClassify(dataMatrix, classifierArr[i]['dimension'], classifierArr[i]['threshold'], classifierArr[i]['inequal']) aggClassEstimate += classifierArr[i]['alpha'] * classEstimate print(aggClassEstimate) return np.sign(aggClassEstimate) (未完待续)]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列最小最优化算法SMO]]></title>
    <url>%2F2018%2F07%2F28%2Fmachine-learning-svm-smo%2F</url>
    <content type="text"><![CDATA[如何高效地实现支持向量机学习呢？常用的是1998年Platt提出的序列最小最优化算法(Sequential minimal optimization，SMO)算法。 SMO算法要解的是如下的一个最优化问题：$$\min_{\alpha} \left( \frac{1}{2} \sum_{i=1}^N \sum_{j=1}^N \alpha_i \alpha_j y_i y_j K(x_i,x_j) - \sum_{i=1}^N \alpha_i\right) \tag{1}$$ $$subject \; to \sum_{i=1}^N \alpha_i y_i = 0, \tag{2}$$ $$0 \leq \alpha_i \leq C, \forall i \tag{3}$$ 整个SMO算法包括两个部分：求解两个变量二次规划的解析方法和选择变量的启发式方法。 两个变量二次规划的求解方法假设选择的两个变量是$\alpha_1,\alpha_2$，其他变量$\alpha_i (i=3,4,\dots,N)$是固定的。因此，上面的最优化问题(1)~(3)的子问题可写为$$\min_{\alpha_1,\alpha_2} G(\alpha_1,\alpha_2) = \frac{1}{2} K_{11} \alpha_1^2 + \frac{1}{2} K_{22} \alpha_2^2 + y_1 y_2 K_{12} \alpha_1 \alpha_2 - (\alpha_1 + \alpha_2) + \\y_1 \alpha_1 \sum_{i=3}^{N} y_i \alpha_i K_{i1} + y_2 \alpha_2 \sum_{i=3}^{N} y_i \alpha_i K_{i2} \tag{4}$$ $$subject \; to \; \alpha_1 y_1 + \alpha_2 y_2 = - \sum_{i=3}^{N} y_i \alpha_i = \beta, \tag{5}$$ $$0 \leq \alpha_i \leq C, \forall i \tag{6}$$ 其中，$K_{ij} = K(x_i,x_j) ,i,j = 1,2, \dots ,N$，（４）中省略了不含$\alpha_1,\alpha_2$的常数项。 由于只有两个变量$(\alpha_1,\alpha_2)$，约束可以用二维空间中的图形表示。 不等式约束（6）使得$（\alpha_1,\alpha_2）$在区域 [0, C] x [0, C] 内，等式约束（５）使得$（\alpha_1,\alpha_2）$在平行于区域 [0, C] x [0, C] 的对角线的直线上。因此要求的是目标函数在一条平行于对角线的线段上的最优值。这使得两个变量的最优化问题成为实质上的单变量的最优化问题，不妨考虑为变量$\alpha_2$的最优化问题。 假设问题（４）～（６）的初始可行解为$\alpha_1,\alpha_2$，最优解为$\alpha_1^{new},\alpha_2^{new}$，沿着约束方向经剪辑后$\alpha_2$的最优解为$\alpha_2^{new,clipped}$。 由于$\alpha_2^{new}$满足不等式约束（５），所以最优值$\alpha_2^{new}$的取值范围必须满足条件$$L \leq \alpha_2^{new} \leq H$$其中，L与H分别是$\alpha_2^{new}$所在的对角线段端点的下、上界。 如果$y_1 \neq y_2$ ，则$$L = \max (0, \alpha_2 - \alpha_1)，H = \min ( C, C + \alpha_2 - \alpha_1 ) \tag{7}$$如果$y_i = y_2$，则$$L = \max (0, \alpha_2 + \alpha_1 - C)，H = \min ( C, \alpha_2 + \alpha_1 ) \tag{8}$$ 记$$w(x) = \sum_{i=1}^{N} \alpha_i y_i K(x_i,x) + b \tag{9}$$令$$E_i = w(x_i) - y_i = \left ( \sum_{i=1}^{N} \alpha_i y_i K(x_i,x) + b \right) - y_i, i = 1,2, \tag{10}$$当i = 1, 2时，$E_i$为函数w(x)对输入$x_i$的预测值与真实输出$y_i$之间的误差。 由$$\alpha_1 y_1 + \alpha_2 y_2 = \beta 及 y_i^2 = 1$$$\alpha_1$可表示为$$\alpha_1 = ( \beta - y_2 \alpha_2 ) y_1 \tag{11}$$代入（４）中，得到仅含$\alpha_2$的目标函数：$$G(\alpha_2) = \frac{1}{2} K_{11} ( \beta - y_2 \alpha_2 )^2 + \frac{1}{2} K_{22} \alpha_2^2 + y_2 K_{12} ( \beta - y_2 \alpha_2 ) \alpha_2 - ( \beta - y_2 \alpha_2 )y_1 - \alpha_2 + \\( \beta - y_2 \alpha_2 ) \sum_{i=3}^{N} y_i \alpha_i K_{i1} + y_2 \alpha_2 \sum_{i=3}^{N} y_i \alpha_i K_{i2}$$对$\alpha_2$求导数，并令其为 0$$\frac {\partial G} {\partial \alpha_2} = K_{11}( \alpha_2 - \beta y_2) + K_{22} \alpha_2 + y_2 K_{12} (\beta - 2 y_2 \alpha_2) + \\y_1 y_2 -1 - y_2 \sum_{i=3}^{N} y_i \alpha_i K_{i1} + y_2 \sum_{i=3}^{N} y_i \alpha_i K_{i2} = 0$$ $$\begin{align}=&gt; ( K_{11} +K_{22} -2 K_{12} ) \alpha_2 &amp;= y_2 ( y_2 - y_1 + \beta K_{11} - \beta K_{12} + \sum_{i=3}^{N} y_i \alpha_i K_{i1} - \sum_{i=3}^{N} y_i \alpha_i K_{i2} ) \\&amp;= y_2 [ y_2 - y_1 + \beta K_{11} - \beta K_{12} + \left( w(x_1) - \sum_{j=1}^{2} y_j \alpha_j K_{1j} - b \right) \\&amp; - \left( w(x_2) - \sum_{j=1}^{2} y_j \alpha_j K_{2j} - b \right) ]\end{align}$$ 将$\beta = \alpha_1 y_1 + \alpha_2 y_2 $代入，得到$$\begin{align}( K_{11} +K_{22} -2 K_{12} ) \alpha_2^{new} &amp;= y_2 \left ( y_2 - y_1 + (\alpha_1 y_1 + \alpha_2 y_2) K_{11} - (\alpha_1 y_1 + \alpha_2 y_2) K_{12} + \\w(x_1) - w(x_2) \tag {12} - y_1 \alpha_1 K_{11} - y_2 \alpha_2 K_{12} + y_1 \alpha_1 K_{21} + y_2 \alpha_2 K_{22} \right) \\&amp; = y_2 \left( E_1 - E_2 + \alpha_2 y_2 (K_{11} - 2 K_{12} + K_{22}) \right) \\&amp; = \alpha_2 (K_{11} - 2 K_{12} + K_{22}) + y_2(E_1 - E_2)\end{align}$$令$$\eta = K_{11} - 2 K_{12} + K_{22} \tag{13}$$将$\eta$代入（１２）$$\eta \alpha_2^{new} = \alpha_2 \eta + y_2 (E_1 - E_2) \\=&gt; \alpha_2^{new} = \alpha_2 + \frac {y_2 (E_1 - E_2)}{\eta} \tag {14}$$要将$\alpha_2^{new}$限制在区间[L, H]中 ，则$$\alpha_2^{new,clipped} =\begin{cases}H, &amp; \alpha_2^{new} &gt; H \\\alpha_2^{new}, &amp; L \leq \alpha_2^{new} \leq H \\L, &amp; \alpha_2^{new} &lt; L\end{cases} \tag {15}$$由式（５）可得$$\alpha_1 y_1 + \alpha_2 y_2 = \alpha_1^{new} y_1 + \alpha_2^{new,clipped} y_2$$两边同乘以$y_1$，得$$\alpha_1 + \alpha_2 y_1 y_2 = \alpha_1^{new} + \alpha_2^{new,clipped} y_1 y_2$$从而，$$\alpha_1^{new} = \alpha_1 + y_1 y_2 ( \alpha_2^{new,clipped} - \alpha_2) \tag{16}$$故，最优化问题（４）～（６）的解为$（\alpha_1^{new},\alpha_2^{new,clipped}）$ （未完待续。。。）]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax语法]]></title>
    <url>%2F2018%2F07%2F16%2Fmathjax-tutorial%2F</url>
    <content type="text"><![CDATA[如何在网页中便捷地输入数学公式呢？MathJax就是一个不错的选择。 使用$或者$$来标明需要MathJax解析的公式。$表示行内公式，而$$表示的数学公式会独占一行，如 $y=ax+b$： $y=ax+b$ $$y=ax+b$$：$$y=ax+b$$ 输入分数示例：$\frac{1}{3}$ 或者 $1 \over 3$ 显示：$\frac{1}{3}$ 开根号示例：$\sqrt{3}$ 或者 $\sqrt[n]{3}$ 显示：$\sqrt{3}$、$\sqrt[n]{3}$ 上下标^表示上标，_表示下标。如果上下标的内容多于一个字符，则需要用{ }括起来。 示例：$e^2$、$e^{ax+b}$、 显示：$e^2$、$e^{ax+b}$ 对数 普通对数：$\log_2{8}$ =&gt; $\log_2{8}$ 自然对数：$\ln 8$ =&gt; $\ln 8$ 常用对数：$\lg 100$ =&gt; $\lg 100$\ 累加、累乘 累加：$\sum_{i=1}^n (i^2+2i+1)$ =&gt; $\sum_{i=1}^n (i^2+2i+1)$ 累乘：$\prod_{i=1}^n \frac{1}{i^2}$ =&gt; $\prod_{i=1}^n \frac{1}{i^2}$ 向量示例：$\vec x$ =&gt; $\vec x$ 积分示例：$\int_a^b sinx dx$ =&gt; $\int_a^b sinx dx$ 无穷示例：$\infty$ $\Rightarrow$ $\infty$ 偏导数示例：$\frac{\partial f(x,y)}{\partial x}$ =&gt; $\frac{\partial f(x,y)}{\partial x}$ 标签示例：$$(a+b)(a-b)=a^2-b^2 \tag{1.1}$$$$(a+b)(a-b)=a^2-b^2 \tag{1.1}$$ 最大、最小最大：$$\max_{x} y$$$$\max_{x} y$$最小：$$\min_{x} y$$$$\min_{x} y$$ 统计估计示例：$$\hat y$$$$\hat y$$ 向上（下）取整向上取整：$$\left \lceil \frac{a}{b} \right \rceil$$$$\left \lceil \frac{a}{b} \right \rceil$$向下取整：$$\left \lfloor \frac{a}{b} \right \rfloor$$$$\left \lfloor \frac{a}{b} \right \rfloor$$ 空格空一格：a\ b =&gt; $a \ b$ 空四格：a \quad b =&gt; $a \quad b$ 空八格：a \qquad b $\Rightarrow$ $a \qquad b$ 绝对值、范数绝对值：\lvert x \rvert $\Rightarrow$ $\lvert x \rvert$ 范数：\lVert x \rVert $\Rightarrow$ $\lVert x \rVert$ 对齐123456$$\begin&#123;align&#125;y &amp;= (a-b)(a+b) \\&amp;= a^2 - b^2\end&#123;align&#125;$$ $$\begin{align}y &amp;= (a-b)(a+b) \\&amp;= a^2 - b^2\end{align}$$ 分段函数12345678$$y=\begin&#123;cases&#125;0,&amp; x &lt; 0 \\0.5,&amp; x = 0 \\1,&amp; x &gt; 0\end&#123;cases&#125;$$ $$y=\begin{cases}0,&amp; x &lt; 0 \\0.5,&amp; x = 0 \\1,&amp; x &gt; 0\end{cases}$$ 矩阵 不带括号的矩阵 1234567$$A = \begin&#123;matrix&#125;2 &amp; 0 \\0 &amp; 5\end&#123;matrix&#125;$$ $$A =\begin{matrix}2 &amp; 0 \\0 &amp; 5\end{matrix}$$ 带括号的矩阵 1.\begin{vmatrix}...\end{vmatrix}$$A =\begin{vmatrix}2 &amp; 0 \\0 &amp; 5\end{vmatrix}$$ 2.\begin{bmatrix}...\end{bmatrix}$$A =\begin{bmatrix}2 &amp; 0 \\0 &amp; 5\end{bmatrix}$$ 3.\begin{Bmatrix}...\end{Bmatrix}$$A =\begin{Bmatrix}2 &amp; 0 \\0 &amp; 5\end{Bmatrix}$$4.\begin{pmatrix}...\end{pmatrix}$$A =\begin{pmatrix}2 &amp; 0 \\0 &amp; 5\end{pmatrix}$$ 省略号 省略号 符号 水平省略号 $\cdots$ \cdots 垂直省略号 $\vdots$ \vdots 对角省略号 $\ddots$ \ddots 括号 括号 符号 $\overbrace{x,y,z}$ \overbrace{x,y,z} $\underbrace{x_1,x_2}$ \underbrace{x_1,x_2} 箭头 箭头 符号 $\uparrow$ \uparrow $\Uparrow$ \Uparrow $\downarrow$ \downarrow $\Downarrow$ \Downarrow $\rightarrow$ \rightarrow $\Rightarrow$ \Rightarrow $\leftarrow$ \leftarrow $\Leftarrow$ \Leftarrow $\leftrightarrow$ \leftrightarrow $\Leftrightarrow$ \Leftrightarrow $\nearrow$ \nearrow $\searrow$ \searrow $\swarrow$ \swarrow $\nwarrow$ \nwarrow 四则运算 四则运算 符号 + + - - $\times$ \times $\div$ \div 特殊乘法 $x \cdot y$ =&gt; $x \cdot y$ $x \bullet y$ =&gt; $x \bullet y$ $x \odot y$ =&gt; $x \odot y$ $x \otimes y$ =&gt; $x \otimes y$ 关系运算符 关系运算 符号 $\leq$ \leq $\geq$ \geq $\neq$ \neq $\approx$ \approx $\ll$ \ll $\gg$ \gg 相似于$\sim$ \sim $\simeq$ \simeq 全等$\cong$ \cong 恒等$\equiv$ \equiv 定义为$\triangleq$ \triangleq $\prec$ \prec $\succ$ \succ 正比于$\propto$ \propto 推出 $\to$、$\gets$ \to、\gets 逻辑运算符 逻辑运算 符号 $\forall$ \forall $\exists$ \exists $\land$ \land $\lor$ \lor $\lnot$ \lnot 集合运算符 集合运算 符号 集合运算 符号 集合运算 符号 $\cup$ \cup $\subseteq$ \subseteq $\in$ \in $\cap$ \cap $\subseteqq$ \subseteqq $\notin$ \notin $\subset$ \subset $\subsetneq$ \subsetneq $\varnothing$ \varnothing $\supset$ \supset $\subsetneqq$ \subsetneqq $\emptyset$ \emptyset 集合相减 $\setminus$ \setminus $\supseteq$ \supseteq $\supsetneqq$ \supsetneqq 希腊字母 小写字母 符号 大写字母 符号 $\alpha$ \alpha $\beta$ \beta $\gamma$ \gamma $\Gamma$ \Gamma $\delta$ \delta $\Delta$ Delta $\lambda$ \lambda $\Lambda$ \Lambda $\eta$ \eta $\epsilon$ $\varepsilon$ \epsilon \varepsilon $\rho$ \rho $\zeta$ \zeta $\xi$ \xi $\Xi$ \Xi $\pi$ \pi $\Pi$ \Pi $\theta$ \theta $\Theta$ \Theta $ \sigma $ \sigma $\Sigma$ \Sigma $\phi$ \phi $\Phi$ \Phi $\psi$ \psi $\Psi$ \Psi $\mu$ \mu $\omega$ \omega $\Omega$ \Omega $\tau$ \tau 字体 粗体（boldface）：\mathbf{X} =&gt; $\mathbf{X}$ 罗马体（roman）：\mathrm{d}x =&gt; $\mathrm{d}x$ 导数的正式写法：\frac{\mathrm{d} y } {\mathrm{d} x }$$\frac{\mathrm{d} y } {\mathrm{d} x }$$以下三种字体仅支持大写字母 书写体（calligraphic）：\mathcal{X} =&gt; $\mathcal{X}$ script：\mathscr{X} =&gt; $\mathscr{X}$ 黑体（Blackboard bold）：\mathbb{X} =&gt; $\mathbb{X} $ 特殊符号 特殊符号 代码 反斜杠$\backslash$ \backslash 星号$\star$ \star 度数，例如$30^\circ$ 30^\circ 手写体$\ell$，区别于数字1 \ell 导数简写，撇$\prime$ \prime 波浪号$\tilde x$ \tilde x $\overset{def}{=}$、$\overset{b}{a}$ \overset{def}{=} $\underset{b}{a}$ \underset{b}{a} 单个字符上划线 $\bar b$ \bar b 多个字符上划线 $\overline{ab}$ \overline{ab}]]></content>
      <categories>
        <category>mathjax</category>
      </categories>
      <tags>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性可分支持向量机]]></title>
    <url>%2F2018%2F07%2F16%2Fmachine-learning-svm-linearly-separable%2F</url>
    <content type="text"><![CDATA[线性可分支持向量机分离超平面$$\mathbf w \cdot \mathbf x +b = 0 \tag {1}$$ 其中，w为分离超平面的法向量，b为截距 分类决策函数$$f(x) = sign(\mathbf w \cdot \mathbf x +b)$$其中，sign()称为符号函数，$$sign(x) =\begin{cases}-1, &amp; x &lt; 0 \\0, &amp; x = 0 \\1, &amp; x &gt; 0\end{cases}$$ 函数间隔定义：对于给定的训练数据集T和超平面(w,b)，定义超平面(w,b)关于样本点($x_i,y_i$)的函数间隔为$$\hat \gamma_i = y_i ( w \cdot x_i + b)$$定义超平面(w,b)关于训练数据集T的函数间隔为超平面(w,b)关于T中所有样本点($x_i,y_i$)的函数间隔之最小值，即$$\hat \gamma = \min_{i=1,\dots,N} \hat \gamma_i$$ 几何间隔定义：对于给定的训练数据集T和超平面(w,b)，定义超平面(w,b)关于样本点($x_i,y_i$)的几何间隔为$$\gamma_i = y_i \frac {w \cdot x_i + b}{||w||}$$定义超平面(w,b)关于训练数据集T的几何间隔为超平面(w,b)关于T中所有样本点($x_i,y_i$)的几何间隔之最小值，即$$\gamma = \min_{i=1,\dots,N} \gamma_i$$超平面（w，b）关于样本点（$x_i,y_i$）的几何间隔是实例点到超平面的带符号的距离。 函数间隔和几何间隔有如下关系：$$\gamma_i = \frac{\hat \gamma_i}{||w||}$$ $$\gamma = \frac{\hat \gamma}{||w||}$$ 若||w||=1，则函数间隔和几何间隔相等。如果超平面参数w和b成比例地改变（超平面没有改变），函数间隔也会按比例改变，而几何间隔不变。 间隔最大化如何求得几何间隔最大的分离超平面，即最大间隔分离超平面呢？可用下面的约束最优化问题来表示$$\max_{w,b} \gamma \\s.t. y_i \frac{w \cdot x_i +b }{||w||} \geq \gamma, i=1,2,\dots,N$$约束条件表示超平面(w,b)关于每个训练样本点的几何间隔至少是$\gamma$ 根据函数间隔和几何间隔的关系，上面的问题可写为$$\max_{w,b} \frac{\hat \gamma}{||w||}$$ $$s.t. y_i ( w \cdot x_i +b ) \geq \hat \gamma, i=1,2,\dots,N$$ 函数间隔$\hat \gamma$的取值并不影响最优化问题的解。因为将w和b按比例改变为$\lambda w 和\lambda b$，这时函数间隔变为$\lambda \hat \gamma$，函数间隔的改变对上面的最优化问题的不等式约束没有影响，对目标函数的优化也没有影响。 不妨取$\hat \gamma = 1$，将其代入上面的最优化问题，得$\max_{w,b} \frac{1}{||w||}$，又最大化$\frac{1}{||w||}$等价于最小化$\frac{1}{2}||w||^2$。 故得到了下面的线性可分支持向量机学习的最优化问题$$\min_{w,b} \frac{1}{2}||w||^2$$ $$s.t. y_i ( w \cdot x_i +b ) - 1 \geq 0, i = 1,2,\dots,N$$ 对式（4）使用拉格朗日乘数法（Lagrange multipliers）可得到其“对偶问题”(dual problem)。对式（4）的每条约束添加拉格朗日乘数$\alpha_i \geq 0$，则该问题的拉格朗日函数可写为$$L(w,b,\alpha) = \frac{1}{2}||w||^2 + \sum_{i=1}^{m} \alpha_i (1-y_i(w \cdot x_i +b)) \tag{5}，\\其中 \alpha = (\alpha_i,\alpha_2,\dots,\alpha_m)^T$$令L(w,b,$\alpha$)对w和b的偏导数为零，$$\begin{align}&amp; \frac{\partial L}{\partial w} = w - \sum_{i=1}^{m} \alpha_i y_i \mathbf x_i = 0\\&amp; \frac{\partial L}{\partial b} = -\sum_{i=1}^{m} \alpha_i y_i = 0\end{align}$$从而，$$w = \sum_{i=1}^{m} \alpha_i y_i \mathbf x_i \tag {6}$$ $$0 = \sum_{i=1}^{m} \alpha_i y_i \tag {7}$$ 将式（6）、（7）代入式（5）中，得：$$\begin{align}L(w,b,\alpha) &amp; = \frac{1}{2} \sum_{i=1}^{m} \alpha_I y_i \mathbf x_i^T \sum_{j=1}^{m} \alpha_j y_j \mathbf x_j + \sum_{i=1}^{m} \alpha_i ( 1 - y_i( \mathbf x_i \sum_{j=1}^{m} \alpha_j y_j \mathbf x_j^T + b) )\\&amp; =\sum_{i=1}^{m} \alpha_i - \frac{1}{2}\sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_i \alpha_j y_i y_j \mathbf x_i^T x_j\end{align}$$ 故，式(4)的对偶问题为$$\max_\alpha [ \sum_{i=1}^{m} \alpha_i - \frac{1}{2}\sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_i \alpha_j y_i y_j (\mathbf x_i \cdot \mathbf x_j) ] \tag{8} \\s.t. \sum_{i=1}^{m} \alpha_i y_i = 0,\\\alpha_i \geq 0, i = 1,2,\dots,m$$ 例题已知一个训练数据集，其正例点是$x_1 = (3,3),x_2 = (4,3)$,负例点是$x_3 = (1,1)$，求线性可分支持向量机。 解：对偶问题是$$\min_\alpha \left ( \frac{1}{2}\sum_{i=1}^{m} \sum_{j=1}^{m} \alpha_i \alpha_j y_i y_j (\mathbf x_i \cdot \mathbf x_j) - \sum_{i=1}^{m} \alpha_i \right) \\= \frac{1}{2}(18 \alpha_1^2+25 \alpha_2^2 + 2 \alpha_3^2 + 42\alpha_1 \alpha_2 - 12 \alpha_1 \alpha_3 - 14 \alpha_2 \alpha_3) -\alpha_1 - \alpha_2 - \alpha_3 \\s.t. \alpha_1 + \alpha_2 - \alpha_3 = 0 \\\alpha_i \geq 0 , i = 1,2,3$$将$\alpha_3 = \alpha_1 + \alpha_2$代入目标函数并记为$$s(\alpha_1,\alpha_2) = 4 \alpha_1^2 + \frac{13}{2} \alpha_2^2 + 10 \alpha_1 \alpha_2 - 2 \alpha_1 - 2 \alpha_2$$ 对$\alpha_1,\alpha_2$求偏导数，并其为0$$\frac{\partial s}{\partial \alpha_1} = 8 \alpha_1 + 10 \alpha_2 - 2 = 0\\\frac{\partial s}{\partial \alpha_2} = 13 \alpha_2 + 10 \alpha_1 - 2 = 0$$联立上式，解得：$$\alpha_1 = \frac{3}{2}, \alpha_2 = -1$$从而，$s(\alpha_1,\alpha_2)在（\frac{3}{2}, -1）$取极值，但该点不满足约束条件$\alpha_2 \geq 0$，所以最小值应在边界上取得。 当$\alpha_1 = 0$时，$$\begin{align}s(\alpha_2) &amp;= \frac{13}{2} \alpha_2^2 - 2 \alpha_2 \\&amp;= \frac{13}{2} (\alpha_2^2 - \frac{4}{13} \alpha_2) \\&amp;= \frac{13}{2} (\alpha_2 - \frac{2}{13})^2 - \frac{2}{13}\end{align}$$显然，当$\alpha_2 = \frac{2}{13}$时，$s(\alpha_1,\alpha_2)$取得最小值$s(0,\frac{2}{13}) = - \frac{2}{13}$。 同理可得，当$\alpha_2 = 0$时，$s(\alpha_1,\alpha_2)$的最小值$s(\frac{1}{4},0) = - \frac{1}{4}$。 故，$s(\alpha_1,\alpha_2)$在$\alpha_1 = \frac{1}{4} ,\alpha_2 = 0)$处达到最小，此时，$\alpha_3 = \frac{1}{4}$ 因此，$\alpha_1^* = \alpha_3^* = \frac{1}{4}$对应的实例点$x_1,x_3$是支持向量。$$\begin{align}w_1^{*} &amp; = \alpha_1^{*} y_1 x_{11} + \alpha_3^{*} y_3 x_{31}\\&amp;=\frac{1}{4} \times 1 \times 3 + \frac{1}{4} \times (-1) \times 1\\&amp;=\frac{1}{2}\end{align}$$同理可得，$$w_2^* = \alpha_1^* y_1 x_{12} + \alpha_3^* y_3 x_{32} =\frac{1}{2}$$ $$\begin{align}b^* &amp;= y_1 - [ \alpha_1^*y_1(x_1 \cdot x_1) + \alpha_3^*y_3(x_3 \cdot x_1)] \\&amp;= 1 - \left( \frac{1}{4} \times 1 \times [ (3,3) \cdot (3,3) ] + \frac{1}{4} \times (-1) \times [(1,1) \cdot (3,3) \right) \\&amp;= -2\end{align}$$ 故，分离超平面为$$\frac{1}{2}x^{(1)} + \frac{1}{2} x^{(1)} - 2 = 0$$分类决策函数为$$f(x) = sign \left( \frac{1}{2}x^{(1)} + \frac{1}{2} x^{(1)} - 2 \right)$$ （未完待续。。。）]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之logistic回归]]></title>
    <url>%2F2018%2F07%2F10%2Fmachine-learning-logistic-regression%2F</url>
    <content type="text"><![CDATA[对于二分类任务，其输出标记为y ∈ {0,1}，因此我们需要一个将自变量z转换为0/1值，最理想的是 “单位阶跃函数”（unit-step function），亦称Heaviside函数。$$y=\begin{cases}0, &amp; \text{z &lt; 0} \\0.5, &amp; \text{z = 0} \\1, &amp; \text{z &gt; 0}\end{cases}$$ 然而，单位阶跃函数的问题在于：该函数是一个不连续的分段函数，它在x=0处从0瞬间跳跃到了1。 我们希望找到一个近似单位阶跃函数的“替代函数”（surrogate function），并希望它单调可微。对数几率函数正是这样一个替代函数。 对数几率函数：$$y=\frac{1}{1+e^{-z}}$$ 对数几率函数是一种Sigmoid函数（形似S的函数），它将z值转化为一个接近0或1的y值。从上面[-5,5]以及[-60,60]两张局部图可以看出，其在[-5,5]这个区间范围内变化很陡，函数值从0快速跳跃到了1。 算法思想在每个特征上都乘以一个回归系数，然后把所有的结果值相加，将这个总和代入Sigmoid函数中，进而得到一个范围在0~1之间的数值。任何大于0.5的数据被分入1类，小于0.5则被归入0类。 二项logistic回归模型：$$P(Y=1|x)=\frac{1}{1+e^{-(w \cdot x + b)}}=\frac{e^{w \cdot x+b}}{1+e^{w \cdot x+b}}=h(x)$$ $$P(Y=0|x)=\frac{1}{1+e^{w \cdot x+b}}$$ 其中，x ∈ $R^n$是输入向量，w ∈ $R^n$是权重向量，$w \cdot x$为w和x的内积。 方便起见，将输入向量和权重向量加以扩充，仍记作w，x，即$$w = (w^{(1)},w^{(2)},\dots,w^{(n)},b)^T$$ $$x=(x^{(1)},x^{(2)},\dots,x^{(n)},1)^T$$ 此时，二项logistic回归模型：$$P(Y=1|x)=\frac{e^{w \cdot x}}{1+e^{w \cdot x}}=h(x)$$ $$P(Y=0|x)=\frac{1}{1+e^{w \cdot x}}$$ 我们可以通过最大似然估计法（maximum likelihood method）来估计w。 似然函数：$$\prod^{n}_{i=1}[{h(x_i)]^{y_i}}[1-h(x_i)]^{1-y_i}$$对数似然函数：$$L(w)=\sum^n_{i=1} [ {y_i \ln h(x_i)+(1-y_i) \ln (1-h(x_i))}]\\=\sum^n_{i=1} [y_i \ln \frac{h(x_i)}{1-h(x_i)}+\ln(1-h(x_i))]\\=\sum^n_{i=1}[{y_i ( w \cdot x_i)-\ln(1+\rm e^{w \cdot x_i})}]$$从而$$\hat w = argmax_w L(w)$$ 求最优回归系数梯度上升法算法思想大学高等数学下册中说，沿梯度方向的方向导数最大，也就是说，梯度方向是函数f(x,y)在某一点(x,y)处增长最快的方向。 要找到某函数的最大值，最好的方法就是沿着该函数的梯度方向探寻。 梯度上升算法的迭代公式： $$w=w+\alpha \cdot grad L(w)$$其中，$\alpha$为步长，表示每次沿梯度方向移动的距离；grad L(w)表示L(w)的梯度。 梯度公式$$grad f(x,y,z) = \frac{\partial f}{\partial x} \cdot \vec i + \frac{\partial f}{\partial y} \cdot \vec j + \frac{\partial f}{\partial z} \cdot \vec k$$根据之前求得的对数似然函数，对w求偏导数$$\frac{\partial L(w)}{\partial w}=\sum^n_{i=1}[{y_i x_{i}} - \frac{x_{i}e^{w \cdot x_i}}{1+e^{w \cdot x_i}}]\\=\sum^n_{i=1}{x_{i}(y_i-h(x_i))}$$故$$grad L(w_1,w_2,\dots,w_n)=\sum_{k=1}^n \frac{\partial L(w)}{\partial w_k}\cdot \vec{i_k}\\= ( \sum_{i=1}^{n}x_{i1}(y_i-h(\vec{x_i})), \sum_{i=1}^{n}x_{i2}(y_i-h(\vec{x_i})),\dots,\sum_{i=1}^{n}x_{in}(y_i-h(\vec{x_i})))^T$$ 代码实现12345678910111213141516171819202122232425import numpy as npdef sigmoid(inputVector): return 1.0/(1+np.exp(-inputVector))def gradientAscent(dataMatrix,classLabels,iterations=500,alpha=0.001): """梯度上升算法""" dataMatrix = np.mat(dataMatrix) # transpose()将矩阵转置 labelMatrix = np.mat(classLabels).transpose() m,n = np.shape(dataMatrix) weights = ones((n,1)) for k in range(iterations): h = sigmoid(dataMatrix*weights) error = (labelMatrix-h) weights = weights + alpha * dataMatrix.transpose() * error return weightsdef classifyVector(inputVector,weights): """logistic回归分类函数""" p = sigmoid(inputVector*weights) if p &gt; 0.5: return 1 else: return 0 随机梯度上升一次仅用一个样本点来更新回归系数。 12345678910def randomGradientAscent(dataMatrix,classLabels,alpha=0.001): """随机梯度上升算法""" m,n = np.shape(dataMatrix) weights = np.ones(n) for i in range(m): # dataMatrix[i]*weights 逐元素相乘 h = sigmoid(sum(dataMatrix[i]*weights)) error = classLabels[i]-h weights = weights + alpha*dataMatrix[i]*errorreturn weights 改进的随机梯度上升改进 动态调整alpha 随机选取样本来更新回归系数 代码实现： 1234567891011121314def improvedRandomGradientAscent(dataMatrix,classLabels, iterations=500,alpha=0.001) m,n = np.shape(dataMatrix) weights = np.ones(n) for j in range(iterations): dataIndex = range(m) for i in range(m): alpha = alpha + 4/(1+i+j) randomIndex = int(np.random.uniform(0,len(dataIndex))) h = sigmoid(sum(dataMatrix[randomIndex]*weights)) error = classLabels[randomIndex] - h weights = weights + alpha * error * dataMatrix[randomIndex] del dataIndex[randomIndex] return weights 梯度下降法梯度下降法与梯度上升法类似，用于求函数的最小值，其迭代公式如下：$$w=w-\alpha \cdot grad L(w)$$]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之朴素贝叶斯]]></title>
    <url>%2F2018%2F07%2F02%2Fmachine-learning-navie-bayes%2F</url>
    <content type="text"><![CDATA[在讲朴素贝叶斯之前，我们先来回顾一下大学二年级概率论中的相关知识． 条件概率公式： $$P(A|B) = \frac{P(AB)}{P(B)}$$ $$=&gt; P(AB) = P(A|B)P(B)$$ 全概率公式： $$P(A)=\sum_{i=1}^{\infty}{P(B_i)P(A|B_i)}$$ 贝叶斯公式： $$P(B_i|A)=\frac{P(AB_i)}{P(A)}=\frac{P(A|B_i)P(B_i)}{\sum_{i=1}^{\infty}{P(B_i)P(A|B_i)}}$$ 算法思想朴素贝叶斯是贝叶斯决策理论的一部分，而贝叶斯决策理论的核心思想是选择具有最高概率的决策． 举个很简单的例子，一般网站评论或者游戏聊天都会对侮辱性词汇进行屏蔽过滤． 假设现在存在一条评论，如何判断它是否包含侮辱性词汇？我们用P1(w)表示评论w包含侮辱性词汇的概率，用p2(w)表示评论w不包含侮辱性词汇的概率，那么对于评论w，可以用下面的规则来判断它的类别： 如果P1(w) &gt; P2(w) ，那么w为包含侮辱性词汇的评论． 如果P2(w) &gt; P1(w)，那么w为不包含侮辱性词汇的评论． 假设前提朴素贝叶斯是用于文档分类的常用算法，它是基于以下假设对贝叶斯分类器的一个扩展． 特征之间相互独立，即一个特征出现的可能性与其他特征没有关系．比如，如果文档中一个词出现的概率不依赖于文档中的其他词，那么文档中词与词之间相互独立． 每个特征同等重要． 我们知道这两个假设过于简单，这也是之所以称之为朴素（navie）贝叶斯的原因． 理论模型$$P(c|\mathbf{x})=\frac{P(c)P(\mathbf{x}|c)}{P(\mathbf{x})}$$ 其中，P(c)是类＂先验＂(prior)概率，$P(\mathbf{x}|c)$是样本x相对于类标记c的类条件概率，或称为＂似然＂，$P(\mathbf{x})$是用于归一化的＂证据＂因子． 对于给定样本x，证据因子$P(\mathbf{x})$与类标记无关，因此估计$P(c|\mathbf{x})$的问题就转化为如何基于训练数据D来估计先验概率P(c)和条件概率$P(\mathbf{x}|c)$ 根据大数定律，当训练集包含充足的独立同分布样本时，P(c)可通过各类样本出现的频率来进行估计． 对于条件概率$P(\mathbf{x}|c)$来说，由于假设x的各个属性相互独立，因此 $$P(\mathbf{x}|c) = P(x_1x_2…x_n|c) = P(x_1|c)P(x_2|c) \cdot\cdot\cdot P(x_n|c) = \prod_{i=1}^{n}{P(x_i|c)}$$ 其中，n为x的属性个数 由于连乘操作易造成下溢出，即太多很小的数相乘导致结果四舍五入后得到0，通常使用对数进行处理，将连乘变为累加，从而避免下溢出．因此， 令$$L = P(c)P(\mathbf{x}|c)$$ 则$$log L = log P(c) + log P(\mathbf{x}|c) = log P(c) + \sum_{i=1}^{n}{log P(x_i|c)}$$ 拉普拉斯修正为了避免其他属性（特征）携带的信息被训练集中未出现的属性值＂抹去＂，即为了避免多个条件概率相乘时某个概率值为0，导致最后的乘积为0，在估计概率值时通常要进行＂平滑＂，常用＂拉普拉斯修正＂． 具体来说，令N表示训练集D中可能的类别数，$N_i$表示第i个属性可能的取值数，则 $$P(c)=\frac{|D_c|+1}{|D|+N}$$ $$P(w_i|c)=\frac{|D_{c,x_i}|+1}{|D_c|+N_i}$$ 示例：文本分类朴素贝叶斯分类器通常有以下两种实现方式 词集模型：将每个词的出现与否作为一个特征，值为1表示词条出现在文档中，0表示词条未出现 词袋模型：将每个词在文档中出现的次数作为一个特征 下面我们用词集模型，来实现一个区分某一评论是否包含侮辱性词汇的朴素贝叶斯分类器． 创建一个bayes.py文件， 将训练集转化为词汇列表 1234567891011from numpy import *def createVocabularyList(dataset): """ 从数据集中抽取不重复的词汇列表 dataset: 给定的数据集 """ vocabularySet = set([]) # 创建一个空集合 for document in dataset: # 操作符｜表示求两个集合的并集 vocabularySet = vocabulary | set(document) return list(vocabularySet) 将训练集中的某一条数据转化为向量 1234567891011121314def setOfWords2Vector(vocabularyList,inputSet): """ 根据词汇列表，将输入的数据集转化为与词汇列表维度相同的向量 """ # 创建一个长度为len(vocabularyList)，所含元素都为0的向量 # 等价于 # returnVector = [] # for i in range(len(vocabularyList)): # returnVector[i] = 0 returnVector = [0]*len(vocabularyList) for word in inputSet: if word in vocabularyList: returnVector[vocabularyList.index(word)] = 1 return returnVector 创建朴素贝叶斯分类器训练函数 123456789101112131415161718192021222324252627282930def trainNavieBayes(trainMatrix,trainCategory): """ 贝叶斯分类器训练函数 trainMatrix: numpy中array类型，是由训练集转化的所有向量组成的矩阵 trainCategory: 由矩阵中每一向量的所属类别组成的列表 """ numTrainDocs = len(trainMatrix) numWords = len(trainMatrix[0]) # pAbusive = sum(trainCategory)/float(numTrainDocs) # 拉普拉斯修正 pAbusive = (sum(trainCategory) + 1)/(float(numTrainDocs) + 2) p0Vector = zeros(numWords);p1Vector = zeros(numWords) # 计算某一类别下的总词数 # p0NumWords = 0.0;p1NumWords = 0.0 # 使用拉普拉斯修正后 p0NumWords = 2.0;p1NumWords = 2.0 for i in range(numTrainDocs): if trainCategory[i] == 1: p1Vector += trainMatrix[i] p1NumWords += sum(trainMatrix[i]) else: p0Vector += trainMatrix[i] p0NumWords += sum(trainMatrix[i]) # 用某个类别下某个词出现的次数除以该类别下的总词数， # 即求得某一类别c在每一个属性上的概率p(ci) # p0Vector = p0Vector/p0NumWords # p1Vector = p1Vector/p1NumWords p0Vector = log(p0Vector/p0NumWords) p1Vector = log(p1Vector/p1NumWords) return p0Vector,p1Vector,pAbusive 创建朴素贝叶斯分类函数 1234567def classifyNavieBayes(vector2Classify,p0Vector,p1Vector,pc1): p1 = sum(vector2Classify*p1Vector) + log(pc1) p0 = sum(vector2Classify*p0Vector) + log(1.0-pc1) if p1 &gt; p0: return 1 else: return 0 上面程序的第2行，就是在求 $$log L = log P(c) + log P(\mathbf{x}|c) = log P(c) + \sum_{i=1}^{n}{log P(x_i|c)}$$ 接下来我们测试一下刚才的分类器是否有效 1234567891011121314151617181920212223242526def loadDataSet(): postingList = [['my','dog','has','flea','problems','help','please'], ['maybe','not','take','him','to','dog','park','stupid'], ['my','dalmation','is','so','cute','I','love','him'], ['stop','posting','stupid','worthless','garbage'], ['mr','licks','ate','my','steak','how','to','stop','him'], ['quit','buying','worthless','dog','food','stupid']] # 0表示正常言论，１表示包含侮辱性词汇的评论 categoryVector = [0,1,0,1,0,1] return postingList,categoryVectordef testNavieBayes(): listOfPosts,listClasses = loadDataSet() vocabularyList = createVocabularyList(listOfPosts) trainMatrix = [] for post in listOfPosts: trainMatrix.append(setOfWords2Vector(vocabularyList,post)) p0Vector,p1Vector,pc1 = trainNavieBayes(array(trainMatrix),array(listClaasses)) testPost = ['love','my','dalmation'] testVector = array(setOfWords2Vector(vocabularyList,testPost)) print(str(testPost)+" 被分类为:"+ classifNavieBayes(testVector,p0Vector,p1Vector,pc1)) testPost = ['stupid','garbage'] testVector = array(setOfWords2Vector(vocabularyList,testPost)) print(str(testPost)+" 被分类为:"+ classifNavieBayes(testVector,p0Vector,p1Vector,pc1)) 参考资料 机器学习实战, Peter Harrington, 人民邮电出版社 机器学习, 周志华, 清华大学出版社]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之k-近邻算法]]></title>
    <url>%2F2018%2F06%2F27%2Fmachine-learning-knn%2F</url>
    <content type="text"><![CDATA[k-近邻算法（k-Nearest Neighbor，简称kNN）,工作原理： 存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系． 输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似的数据（最近邻）的分类标签．一般来说，只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数． 最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类． 算法实现创建一个kNN.py文件 123456789101112131415161718192021222324252627282930313233343536373839from numpy import *import operatordef classify(inputData,dataSet,labels,k): """ k-近邻算法 inputData: 需要预测分类的数据 dataSet: 训练样本集 labels: 样本集的分类标签 k: k-近邻算法中k,选择最近邻居的数目 """ # 取得样本集合中的样本个数，shape是numpy中用于计算矩阵维度的元组，这里的shape[0]可以理解为求二维矩阵dataSet的行数 dataSetSize = dataSet.shape[0] # 求输入数据与样本集合的差值，tile()是numpy中用于扩展矩阵的函数，这里是将inputData扩展为dataSize行的矩阵，以确保inputData与dataSize同维度，可以相减 differenceMatrix = tile(inputData,(dataSize,1)) - dataSet # 差矩阵的每个元素平方 sqDifferenceMatrix = sqDifferenceMatrix**2 # 对平方后的差距阵每一行求和 sqDistances = sqDifferenceMatrix.sum(axis=1) # 求得输入数据与所有样本的距离 distances = sqDistances**0.5 # 按照从小到大的顺序对距离列表中的每个距离排序，按排序顺序返回排序之前的索引号 sortedDistanceIndicies = distances.argsort() # kClassData 用于存储最相似的k个数据中出现的所有分类及该分类出现的次数，以分类标签作为键，以频度作为值 kClassData = &#123;&#125; for i in range(k): label = labels[sortedDistanceIndicies[k]] # 以下三行，书上简写为kClassCount[label] = kClassData.get(label,0) + 1 # 其中的get()方法，表示若不存在键label，则执行kClassData[label] = 0 if label not in kClassData: kClassData[label] = 0 kClassData[label] += 1 # 对kClassData 按出现的频度降序排序 # 书上这里写的是kClassData.iteritems()，这是python2中字典的方法，python3中只有items()方法 sortedkClassData = sorted(kClassData.items(), key=operator.itemgetter(1), reverse=True) # 返回k个最相似数据中出现频度最高的分类标签 return sortedkClassData[0][0] 上面的程序使用了欧式距离公式，计算两个n维向量A和B之间的距离: $$d=\sqrt{\sum_{i=1}^n{(A_i- B_i)^2}}$$ 例如，点(2,1,5)和(1,2,3)之间的距离计算为： $$d=\sqrt{(2-1)^2+(1-2)^2+(5-3)^2}$$ 测试算法已知6部电影的打斗镜头，接吻镜头及其类型（模拟的数据），判断一部已知打斗镜头和接吻镜头数的新电影，它的类型是动作片，还是爱情片，具体数据如下: 电影名称 打斗镜头 接吻镜头 电影类型 小时代 0 50 爱情片 鬼吹灯之寻龙诀 100 15 动作片 战狼 150 5 动作片 让子弹飞 80 2 动作片 左耳 6 50 爱情片 心花路放 5 40 爱情片 ? 18 90 待定 我们当然可以一眼看出来，这部新电影应该是爱情片，但是，如何让程序自动预测它的类别呢？ 创建一个test.py，代码如下: 1234567891011121314import kNNdef createDataSet(): dataSet = array([0,50],[100,15],[150,5], [80,2],[6,50],[5,40]) labels = ['爱情片','动作片','动作片','动作片','爱情片','爱情片'] return dataSet,labelsdef testKNN(): inputData = [18,90] dataSet,labels = createDataSet() return kNN.classify(inputData,dataSet,labels,3) label = testKNN()print(label) 输出结果： 1爱情片 可以看到，kNN算法确实准确的预测了新电影的分类． 算法改进欧式距离中，数字差值越大的属性对计算结果的影响也越大．若想消除这种影响，使各属性权重相等，可以将数值归一化，如将取值范围处理为0到1，或者-1到1之间． 下面的公式可以将任意取值范围的特征值转化为0到1区间内的值： $$newValue = \frac{oldValue-min}{max-min}$$ 其中，min和max分别是数据集中某一特征（属性）的最小值和最大值 在kNN.py中新增如下代码： 12345678910def autoNorm(dataSet): """将训练集中的数据归一化""" minValues = dataSet.min(0) maxValues = dataSet.max(0) ranges = maxValues - minValues normDataSet = zeros(shape(dataSet)) m = dataSet.shape[0] normDataSet = dataSet - tile(minVals,(m,1)) normDataSet = normDataSet/tile(ranges,(m,1)) return normDataSet 接着修改classify()函数 12345678910111213141516171819202122232425def classify(inputData,dataSet,labels,k): """ k-近邻算法 inputData: 需要预测分类的数据 dataSet: 训练样本集 labels: 样本集的分类标签 k: k-近邻算法中k,选择最近邻居的数目 """ dataSet = autoNorm(dataSet)# 添加这一行 dataSetSize = dataSet.shape[0] differenceMatrix = tile(inputData,(dataSize,1)) - dataSet sqDifferenceMatrix = sqDifferenceMatrix**2 sqDistances = sqDifferenceMatrix.sum(axis=1) distances = sqDistances**0.5 sortedDistanceIndicies = distances.argsort() kClassData = &#123;&#125; for i in range(k): label = labels[sortedDistanceIndicies[k]] if label not in kClassData: kClassData[label] = 0 kClassData[label] += 1 sortedkClassData = sorted(kClassData.items(), key=operator.itemgetter(1), reverse=True) return sortedkClassData[0][0] 涉及的一些numpy中的函数]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matplotlib入门]]></title>
    <url>%2F2018%2F06%2F26%2Fpython-matplotlib%2F</url>
    <content type="text"><![CDATA[Matplotlib是一个Python的2D绘图库。 1import matplotlib.pyplot as plt 设置图片标题1plt.title('title') 设置x/y轴文字12plt.xlabel('xlabel')plt.ylabel('ylabel') 设置x/y轴的刻度范围默认情况下，matplotlib的坐标轴刻度并不会从0开始。通过xlim()和ylim()方法，设置x/y轴的刻度范围，可以让x/y轴的刻度从0开始。 12plt.xlim(xmin,xmax)plt.ylim(ymin,ymax) 示例： 12plt.xlim(xmin=0, xmax=1000)plt.ylim(ymin=0, ymax=100) 设置x/y轴的刻度可以使用xticks()和yticks()方法，设置x/y轴需要显示的所有刻度值。 12plt.xticks(ticks=None, labels=None, **kwargs)plt.yticks(ticks=None, labels=None, **kwargs) 示例： 12# 以50为步长，x轴的刻度为0,50,100,150,...,900,950plt.xticks(np.arange(0, 950, step=50)) 显示图片1plt.show() 使用中文Matplotlib默认是不支持中文的。因此，如果要显示中文，可以导入本地的中文字体库。 1234567import matplotlib.pyplot as pltfrom matplotlib.font_manager import FontProperties# 设置字体，fname为本地字体库的所在路径font = FontProperties(fname='/System/Library/Fonts/Hiragino Sans GB.ttc',size=14)# 在用到中文的地方，设置fontpropertiesplt.title("出行时段分布",fontproperties=font) 折线图绘制折线图，需要使用matplotlib.pyplot中的plot方法 12plot([x], y, [fmt], *, data=None, **kwargs)plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs) 线条样式及颜色fmt由标记（marker）、线条样式（linestyle）以及颜色（color）组成。 12# marker、line以及color均为可选fmt = '[marker][line][color]' Markers 1234567891011符号 描述-------------- o 圆形 v 下三角 ^ 上三角 s 正方形 * 星号 + 加号 x X D 等边菱形 d 不等边菱形 Line Styles 123456符号 描述-------------- - 实线 -- 虚线 -. 点划线 : 点线 Colors 12345678910符号 描述-------------- b blue g green r red c cyan 蓝绿色 m magenta 洋红色 y yellow k black w white 示例： 12345import matplotlib.pyplot as plty = [1,4,9,16]# 带圆形标记的红色实线plt.plot(y, 'o-r')plt.show() 常用关键字参数12345678符号 描述--------------------------------color or c colorlinestyle or ls floatlinewidth or lw floatmarker marker stylemarkersize or ms floatlabel 线条的名字 散点图绘制散点图，需要使用matplotlib.pyplot中的scatter方法 1234567891011import matplotlib.pyplot as pltx = [1,2,3,4,5]y = [i**2 for i in x]plt.scatter(x,y,linewidth=5)plt.title('Squares Numbers',fontsize=24)plt.xlabel('value',fontsize=14)plt.ylabel('square of value',fontsize=14)plt.tick_params(axis='both',labelsize=14)plt.show() 柱状图绘制柱状图，需要使用matplotlib.pyplot中的bar方法 1bar(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs) 饼状图绘制饼状图，需要使用matplotlib.pyplot中的pie方法 1234pie(x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=None, radius=None, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0), frame=False, rotatelabels=False, hold=None, data=None) 保存图片保存图片，需要使用matplotlib.pyplot中的savefig方法。 需要注意的是：savefig必须在show方法之前执行。 123plt.savefig('./test.eps')plt.show() 添加水平/垂直线可以使用hlines()和vlines()方法分别绘制水平、垂直线段。 12plt.vlines(x=0, ymin=0, ymax=1, linestyles=&apos;dashed&apos;)plt.hlines(y=0.5, xmin=-10, xmax=10, linestyles=&apos;dashed&apos;) 显示图例1plt.legend() 显示网格1plt.grid(b=None, which='major', axis='both', **kwargs) b：是否显示网格 which：在哪些刻度上画网格线（主刻度|小刻度），可选的值有{‘major’, ‘minor’, ‘both’} axis：在哪个轴上画网格线，可选的值有{‘both’, ‘x’, ‘y’} 其他关键字参数： 12345符号 描述----------------------------------color or c 网格线的颜色linestyle or ls 网格线的样式linewidth or lw 线的宽度 更改坐标轴的位置1234567891011121314# gca，get current axisax = plt.gca()# 隐藏右边和顶部的线条ax.spines['right'].set_color('none')ax.spines['top'].set_color('none')# 设置x轴和y轴所在的位置ax.xaxis.set_ticks_position('bottom')ax.yaxis.set_ticks_position('left')# 设置x轴和y轴的交点为(0,0)ax.spines['bottom'].set_position(('data', 0))ax.spines['left'].set_position(('data', 0)) 对LaTex的支持在需要输入LaTex公式的地方，使用一对美元符$$包裹起来，就像这样r&#39;sigmoid(x)=$\frac{1}{1+e^{-x}}$&#39;，不要忘记前面的字母r（告诉编译器后面的字符串是个raw string，不需要对反斜杠进行转义）。 示例： 绘制Sigmoid函数，并在图例中显示sigmoid的数学表达式 1234567891011121314151617181920import matplotlib.pyplot as pltimport numpy as npimport mathx = np.arange(start=-10, stop=10, step=0.1)y = 1 / (1 + math.e ** (-x))plt.plot(x, y, linewidth=3, label=r'sigmoid(x)=$\frac&#123;1&#125;&#123;1+e^&#123;-x&#125;&#125;$')plt.xlabel('x', fontsize=15)plt.ylabel('sigmoid(x)', fontsize=15)plt.xticks(np.arange(-10, 11, step=1))plt.yticks(np.arange(0, 1.1, step=0.1))plt.ylim(ymin=0, ymax=1)plt.xlim(xmin=-10, xmax=10)plt.vlines(x=0, ymin=0, ymax=1, linestyles='dashed')plt.hlines(y=0.5, xmin=-10, xmax=10, linestyles='dashed')plt.legend()plt.show() 输出： 更多信息，参看https://matplotlib.org/api/pyplot_summary.html]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NumPy入门]]></title>
    <url>%2F2018%2F06%2F25%2Fpython-numpy%2F</url>
    <content type="text"><![CDATA[NumPy（Numerical Python）是高性能科学计算和数据分析的基础包。 按照标准约定，我们在使用NumPy时，最好遵循如下格式： 1import numpy as np ndarrayndarray是一个n维数组对象，其中的所有元素必须是相同类型的值。 ndarray常见属性： shape：表示各个维度大小的元组 dtype：表示数组数据类型的对象 通过NumPy中的array()函数，即可将一切序列型的对象转换为NumPy中的数组。 示例： 1234import numpy as npdata = np.array([[1,2,4,5],[1.1,23,1234,5]])print(data.shape)print(data.dtype) 算术运算NumPy中的ndarray支持逐元素的算术运算+、-、*、/、%和//等。 12345678910111213141516import numpy as npdata1 = np.array([[1,2,3],[4,5,6],[7,8,9]])data2 = np.array([[11,21,31],[41,51,61],[71,81,91]])print('data1和data2逐元素相加：')print(data1 + data2)print('data1和data2逐元素相减：')print(data2 - data1)print('data1和data2逐元素相乘：')print(data1 * data2)print('data2和data1逐元素相除：')print(data2 / data1)print('data2和data1逐元素相除取余：')print(data2 % data1)print('data2和data1逐元素相除取商：')print(data2 // data1) 输出： 123456789101112131415161718192021222324data1和data2逐元素相加：[[ 12 23 34] [ 45 56 67] [ 78 89 100]]data1和data2逐元素相减：[[10 19 28] [37 46 55] [64 73 82]]data1和data2逐元素相乘：[[ 11 42 93] [164 255 366] [497 648 819]]data2和data1逐元素相除：[[11. 10.5 10.33333333] [10.25 10.2 10.16666667] [10.14285714 10.125 10.11111111]]data2和data1逐元素相除取余：[[0 1 1] [1 1 1] [1 1 1]]data2和data1逐元素相除取商：[[11 10 10] [10 10 10] [10 10 10]] 将NumPy中的ndarray转换为Python中的list使用ndarray的tolist()函数，可以将NumPy数组转换为Python中的list 123456import numpy as npdata = np.array([[1,2,4,5],[1.1,23,1234,5]])print(type(data))ls = data.tolist()print(ls)print(type(ls)) 输出： 123&lt;class 'numpy.ndarray'&gt;[[1.0, 2.0, 4.0, 5.0], [1.1, 23.0, 1234.0, 5.0]]&lt;class 'list'&gt; 数组复制使用ndarray的copy()方法，可以创建数组副本。 123456import numpy as npdata = np.array([[1,2,4,5],[12,23,1234,5]])x = data.copy()print(x is data)print(x == data) 输出： 123False[[ True True True True] [ True True True True]] zeros, ones除了可以使用array()函数创建数组外，还可以使用zeros、ones来创建数组。 接受参数： 表示维度大小的元组shape 表示数据类型的dtype 返回：一个指定维度且元素值全为0或1的数组 示例： 1234567import numpy as np# 创建一个１行３列的全0数组print(np.zeros(3))# 创建一个３行3列的全0数组print(np.zeros((3,3)))print(np.ones(3)) 输出结果： 12345[0. 0. 0.][[0. 0. 0.] [0. 0. 0.] [0. 0. 0.]][1. 1. 1.] 可以看到，如果我们只传入一个数字n，则会创建一个1xn的数组。 shapeshape()函数用于测量NumPy中数组、矩阵等的维度，返回一个表示维度的元组。 示例： 12345678import numpy as npprint(np.shape([[1, 2]]))print(np.shape([0]))data = np.array([[[1,2,3],[1,2,3]], [[4,5,6],[7,8,9]]])print(np.shape(data))print(data.shape) 输出： 1234(1, 2)(1,)(2, 2, 3)(2, 2, 3) full函数原型： 1full(shape, fill_value, dtype=None, order='C') shape：数组的维度 fill_value：填充的值 dtype：指定的数据类型 示例： 123import numpy as npprint(np.full((2,2),1.)) 输出： 12[[1. 1.] [1. 1.]] 广播broadcast_to函数原型： 1broadcast_to(array, shape, subok=False) array：待广播的数组 shape：期望的维度（用元组表示） 示例： 1234import numpy as npx = np.array([1,2,3,4])print(np.broadcast_to(x, (2,4))) 输出： 12[[1 2 3 4] [1 2 3 4]] tile函数原型： 1tile(A, reps) 沿着每个轴，将数组中的元素重复指定次数。 https://docs.scipy.org/doc/numpy/reference/generated/numpy.tile.html 示例： 12345import numpy as npx = np.array([1,2,3,4])print(np.tile(x,3))print(np.tile(x,(2,2))) 输出： 123[1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4][[1 2 3 4 1 2 3 4] [1 2 3 4 1 2 3 4]] eyeeye()函数用于创建一个指定大小的单位数组(类似于线性代数中的单位矩阵)。 接受参数：一个表示维度大小的整数 示例： 12import numpy as npnp.eye(3) 输出： 123array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) arangearange()函数类似于python中的range()，但它返回的是一个NumPy数组。 12import numpy as npnp.arange(5) 输出： 1array([0, 1, 2, 3, 4]) matmat()函数用于创建矩阵。 randomseed设置随机数生成器种子。保证每次运行，生成的随机数相同。 randint函数原型： 1numpy.random.randint(low, high=None, size=None, dtype='l') 返回一个或者多个随机整数，范围从低（包括）到高（不包括），即[low, high)。如果没有写参数high的值，则返回[0,low)的值。 shuffle打乱ndarray中数据的顺序。 保存/加载NumPy对象要想保存NumPy对象，可以使用numpy.save()方法 123import numpy as npnp.save(np.ones((1,)),'./test.npy') 加载保存在本地的NumPy对象，可以使用numpy.load()方法 123import numpy as npnp.load('./test.npy')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java位运算符]]></title>
    <url>%2F2018%2F06%2F16%2Fjava-bitwise-operation%2F</url>
    <content type="text"><![CDATA[在讲位运算符之前，我们先来回顾下本科时学过的一些计算机基础知识。 所谓原码就是二进制定点表示法，即最高位为符号位，正数为0，负数为1，其余位表示数值的大小。 反码：正数的反码与其原码相同，负数的反码是其原码逐位求反（符号位除外）。 补码：正数的补码与其原码相同，负数的补码为其反码加1。 整数在内存中是以补码的形式存储的。 一个简单的例子： 5的原码、补码、反码为$$原码：0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0101 \\反码：0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0101 \\补码：0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0101$$-4的原码、补码、反码为：$$原码：1000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0100 \\反码：1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1011 \\补码：1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1100$$ 反过来，已知补码如何求原码呢？ 已知补码如下，求其十进制表示？$$1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1000$$先通过补码求得反码，即补码减去1$$\ 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1000 \\\underline{- 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0001} \\= 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 0111$$除最高位（符号位）外，其他位按位求反，就得到了原码$$(1000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 1000)_2 = -8$$有了上面这些知识，位运算就很容易理解了。 按位与&amp;按位与运算的运算符是“&amp;”，是双目运算符。如果两个操作数对应位都是1，则结果位为1，否则为0。 示例：5 &amp; -4 = 4$$5的补码\\\overbrace {0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0101} \\\&amp; \\\underbrace{1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1100 } \\-4的补码 \\\Downarrow \\\underbrace{0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0100} \\5\&amp;-4的结果为十进制整数4$$ 按位或|按位与运算的运算符是“|”，是双目运算符。如果两个操作数对应位都是0，则结果才是0，否则为1。 示例：3 | 6 = 7$$3的补码 \\\overbrace {0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0011} \\| \\\underbrace{0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0110} \\6的补码 \\\Downarrow \\\underbrace{0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0111} \\3 | 6的结果为十进制整数7$$ 按位非~按位非运算，也称“按位取反”运算，运算符为“~”，是单目运算符。 运算法则：将操作数二进制中的1全部修改为0，0全部改为1 示例：~7 = -8$$7的补码\\\overbrace {0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0111} \\\Downarrow \\\underbrace{1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1111 \quad 1111 \ 1000} \\\sim7的结果为十进制整数-8$$ 按位异或^按位异或运算的运算符是“^”，是双目运算符。 运算法则：当两个操作数的二进制表示相同（同为0或同为1）时，结果为0，否则为1。 示例：7^3 = 4$$7的补码 \\\overbrace{0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0111} \\ \wedge \\\underbrace{0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0011} \\3的补码 \\\Downarrow \\\underbrace{0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0000 \quad 0000 \ 0100} \\7^{\wedge} 3的结果为十进制整数4$$ 移位运算符Java语言中的移位运算符有3种，其操作的数据类型只有byte、short、char、int和long5种类型。 左移运算符&lt;&lt;。左移空出的位置补0。 如12&lt;&lt;1 = 24： $$\quad \quad \quad \underline{0 \quad 0 \quad 0 \quad 0 \quad 1 \quad 1 \quad 0 \quad 0 }\\\quad 抛弃 \rightarrow 0 \quad \underline{0 \quad 0\quad 0\quad 1 \quad 1\quad 0\quad 0} \quad 0 \leftarrow 补零 \\结果为 2^{4}+2^{3} = 24$$ 右移运算符&gt;&gt;。如果最高位为0，则右移空出的位置补0；如果最高位为1，空出的位置补1。 如12&gt;&gt;1 = 6： $$\underline{0 \quad 0\quad 0\quad 0\quad 1\quad 1\quad 0 \quad 0 }\\\quad 补零\rightarrow 0 \quad \underline{0 \quad 0 \quad 0\quad 0\quad 1 \quad 1\quad 0} \quad 0 \leftarrow 抛弃\\结果为 2^{2}+2^{1} = 6$$ 无符号右移运算符&gt;&gt;&gt;。不管最高位是0还是1，右移空出的位置都补0。 简单来说，一个数左移n位，相当于这个数乘以2的n次方；右移n位，相当于除以2的n次方。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的进制表示]]></title>
    <url>%2F2018%2F06%2F10%2Fjava-binary-octal-decimal-hexadecimal%2F</url>
    <content type="text"><![CDATA[平时做题也好，写程序或算法也罢，我们经常会见到诸如0Xfff、0b1000等数据，那么它们到底是什么意思呢？ 其实0x、0b等是不同进制的前缀，旨在告诉编译器后面的数字是几进制的数据，而非默认的十进制数据。 二进制（binary）：以0b或者0B为前缀，例如0b1000，等价于十进制的$1*2^3$=8 需要注意的是，0b（0B）这种写法是从jdk1.7才有的 八进制（octal）：以0为前缀，例如：070，等价于十进制的$7*8^1+0*8$=56 十进制（decimal）：没有前缀，默认情况下数字均为十进制表示 十六进制（hexadecimal）：以0x或者0X为前缀，例如算法中很常见的0xfff 上面的0是数字0，而不是字母o 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; int binary1 = 0b1000;//8 System.out.println(binary1); int binary2 = 0B111;//7 System.out.println(binary2); int octal = 070;//56 System.out.println(octal); int hexadecimal = 0xfff;//4095 System.out.println(hexadecimal); &#125;&#125; 输出结果： 123487564095]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构(C/C++版)之单链表的实现]]></title>
    <url>%2F2018%2F06%2F07%2Fdata-structure-singlelinkedlist-in-c-or-c%2F</url>
    <content type="text"><![CDATA[用C/C++实现的单链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;/*以下所有方法中的index从1开始，而不是0. */typedef struct Node&#123; ElemType data; struct Node * next;&#125; LinkedList;//单链表//如果参数写为LinkedList * list，并不会改变实参的值，但可以改变实参指针变量所指向的变量的值//初始化单链表void init(LinkedList * &amp;list)&#123; list = (LinkedList *) malloc(sizeof(LinkedList)); list-&gt;next = NULL;&#125;//是否为空bool isEmpty(LinkedList * list)&#123; return list-&gt;next == NULL;&#125;//输出单链表void print(LinkedList * list)&#123; LinkedList * p = list-&gt;next; while(p!=NULL) &#123; printf("%d ",p-&gt;data); p=p-&gt;next; &#125; printf("\n");&#125;//计算单链表长度，头结点不算在内int length(LinkedList * list)&#123; int count = 0; LinkedList * p = list; while(p-&gt;next!=NULL) &#123; count++; p = p-&gt;next; &#125; return count;&#125;/*//判断index是否为正确的位置索引，索引号从1开始到length(list)static bool isPositionIndex(LinkedList * list,int index) &#123; if(index &gt; 0 &amp;&amp; index &lt;= length(list)) return true; else return false;&#125;//判断index是否为正确的可添加结点的位置索引，索引号从1开始到length(list)+1static bool isPositionIndexForAdd(LinkedList * list,int index) &#123; if(index &gt; 0 &amp;&amp; index &lt;= length(list) + 1) return true; else return false;&#125;*///在单链表尾部添加结点bool add(LinkedList * &amp;list,ElemType e)&#123; LinkedList * p,* last = list; while(last-&gt;next!=NULL) &#123; last = last-&gt;next; &#125; p = (LinkedList *)malloc(sizeof(LinkedList)); p-&gt;data = e; p-&gt;next = NULL; last-&gt;next = p; return true;&#125;//在索引位置为index处插入新的结点//下面的写法，只遍历了一次单链表bool add(LinkedList * &amp;list,int index,ElemType e)&#123; int count = 0; LinkedList * newNode,* p = list; while(p != NULL &amp;&amp; count &lt; index - 1)//找到index结点的前一个结点 &#123; count++; p = p-&gt;next; &#125; if(p == NULL)//不存在第index-1个结点 return false; else &#123; newNode = (LinkedList *)malloc(sizeof(LinkedList)); newNode-&gt;data = e; newNode-&gt;next = p-&gt;next; p-&gt;next = newNode; return true; &#125;&#125;/*//下面的写法， 遍历了两遍单链表bool add(LinkedList * &amp;list,int index,ElemType e)&#123; //判断给定的index是否合理 if(!isPositionIndexForAdd(list,index)) return false; int count = 0; LinkedList * newNode,* p = list; while(p != NULL &amp;&amp; count &lt; index - 1)//找到index结点的前一个结点 &#123; count++; p = p-&gt;next; &#125; newNode = (LinkedList *)malloc(sizeof(LinkedList)); newNode-&gt;data = e; newNode-&gt;next = p-&gt;next; p-&gt;next = newNode; return true;&#125;*///获取单链表中位置索引为index的元素，并将值赋给e//只遍历一次bool get(LinkedList * list,int index,ElemType &amp;e)&#123; LinkedList * p = list-&gt;next; int count = 1; while(p != NULL &amp;&amp; count &lt; index) &#123; count++; p = p-&gt;next; &#125; if(p == NULL)//不存在第index个结点 return false; else &#123; e = p-&gt;data; return true; &#125;&#125;/*//需要遍历两次单链表bool get(LinkedList * list,int index,ElemType &amp;e)&#123; if(!isPositionIndex(list,index)) return false; LinkedList * p = list-&gt;next; int count = 1; while(p != NULL &amp;&amp; count &lt; index) &#123; count++; p = p-&gt;next; &#125; e = p-&gt;data; return true;&#125;*//*//另一种更简洁的写法ElemType get(LinkedList * list,int index)&#123; LinkedList * p = list-&gt;next; int count = 1; while(p != NULL &amp;&amp; count &lt; index) &#123; count++; p = p-&gt;next; &#125; if(p == NULL)//不存在第index个结点 return NULL; else return p-&gt;data;&#125; *///删除最后一个结点bool remove(LinkedList * &amp;list,ElemType &amp;e)&#123; LinkedList * oldNode,* p = list; if(p-&gt;next == NULL) return false; while(p-&gt;next-&gt;next != NULL)//找最后一个结点的前驱结点 &#123; p = p-&gt;next; &#125; oldNode = p-&gt;next; e =oldNode-&gt;data; p-&gt;next = NULL; free(oldNode); return true;&#125;//删除第index个结点bool remove(LinkedList * &amp;list,int index,ElemType &amp;e)&#123; int count = 0; LinkedList * oldNode, * p = list; while(p != NULL &amp;&amp; count &lt; index - 1)//找到第index-1个结点 &#123; count++; p = p-&gt;next; &#125; if(p == NULL)//不存在第index-1个结点 return false; else &#123; oldNode = p-&gt;next; //这里需要特别注意，必须判断oldNode是否为NULL if(oldNode == NULL) return false; e = oldNode-&gt;data; p-&gt;next = oldNode-&gt;next; free(oldNode); return true; &#125;&#125;//在单链表中元素e首次出现的位置 ，若不存在，则返回-1int indexOf(LinkedList * list,ElemType e)&#123; int count = 1; LinkedList * p = list-&gt;next; while(p != NULL &amp;&amp; p-&gt;data != e) &#123; count++; p = p-&gt;next; &#125; if(p == NULL) return -1; else return count;&#125;//销毁单链表void destroy(LinkedList * &amp;list)&#123; LinkedList * pre = list,* p = list-&gt;next; while(p!=NULL) &#123; free(pre); pre = p; p = p-&gt;next; &#125; free(pre);&#125; 测试程序： 123456789101112131415161718192021222324252627typedef int ElemType;//声明LinkedList.h中的ElemType为int类型#include &lt;stdio.h&gt;#include "LinkedList.h"//包含头文件时，尖括号用于引入系统库，自己定义的头文件，需要使用引号引入int main() &#123; LinkedList * list; init(list); add(list,20); add(list,20); add(list,21); add(list,22); add(list,23); add(list,2,100); printf("长度：%d\n",length(list)); print(list); ElemType e; if(get(list,4,e)) printf("第4个结点的值为：%d\n",e); printf("100首次出现的位置为：%d\n",indexOf(list,100)); if(remove(list,3,e)) printf("第3个结点的值为：%d\n",e); if(remove(list,e)) printf("最后一个结点的值为：%d\n",e); print(list); destroy(list); return 0;&#125; 输出结果： 1234567长度：620 100 20 21 22 23 第4个结点的值为：21100首次出现的位置为：2第3个结点的值为：20最后一个结点的值为：2320 100 21 22]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201803-3.URL映射]]></title>
    <url>%2F2018%2F06%2F06%2Fccf-csp-20180303%2F</url>
    <content type="text"><![CDATA[问题描述 URL 映射是诸如 Django、Ruby on Rails 等网页框架 (web frameworks) 的一个重要组件。对于从浏览器发来的 HTTP 请求，URL 映射模块会解析请求中的 URL 地址，并将其分派给相应的处理代码。现在，请你来实现一个简单的 URL 映射功能。 本题中 URL 映射功能的配置由若干条 URL 映射规则组成。当一个请求到达时，URL 映射功能会将请求中的 URL 地址按照配置的先后顺序逐一与这些规则进行匹配。当遇到第一条完全匹配的规则时，匹配成功，得到匹配的规则以及匹配的参数。若不能匹配任何一条规则，则匹配失败。 本题输入的 URL 地址是以斜杠 / 作为分隔符的路径，保证以斜杠开头。其他合法字符还包括大小写英文字母、阿拉伯数字、减号 -、下划线 _ 和小数点 .。例如，/person/123/ 是一个合法的 URL 地址，而 /person/123? 则不合法（存在不合法的字符问号 ?）。另外，英文字母区分大小写，因此 /case/ 和 /CAse/ 是不同的 URL 地址。 对于 URL 映射规则，同样是以斜杠开始。除了可以是正常的 URL 地址外，还可以包含参数，有以下 3 种： 字符串 &lt;str&gt;：用于匹配一段字符串，注意字符串里不能包含斜杠。例如，abcde0123。 整数 &lt;int&gt;：用于匹配一个不带符号的整数，全部由阿拉伯数字组成。例如，01234。 路径 &lt;path&gt;：用于匹配一段字符串，字符串可以包含斜杠。例如，abcd/0123/。 以上 3 种参数都必须匹配非空的字符串。简便起见，题目规定规则中 &lt;str&gt; 和 &lt;int&gt; 前面一定是斜杠，后面要么是斜杠，要么是规则的结束（也就是该参数是规则的最后一部分）。而 &lt;path&gt; 的前面一定是斜杠，后面一定是规则的结束。无论是 URL 地址还是规则，都不会出现连续的斜杠。 输入格式 输入第一行是两个正整数 n 和 m，分别表示 URL 映射的规则条数和待处理的 URL 地址个数，中间用一个空格字符分隔。 第 2 行至第 n+1 行按匹配的先后顺序描述 URL 映射规则的配置信息。第 i+1 行包含两个字符串 pi 和 ri，其中 pi 表示 URL 匹配的规则，ri 表示这条 URL 匹配的名字。两个字符串都非空，且不包含空格字符，两者中间用一个空格字符分隔。 第 n+2 行至第 n+m+1 行描述待处理的 URL 地址。第 n+1+i 行包含一个字符串 qi，表示待处理的 URL 地址，字符串中不包含空格字符。 输出格式 输入共 m 行，第 i 行表示 qi 的匹配结果。如果匹配成功，设匹配了规则 pj ，则输出对应的 rj。同时，如果规则中有参数，则在同一行内依次输出匹配后的参数。注意整数参数输出时要把前导零去掉。相邻两项之间用一个空格字符分隔。如果匹配失败，则输出 404。 样例输入 5 4/articles/2003/ special_case_2003/articles/&lt;int&gt;/ year_archive/articles/&lt;int&gt;/&lt;int&gt;/ month_archive/articles/&lt;int&gt;/&lt;int&gt;/&lt;str&gt;/ article_detail/static/&lt;path&gt; static_serve/articles/2004//articles/1985/09/aloha//articles/hello//static/js/jquery.js 样例输出 year_archive 2004article_detail 1985 9 aloha404static_serve js/jquery.js 样例说明 对于第 1 个地址 /articles/2004/，无法匹配第 1 条规则，可以匹配第 2 条规则，参数为 2004。 对于第 2 个地址 /articles/1985/09/aloha/，只能匹配第 4 条规则，参数依次为 1985、9（已经去掉前导零）和 aloha。 对于第 3 个地址 /articles/hello/，无法匹配任何一条规则。 对于第 4 个地址 /static/js/jquery.js，可以匹配最后一条规则，参数为 js/jquery.js。 数据规模和约定 1 ≤ n ≤ 100，1 ≤ m ≤ 100。 所有输入行的长度不超过 100 个字符（不包含换行符）。 保证输入的规则都是合法的。 分析： 若使用常规的字符串操作，解决本题将十分困难。因此，下面采用正则表达式求解。 主要的思路为：将输入规则中的&lt;int&gt;、&lt;str&gt;和&lt;path&gt;替换为对应的正则表达式(\\d+)、([-\\w\\.]+)和(.+)。这里的括号，表示正则表达式中的分组，便于后续输出匹配的各个参数。 C++版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;regex&gt;using namespace std;typedef struct Node &#123; // URL规则 string rule; // 规则的名字 string name; Node(string _rule, string _name) &#123; rule = _rule; name = _name; &#125;&#125; UrlMapping;bool match(UrlMapping urlMapping, string url) &#123; smatch result; // 若不匹配 if (!regex_match(url, result, regex(urlMapping.rule))) &#123; return false; &#125; cout &lt;&lt; urlMapping.name; for (int i = 1; i &lt; result.size(); i++) &#123; // 若为数字，则去掉前导零 if (regex_match(result.str(i), regex("\\d+"))) &#123; cout &lt;&lt; ' ' &lt;&lt; stoi(result.str(i)); &#125; else &#123; cout &lt;&lt; ' ' &lt;&lt; result.str(i); &#125; &#125; cout &lt;&lt; endl; return true;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;UrlMapping&gt; mappings; string rule, name; while (n--) &#123; cin &gt;&gt; rule &gt;&gt; name; // 将&lt;int&gt;、&lt;str&gt;和&lt;path&gt;替换为对应的正则表达式 rule = regex_replace(rule, regex("&lt;int&gt;"), "(\\d+)"); rule = regex_replace(rule, regex("&lt;str&gt;"), "([-\\w\\.]+)"); rule = regex_replace(rule, regex("&lt;path&gt;"), "(.+)"); mappings.push_back(UrlMapping(rule, name)); &#125; string url; while (m--) &#123; cin &gt;&gt; url; bool find = false; // 暴力搜索匹配的URL规则 for (int i = 0; i &lt; mappings.size(); i++) &#123; if (match(mappings[i], url)) &#123; find = true; break; &#125; &#125; // 若未找到匹配的URL规则 if (!find) &#123; cout &lt;&lt; 404 &lt;&lt; endl; &#125; &#125; return 0;&#125; Java版 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.Scanner;import java.util.regex.Matcher;import java.util.regex.Pattern;public class Main &#123; static class UrlMapping &#123; // URL规则 String rule; // 规则的名字 String name; public UrlMapping(String rule, String name) &#123; this.rule = rule; this.name = name; &#125; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int m = scan.nextInt(); UrlMapping[] mappings = new UrlMapping[n]; for (int i = 0; i &lt; mappings.length; i++) &#123; // 由于\为转义字符，要在字符串中表示普通的\，需要使用\\，因此\\d+需要表示为\\\\d+ String rule = scan.next().replaceAll("&lt;int&gt;", "(\\\\d+)") .replaceAll("&lt;str&gt;", "([-\\\\w\\\\.]+)") .replaceAll("&lt;path&gt;", "(.+)"); // 由于Matcher类的find()方法为部分匹配（只要有一个子串满足正则表达式即可）, // 因此加上^和$表示url需要整体匹配(整个字符串满足正则表达式) rule = '^' + rule + '$'; mappings[i] = new UrlMapping(rule, scan.next()); &#125; for (int i = 0; i &lt; m; i++) &#123; String url = scan.next(); boolean flag = false; // 暴力搜索匹配的URL规则 for (UrlMapping urlMapping : mappings) &#123; if (matches(urlMapping, url)) &#123; flag = true; break; &#125; &#125; // 若未找到匹配的URL规则 if (!flag) &#123; System.out.println(404); &#125; &#125; scan.close(); &#125; private static boolean matches(UrlMapping urlMapping, String url) &#123; Pattern p = Pattern.compile(urlMapping.rule); Matcher m = p.matcher(url); // 若不匹配 if (!m.find()) &#123; return false; &#125; System.out.print(urlMapping.name); for (int i = 1; i &lt;= m.groupCount(); i++) &#123; String str = m.group(i); // 若为数字，则去掉前导零 if (str.matches("\\d+")) &#123; System.out.print(" " + Integer.parseInt(str)); &#125; else &#123; System.out.print(" " + str); &#125; &#125; System.out.println(); return true; &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201803-2 碰撞的小球]]></title>
    <url>%2F2018%2F06%2F06%2Fccf-csp-20180302%2F</url>
    <content type="text"><![CDATA[问题描述 数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。 当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。 当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。 现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。 提示 因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。 同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。 输入格式 输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。 第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。 输出格式 输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。 样例输入 3 10 54 6 8 样例输出 7 9 9 样例说明 初始时，三个小球的位置分别为4, 6, 8。 一秒后，三个小球的位置分别为5, 7, 9。 两秒后，第三个小球碰到墙壁，速度反向，三个小球位置分别为6, 8, 10。 三秒后，第二个小球与第三个小球在位置9发生碰撞，速度反向（注意碰撞位置不一定为偶数），三个小球位置分别为7, 9, 9。 四秒后，第一个小球与第二个小球在位置8发生碰撞，速度反向，第三个小球碰到墙壁，速度反向，三个小球位置分别为8, 8, 10。 五秒后，三个小球的位置分别为7, 9, 9。 样例输入 10 22 3014 12 16 6 10 2 8 20 18 4 样例输出 6 6 8 2 4 0 4 12 10 2 数据规模和约定 对于所有评测用例，1 ≤ n ≤ 100，1 ≤ t ≤ 100，2 ≤ L ≤ 1000，0 &lt; ai &lt; L。L为偶数。 保证所有小球的初始位置互不相同且均为偶数。 C++版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n, l, t; scanf("%d %d %d", &amp;n, &amp;l, &amp;t); int arr[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; // 默认向右移动 int directions[n]; fill(directions, directions + n, 1); int lastPos[n]; // 执行t次 for (int i = 0; i &lt; t; i++) &#123; // 上一次小球的位置 memcpy(lastPos, arr, sizeof(arr)); for (int j = 0; j &lt; n; j++) &#123; // 若小球位于左端点，且不是初始时刻，则需要改变方向 if (lastPos[j] == 0) &#123; if (i &gt; 0) &#123; directions[j] = -directions[j]; &#125; &#125; else if (lastPos[j] == l) &#123; // 若小球位于右端点，则需要改变方向 directions[j] = -directions[j]; &#125; else &#123; for (int k = 0; k &lt; n; k++) &#123; if (j != k &amp;&amp; lastPos[j] == lastPos[k]) &#123; directions[j] = -directions[j]; break; &#125; &#125; &#125; arr[j] += directions[j]; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (i &gt; 0) &#123; printf(" "); &#125; printf("%d", arr[i]); &#125; printf("\n"); return 0;&#125; Java版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.Arrays;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int l = scan.nextInt(); int t = scan.nextInt(); int[] arr = new int[n]; for (int i = 0; i &lt; n; i++) &#123; arr[i] = scan.nextInt(); &#125; // 默认向右移动 int[] directions = new int[n]; Arrays.fill(directions, 1); int[] lastPos = new int[n]; // 执行t次 for (int i = 0; i &lt; t; i++) &#123; lastPos = Arrays.copyOf(arr, arr.length); for (int j = 0; j &lt; lastPos.length; j++) &#123; // 若小球位于左端点，且不是初始时刻，则需要改变方向 if (lastPos[j] == 0) &#123; if (i &gt; 0) &#123; directions[j] = -directions[j]; &#125; &#125; else if (lastPos[j] == l) &#123; // 若小球位于右端点，则需要改变方向 directions[j] = -directions[j]; &#125; else &#123; // 否则，判断是否发生了碰撞 for (int k = 0; k &lt; lastPos.length; k++) &#123; // 若发生了碰撞，则需要改变方向 if (j != k &amp;&amp; lastPos[j] == lastPos[k]) &#123; directions[j] = -directions[j]; break; &#125; &#125; &#125; arr[j] += directions[j]; &#125; &#125; scan.close(); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; arr.length; i++) &#123; if (i &gt; 0) &#123; sb.append(' '); &#125; sb.append(arr[i]); &#125; System.out.println(sb.toString()); &#125;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF CSP 201803-1.跳一跳]]></title>
    <url>%2F2018%2F06%2F05%2Fccf-csp-20180301%2F</url>
    <content type="text"><![CDATA[问题描述 近来，跳一跳这款小游戏风靡全国，受到不少玩家的喜爱。 简化后的跳一跳规则如下：玩家每次从当前方块跳到下一个方块，如果没有跳到下一个方块上则游戏结束。 如果跳到了方块上，但没有跳到方块的中心则获得1分；跳到方块中心时，若上一次的得分为1分或这是本局游戏的第一次跳跃则此次得分为2分，否则此次得分比上一次得分多两分（即连续跳到方块中心时，总得分将+2，+4，+6，+8…）。 现在给出一个人跳一跳的全过程，请你求出他本局游戏的得分（按照题目描述的规则）。 输入格式 输入包含多个数字，用空格分隔，每个数字都是1，2，0之一，1表示此次跳跃跳到了方块上但是没有跳到中心，2表示此次跳跃跳到了方块上并且跳到了方块中心，0表示此次跳跃没有跳到方块上（此时游戏结束）。 输出格式 输出一个整数，为本局游戏的得分（在本题的规则下）。 样例输入 1 1 2 2 2 1 1 2 2 0 样例输出 22 数据规模和约定 对于所有评测用例，输入的数字不超过30个，保证0正好出现一次且为最后一个数字。 1234567891011121314151617181920#include &lt;cstdio&gt;int main() &#123; int data; // 得分 int score = 0; // 当前是第几个2 int position = 0; while (scanf("%d", &amp;data), data != 0) &#123; if (data == 1) &#123; score += 1; position = 0; &#125; else if (data == 2) &#123; position++; score += position * 2; &#125; &#125; printf("%d\n", score); return 0;&#125;]]></content>
      <categories>
        <category>ccf csp</category>
      </categories>
      <tags>
        <tag>ccf csp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构(C/C++版)之动态顺序表的实现]]></title>
    <url>%2F2018%2F06%2F03%2Fdata-structure-sqlist-in-c-or-c%2B%2B%2F</url>
    <content type="text"><![CDATA[写在前面的话：类似如下函数：bool add(SqList &amp;list, int i, ElemType e)c语言没有bool关键字，c++才有，若需要在c语言中使用，需要引入&lt;stdbool.h&gt;（或者自己定义）.另外，函数参数中&amp;符号，表示引用，c语言也没有（c语言中的&amp;表示取地址符），这是c++才有的语法，若需要在c语言中实现类似功能，即改变实参的值，只能采用指针实现 用C/C++实现的动态顺序表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;stdlib.h&gt;#define DEFAULT_CAPACITY 10 //默认容量#define DEFAULT_INCREMENT_SIZE 1 //默认扩容大小typedef struct &#123; ElemType * data;//存储元素的一维数组 int length; //顺序表当前的长度 int size; //顺序表的容量 int incrementSize; //增补空间大小&#125; SqList;//初始化，需要注意的是：给参数设置默认值，c语言没有这种语法void init(SqList &amp;list, int capacity = DEFAULT_CAPACITY, int incrementSize = DEFAULT_INCREMENT_SIZE) &#123; list.data = (ElemType *) malloc(capacity * sizeof(ElemType)); if (!list.data) &#123; exit(1); &#125; list.length = 0; list.size = capacity; list.incrementSize = incrementSize;&#125;bool isEmpty(SqList list) &#123; return list.length == 0;&#125;//求顺序表的长度int length(SqList list) &#123; return list.length;&#125;//元素首次出现的位置int indexOf(SqList list, ElemType e) &#123; for (int i = 0; i &lt; list.length; i++) &#123; if (list.data[i] == e) &#123; return i; &#125; &#125; return -1;&#125;//元素最后一次出现的位置int lastIndexOf(SqList list, ElemType e) &#123; for (int i = list.length - 1; i &gt;= 0; i--) &#123; if (list.data[i] == e) &#123; return i; &#125; &#125; return -1;&#125;/* * static关键字的作用类似于Java中private，声明为内部函数，只能在本文件中使用 * 另外需要注意的是，该函数必须放在引用之前，否则，编译时会报错 */static bool isElementIndex(SqList list, int i) &#123; return (i &gt;= 0 &amp;&amp; i &lt; list.length) ? true : false;&#125;static bool isPositionIndex(SqList list, int i) &#123; return (i &gt;= 0 &amp;&amp; i &lt;= list.length) ? true : false;&#125;static void ensureCapacity(SqList &amp;list) &#123; //扩容 if (list.length &gt;= list.size) &#123; list.data = (ElemType *) realloc(list.data, (list.size + list.incrementSize) * sizeof(ElemType)); //判断存储空间是否分配成功 if (!list.data) &#123; exit(1); &#125; list.size += list.incrementSize; //增加当前存储容量 &#125;&#125;//在顺序表中指定索引处插入元素bool add(SqList &amp;list, int i, ElemType e) &#123; if (!isPositionIndex(list, i)) &#123; return false; &#125; ensureCapacity(list); for (int j = list.length; j &gt; i; j--) &#123; list.data[j] = list.data[j - 1]; &#125; list.data[i] = e; //??? list.length++; return true;&#125;//在顺序表的最后面添加元素bool add(SqList &amp;list, ElemType e) &#123; //扩容 ensureCapacity(list); list.data[list.length] = e; list.length++; return true;&#125;//删除最后一个元素bool remove(SqList &amp;list, ElemType &amp;e) &#123; if (isEmpty(list)) &#123; return false; &#125; e = list.data[list.length - 1]; list.length--; return true;&#125;//删除指定索引处的元素bool remove(SqList &amp;list, int i, ElemType &amp;e) &#123; if (!isElementIndex(list, i) || isEmpty(list)) &#123; return false; &#125; e = list.data[i]; for (int j = i + 1; j &lt;= list.length - 1; j++) &#123; list.data[j - 1] = list.data[j]; &#125; list.length--; return true;&#125;//取元素bool get(SqList list, int i, ElemType &amp;e) &#123; if (!isElementIndex(list, i)) &#123; return false; &#125; e = list.data[i]; return true;&#125;//遍历输出void print(SqList list) &#123; for (int i = 0; i &lt; list.length; i++) &#123; printf("%d\n", list.data[i]); &#125;&#125;//销毁void destroy(SqList &amp;list) &#123; free(list.data); list.length = 0; list.incrementSize = 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言中的动态内存分配]]></title>
    <url>%2F2018%2F06%2F01%2Fc-dynamic-memory-allocation%2F</url>
    <content type="text"><![CDATA[简介全局变量是分配在内存中的静态存储区的，非静态的局部变量是分配在内存中的动态存储区的，这个存储区是一个称为栈（stack）的区域。 除此以外，C语言还允许建立内存动态分配区域，以存放一些临时用的数据，这些数据不必在程序的声明部分定义，也不必等到函数结束时才释放，而是需要时随时开辟，不需要时随时释放。这些数据是临时存放在一个特别的自由存储区，称为堆（heap）区。由于未在声明部分定义它们为变量或数组，因此不能通过变量名或数组名去引用这些数据，只能通过指针来引用。 动态分配内存C语言中，对内存的动态分配，主要是通过malloc、calloc、free和realloc这四个函数实现。 1.malloc函数 函数原型为 1void * malloc(unsigned int size); 作用：在内存的动态存储区中分配一个长度为size的连续空间。 函数的返回值是所分配区域的第一个字节的地址。指针的基类型为void，即不能指向任何类型的数据，只提供一个地址。如果函数未能成功地执行，则返回空指针（NULL）。 示例 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; extern void check(int * p);//函数声明 int * p = (int *)malloc(5*sizeof(int));//开辟动态内存区，并将地址转换为int * 型 for(int i = 0; i &lt; 5;i++) &#123; scanf("%d",p+i); &#125; check(p); return 0;&#125;extern void check(int * p) &#123; printf("fail\n"); for(int i = 0 ; i &lt; 5;i++ ) &#123; if(p[i] &lt; 60) printf("%d",p[i]); &#125;&#125; 事实上，第5行中的代码也可以写成如下形式： 1int * p = malloc(5*sizeof(int));//由系统进行隐式的类型转换 推荐采用第一种写法，显式的强制转换，更加清楚直观。 另外，因为在不同系统中存放一个指定类型的字节数是不同的，为了使程序具有通用性，我在第5行中使用了sizeof运算符测定在本系统中整数的字节数。 (未完待续)]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法的时间复杂度和空间复杂度]]></title>
    <url>%2F2018%2F05%2F31%2Ftime-and-space-complexity%2F</url>
    <content type="text"><![CDATA[算法效率的度量是对算法所需要的时间和空间进行估算，分别称为时间复杂度和空间复杂度。 时间复杂度算法的时间效率称为算法的时间复杂度，它是问题规模n的某个函数，记作：T(n) = O(f(n))。 其中问题规模n是指输入量的多少，一般可以从问题描述中得到。如，数组元素的个数、矩阵的阶数等。f(n) 是问题规模n的某个函数。这里的O是Order的简写，意指数量级，表示随问题规模n的增大，算法执行时间的增长率和 f(n) 的增长率相同。 一个没有循环的算法基本运算次数与问题规模无关，记作O(1)，也称为常数阶。 常见的算法时间复杂度由小到大排列如下： O(1) &lt; O($\log_{2}n$) &lt; O(n) &lt; O($n\log_{2}n$) &lt; O($n^2$) &lt; O($n^3$) &lt; … &lt; O($c^n$) &lt; O(n!) 时间复杂度的计算 不带循环 1x++;//基本语句的执行次数为1，因此时间复杂度为O(1) 简单循环 1234int x = 0;//语句1，执行1次for( int i = 0 ; i &lt; n ; i++ ) &#123;//语句2，i从0开始到n，执行了n+1次 x+=i;//语句3，执行n次&#125; 因此，该算法的执行次数为T(n)=1+(n+1)+n=2n+2=O(n)，这种计算方式相对麻烦。 该算法的基本运算为循环中的语句3，它的执行次数为T(n)=n=O(n)。显然，这种计算方式比上面的简单得多，以后均采用这种方式分析算法的时间复杂度。 12345for(int i = 0 ; i &lt; n ; i++) &#123;//该循环执行n次 for(int j = 0; j &lt; n ;j++) &#123;//该循环执行n次 x++; &#125;&#125; 显然，该算法的基本运算为x++，其执行了$n^2$次，因此该算法的时间复杂度为O($n^2$)。 12345678void fun(int n) &#123; int x=0; for(int i = 1 ; i &lt; n ; i++) &#123;//该循环执行n-1次 for(int j = i + 1; j &lt;= n ;j++) &#123;//该循环执行n-(i+1)+1=n-i次 x++; &#125; &#125;&#125; 如何计算该算法的时间复杂度呢？ 显然，该算法的基本运算仍为x++，设x++语句执行次数为T(n)，则 $$T(n)=\sum_{i=1}^{n-1}\sum_{j=i+1}^n1=\sum_{i=1}^{n-1}(n-i)=\frac{n(n-1)}{2}=O(n^2)$$ 复杂循环 12345678void fun(int n) &#123; int m = 0; for(int i = 1 ; i &lt;= n ; i++) &#123; for(int j = 2*i ; j &lt;= n ;j++) &#123; m++; &#125; &#125;&#125; 该算法的基本运算为m++，设其执行次数为T(n)，如果按照上面的方法，则 $$T(n)=\sum_{i=1}^n\sum_{j=2i}^{n}1=\sum_{i=1}^{n}(n-2i+1)=(n+1)n-2\frac{n(n+1)}{2}=0$$ 显然，这种做法是错误的，因为内循环从2i到n，即 i 必须满足: 2i ≤ n =&gt; $i&lt;\frac{n}{2}$，因此正确的做法是： $$T(n) = \sum_{i=1}^{\frac{n}{2}}\sum_{j=2i}^{n}1=\sum_{i=1}^{\frac{n}{2}}(n-2i+1)=(n+1)\frac{n}{2}-2\sum_{i=1}^{\frac{n}{2}}i$$ $$=(n+1)\frac{n}{2}-2\frac{(\frac{n}{2}+1)\frac{n}{2}}{2}=\frac{n^2}{4}=O(n^2)$$ 需要递归 12345678910111213void fun(int a[],int n,int k) &#123; int i; if(k==n-1) &#123; for(i = 0 ; i &lt; n ; i++) &#123; printf("%d\n",a[i]); &#125; &#125; else &#123; for(i = k ; i &lt; n ; i++) &#123; a[i] = a[i] + i * i; &#125; fun(a,n,k+1); &#125;&#125; 如何求fun(a,n,0)的时间复杂度呢？ 设fun(a,n,k)的执行时间为T(n,k)，从而，fun(a,n,0)的执行时间为T(n)=T(n,0)。 $$T(n,k)=\begin{cases} n, &amp; \text {k=n-1} \\ (n-k)+T(n,k+1), &amp; \text{其他} \end{cases}$$ 则， T(n)=T(n,0)=n+T(n,1)=n+(n-1)+T(n,2)=…=n+(n-1)+…+2+T(n,n-1) =$\frac{(n+2)(n-1)}{2}+n=\frac{n^2}{2}+\frac{3n}{2}-1=O(n^2)$ 最好、最坏及平均时间复杂度实际上，算法效率不仅仅依赖于问题的规模n，还与问题的初始输入有关。例如: 12345678int fun(int a[],int n,int k) &#123;//该算法用于在给定的数组a[]中查找k for(int i = 0 ; i &lt; n ; i++) &#123; if(a[i] == k) &#123; return i; &#125; &#125; return -1;&#125; 循环体的执行次数，不仅与问题规模n有关，还与输入实例中a的各元素取值以及k的取值有关。在最坏的情况下，a中没有与k相等的元素，则循环体执行n次；在最好的情况下，a中的第一个元素a[0]等于K，则循环体执行1次。 故，该算法的最好时间复杂度为O(1)，最坏时间复杂度为O(n)。在这种情况下，可用最坏情况下的时间复杂度作为算法的时间复杂度，因为最坏情况下的时间复杂度是在任何输入实例上运行时间的上界。 当然，也可用平均时间复杂度来衡量算法，下面给出平均时间复杂度的定义： 设一个算法的输入规模为n，$D_n$是所有输入的集合，任一输入I∈$D_n$，p(I)是I出现的频率，有$\sum_{I∈D_n}P(I)=1$，T(I)是算法在输入I下所执行的基本运算次数，则该算法的平均时间复杂度为： $$T(n)=\sum_{I∈D_n}{P(I)·T(I)}$$ 显然，最坏时间复杂度为$$T(n)=\max_{I∈D_n}{T(I)}$$ 空间复杂度空间复杂度是对一个算法在运行过程中临时占用的存储空间大小的度量。 一个算法在执行过程中所需要的存储空间包括以下3个部分： 1.算法本身占用的空间，取决于算法的长度； 2.输入输出数据占用的空间，取决于问题规模，与算法无关； 3.辅助存储空间，即算法临时开辟的存储空间，与算法有关。 算法的空间复杂度是对算法的执行过程需要的辅助空间进行度量。通常记作 S(n) = O(f(n))，其中n为问题规模，f(n)为问题规模n的一个函数。 下面也举几个例子 12345678910111213141516void sort(int x[],int n) &#123;//该算法将一个数组按从大到小的顺序排序 int i,j,k,t; for(i = 0 ; i &lt; n-1 ; i++) &#123; k = i; for(j = i + 1 ; j &lt; n ; j++) &#123; if(x[j] &gt; x[k]) &#123; k=j; &#125; if(k != i) &#123; t = x[i]; x[i] = x[k]; x[k] = t; &#125; &#125; &#125;&#125; 这里定义了四个辅助变量，临时存储空间与问题规模n无关，故其空间复杂度为O(1)，时间复杂度为O($n^2$) 一般而言，如果不包含递归调用，则算法的空间复杂度为O(1) 123456789void mergesort(int a[],int i,int j) &#123; int m; if(i != j) &#123; m = (i+j)/2; mergesort(a,i,m); mergesort(a,m+1,j); merge(a,i,j,m);//假定merge是一个非递归函数，其内部只定义了一个辅助变量 &#125;&#125; 如何求mergesort(a，0，n-1)的空间复杂度呢？ 对于该算法，设mergesort(a，0，n-1)的临时空间大小为S(n)，其中定义了一个辅助变量m， $$S(n)=\begin{cases} O(1) , &amp; \text{n=1} \\ 2·S(\frac{n}{2})+1 , &amp; \text{n&gt;1} \end{cases}$$ 当n &gt; 1 时，S(n) = 2·S($\frac{n}{2}$) + 1 = 2 ( 2·S($\frac{n}{2^2}$) + 1) + 1=$2^2S(\frac{n}{4})$ + 1 + 2=$2^3S(\frac{n}{8})+1+2+2^2$ =…=$2^kS(\frac{n}{2^k})+\sum_{i=1}^{k}2^{i-1}$=$2^kO(1)+2^k-1$ 由于$\frac{n}{2^k}$ -&gt; 1，则k=$\log_{2}n$ 故S(n) = n + n - 1=2n-1，故该算法的空间复杂度为O(n)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言结构体]]></title>
    <url>%2F2018%2F05%2F31%2Fc-struct%2F</url>
    <content type="text"><![CDATA[C语言允许用户自己建立由不同类型数据组成的组合型的数据结构，它称为结构体。（类似于Java中的类） 定义结构体类型声明一个结构体类型的一般形式： 123struct 结构体名 &#123; 成员列表 &#125;; 对结构体中各成员都应进行类型声明，即 1类型名 成员名; 示例 12345struct Book &#123; char author[10]; char name[20]; double price;&#125;;//注意最后有一个分号 结构体的成员可以属于另一个结构体类型。例如： 1234567891011struct Date &#123; int year; int month; int day;&#125;;struct Book &#123; char author[10]; char name[20]; double price; struct Date publishTime;//成员publishTime属于struct Date类型&#125; 值得注意的是，结构体类型的名字是由关键字struct和结构体名组合而成的，即结构体类型 = struct 结构体名。 定义结构体类型变量C语言中定义结构体类型变量有三种方式。 1.先声明结构体类型，再定义该类型的变量（常用） 上面说到结构体内可以定义结构体类型的成员变量时，我的做法是先声明了一个结构体类型Struct Date，然后在声明Struct Book类型时，将成员变量publishTime指定为struct Date类型。下面再举一个例子说明 12345678910struct Date &#123; int year; int month; int day;&#125;;//声明struct Date类型int main() &#123; struct Date today;//定义struct Date类型的变量 ... return 0;&#125; 2.在声明类型的同时定义变量 这种定义的一般形式如下： 123struct 结构体名 &#123; 成员列表&#125; 变量名列表; 例如： 12345struct Book &#123; char author[10]; char name[20]; double price; &#125; book1,book2;//声明struct Book类型的同时定义了两个struct Book类型的变量book1,book2 个人觉得，把上面的申明类型同时定义变量，变成如下形式来看，可能更易于理解： 1struct Book&#123;char author[10];char name[20];double price;&#125; book1,book2; 这样看，是不是特别类似于普通变量的定义，前面是类型，后面是变量列表。当然你也可以通过其他的方式来记住结构体类型，不管黑猫白猫能抓到老鼠就是好猫&gt;_&lt;。 3.不指定类型名而直接定义结构体类型变量 其一般形式如下： 123struct &#123; 成员列表&#125; 变量名列表; 例如： 12345struct &#123; char author[10]; char name[20]; double price; &#125; book1,book2; 可以看到，这种方法指定了一个匿名的结构体类型，它没有名字，因此不能再以此结构体类型去定义其他变量。这种方式用的不多。 结构体变量的初始化和引用初始化结构体变量在定义结构体变量时，可以对它初始化，即赋予初始值。 先看一个例子 12345678910#include &lt;stdio.h&gt;int main() &#123; struct Book &#123; char author[10]; char name[20]; double price; &#125; book = &#123;"谭浩强","C程序设计",33.00&#125;; printf("作者：%s，书名：%s，价格：%f\n",book.author,book.name,book.price); return 0;&#125; 输出结果: 1作者：谭浩强，书名：C程序设计，价格：33.000000 从上例可以看出，初始化列表是用花括号括起来的一些常量，这些常量依次赋给结构体变量中的各成员。 如果我只想对某一成员初始化怎么办呢？ C99标准允许对某一成员初始化，如： 1234567891011#include &lt;stdio.h&gt;int main() &#123; struct Book &#123; char author[10]; char name[20]; double price; &#125; book = &#123;.price = 33.00&#125;; //在成员名前有成员运算符".",".price"隐含代表结构体变量book的成员book.price printf("作者：%s，书名：%s，价格：%f\n",book.author,book.name,book.price); return 0;&#125; 输出结果： 1作者：，书名：，价格：33.000000 其他未被初始化的成员由系统赋默认值，数值型为0，字符型为’\0’，指针型成员为NULL 引用结构体变量中的成员引用方式为 1结构体变量名.成员名 其中，“.”是成员运算符，它在所有的运算符中优先级最高 结构体数组定义结构体数组的一般形式： ①直接定义 123struct 结构体名 &#123; 成员列表&#125; 数组名[数组长度]; ②先声明结构体类型，再用此类型定义结构体数组 1结构体类型 数组名[数组长度]; 示例： 12345678910111213#include &lt;stdio.h&gt;int main() &#123; struct Book&#123; char author[16]; char name[25]; double price; &#125; book[2] = &#123;&#123;"谭浩强","C程序设计",33.00&#125;,&#123;"明日科技","Java从入门到精通",55.51&#125;&#125;; const int n = 2;//定义常变量,const 类似于Java中的 final for(int i = 0 ; i &lt; n ;i++) &#123; printf("作者：%s，书名：%s，价格：%f\n",book[i].author,book[i].name,book[i].price); &#125; return 0;&#125; 输出结果： 12作者：谭浩强，书名：C程序设计，价格：33.000000作者：明日科技，书名：Java从入门到精通，价格：55.510000 需要注意的是，在上面代码的第7行，给数组初始化的时候，每本书的信息，我用一对花括号包起来了，这样做的目的是方便阅读和检查。事实上，下面的代码也是可行的，但不推荐 12345struct Book&#123; char author[16]; char name[25]; double price;&#125; book[2] = &#123;"谭浩强","C程序设计",33.00,"明日科技","Java从入门到精通",55.51&#125;; 结构体指针结构体指针变量的定义和引用，与普通的指针变量一样。 示例: 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Book&#123; char author[16]; char name[25]; double price;&#125;;int main() &#123; struct Book book; struct Book * p = &amp;book;//定义结构体指针变量p并让其指向book strcpy(book.author,"谭浩强"); //这里不能直接写book.name = "C程序设计";，会报错，必须通过c语言提供的字符串赋值函数赋值 strcpy(book.name,"C程序设计"); book.price = 33.00; printf("作者：%s，书名：%s，价格：%f\n",book.author,book.name,book.price); printf("作者：%s，书名：%s，价格：%f\n",(*p).author,(*p).name,(*p).price); return 0;&#125; 输出结果： 12作者：谭浩强，书名：C程序设计，价格：33.000000作者：谭浩强，书名：C程序设计，价格：33.000000 需要注意的是,”.”的优先级高于“*”，所以必须用括号将*p括起来，即使用(*p).author这种形式。 为了使用方便和直观，C语言允许把(*p).author用p-&gt;author来代替，“-&gt;”称为指向运算符，p-&gt;author表示p所指向的结构体变量中的author成员。(这里很重要，C语言中最常见的就是”-&gt;”) 用-&gt;改写上面的代码： 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct Book&#123; char author[16]; char name[25]; double price;&#125;;int main() &#123; struct Book book; struct Book * p = &amp;book; strcpy(book.author,"谭浩强"); strcpy(book.name,"C程序设计"); book.price = 33.00; printf("作者：%s，书名：%s，价格：%f\n",book.author,book.name,book.price); printf("作者：%s，书名：%s，价格：%f\n",p-&gt;author,p-&gt;name,p-&gt;price); return 0;&#125; 输出结果： 12作者：谭浩强，书名：C程序设计，价格：33.000000作者：谭浩强，书名：C程序设计，价格：33.000000]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析作业之自己实现Java双链表]]></title>
    <url>%2F2018%2F05%2F27%2Fdata-structure-and-algorithm-analysis-homework-doublelinkedlist-in-java%2F</url>
    <content type="text"><![CDATA[自己实现的Java双链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245package com.hegongshan.collections;import java.util.NoSuchElementException;/** * 双链表 * @author hegongshan https://www.hegongshan.com * @param &lt;E&gt; */public class DoubleLinkedList&lt;E&gt; &#123; private int size = 0; private Node&lt;E&gt; first; private Node&lt;E&gt; last; private static class Node&lt;E&gt; &#123; Node&lt;E&gt; prev; E data; Node&lt;E&gt; next; Node(Node&lt;E&gt; prev, E data, Node&lt;E&gt; next) &#123; super(); this.prev = prev; this.data = data; this.next = next; &#125; &#125; public DoubleLinkedList()&#123; &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return first == null; &#125; public boolean add(E e) &#123; linkLast(e); return true; &#125; public void add(int index,E e) &#123; checkPositionIndex(index); if(index == size) &#123; linkLast(e); &#125; else &#123; linkBefore(e,node(index)); &#125; &#125; public E get(int index) &#123; checkElementIndex(index); return node(index).data; &#125; public E getFirst() &#123; if(first == null) &#123; throw new NoSuchElementException(); &#125; return first.data; &#125; public E getLast() &#123; if(last == null) &#123; throw new NoSuchElementException(); &#125; return last.data; &#125; public E set(int index,E e) &#123; checkElementIndex(index); Node&lt;E&gt; node = node(index); E oldValue = node.data; node.data = e; return oldValue; &#125; public E remove(int index) &#123; checkElementIndex(index); Node&lt;E&gt; node = node(index); node.prev.next = node.next; node.next.prev = node.prev; E e = node.data; node.prev = null; node.next = null; node.data = null; size--; return e; &#125; public E removeFirst() &#123; if(first == null) &#123; throw new NoSuchElementException(); &#125; Node&lt;E&gt; node = first; E e = node.data; first = node.next; node.next = null; node.data = null; if(first == null) &#123; last = null; &#125; else &#123; first.prev = null; &#125; size--; return e; &#125; public E removeLast() &#123; if(last == null) &#123; throw new NoSuchElementException(); &#125; Node&lt;E&gt; node = last; E e = node.data; last = node.prev; node.prev = null; node.data = null; if(last == null) &#123; first = null; &#125; else &#123; last.next = null; &#125; size--; return e; &#125; public void clear() &#123; for(Node&lt;E&gt; node = first;node != null;) &#123; Node&lt;E&gt; next = node.next; node.prev = null; node.data = null; node.next = null; node = next; &#125; first = last = null; size = 0; &#125; public void reverse() &#123; Node&lt;E&gt; temp = first; first = last; last = temp; &#125; public boolean contains(Object obj) &#123; return indexOf(obj) != -1; &#125; public int indexOf(Object obj) &#123; int index = 0; if(obj == null) &#123; for(Node&lt;E&gt; node = first;node != null;node = node.next) &#123; if(node.data == null) &#123; return index; &#125; index++; &#125; &#125; else &#123; for(Node&lt;E&gt; node = first;node != null;node = node.next) &#123; if(obj.equals(node.data)) &#123; return index; &#125; index++; &#125; &#125; return -1; &#125; public int lastIndexOf(Object obj) &#123; int index = size - 1; if(obj == null) &#123; for(Node&lt;E&gt; node = last;node != null;node = node.prev) &#123; if(node.data == null) &#123; return index; &#125; index--; &#125; &#125; else &#123; for(Node&lt;E&gt; node = last;node != null;node = node.prev) &#123; if(obj.equals(node.data)) &#123; return index; &#125; index--; &#125; &#125; return -1; &#125; public void linkFirst(E e) &#123; Node&lt;E&gt; node = new Node&lt;&gt;(null,e,first); first.prev = node; first = node; size++; &#125; private void linkBefore(E e,Node&lt;E&gt; node) &#123; Node&lt;E&gt; newNode = new Node&lt;&gt;(node.prev,e,node); node.prev.next = newNode; node.prev = newNode; size++; &#125; public void linkLast(E e) &#123; if(size == 0) &#123; first = new Node&lt;&gt;(null,e,null); last = first; size++; return ; &#125; Node&lt;E&gt; node = new Node&lt;E&gt;(last,e,null); last.next = node; last = node; size++; &#125; private Node&lt;E&gt; node(int index) &#123; checkElementIndex(index); if(index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; node = first; for(int i = 0 ; i &lt; index ; i++) &#123; node = node.next; &#125; return node; &#125; else &#123; Node&lt;E&gt; node = last; for(int i = size - 1 ; i &gt; index ; i--) &#123; node = node.prev; &#125; return node; &#125; &#125; private void checkElementIndex(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IndexOutOfBoundsException("index:" + index + ",size:" + size); &#125; &#125; // 可以添加结点的位置，索引从0开始到size private void checkPositionIndex(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IndexOutOfBoundsException("index:" + index + ",size:" + size); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法分析:Java语言描述</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析作业之自己实现Java单链表]]></title>
    <url>%2F2018%2F05%2F26%2Fdata-structure-and-algorithm-analysis-homework-singlelinkedlist-in-java%2F</url>
    <content type="text"><![CDATA[自己实现的Java单链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270package com.hegongshan.collections;import java.util.NoSuchElementException;/** * 单链表 * @author hegongshan https://www.hegongshan.com * @param &lt;E&gt; */public class SingleLinkedList&lt;E&gt; &#123; private int size = 0; private Node&lt;E&gt; first; public SingleLinkedList() &#123; &#125; // 单链表中元素个数 public int size() &#123; return size; &#125; // 判断单链表是否为空 public boolean isEmpty() &#123; return first == null; &#125; public boolean contains(Object obj) &#123; return indexOf(obj) != -1; &#125; public Object[] toArray() &#123; if (isEmpty()) &#123; return null; &#125; Object[] array = new Object[size]; Node&lt;E&gt; node = first; for (int i = 0; i &lt; size; i++) &#123; array[i] = node.data; node = node.next; &#125; return array; &#125; @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; return (T[]) toArray(); &#125; public boolean add(E e) &#123; linkLast(e); return true; &#125; // 在单链表尾部插入新的结点 public void linkLast(E e) &#123; if (!isEmpty()) &#123; Node&lt;E&gt; newNode = new Node&lt;&gt;(e, null); Node&lt;E&gt; last = first; while (last.next != null) &#123; last = last.next; &#125; last.next = newNode; &#125; else &#123; first = new Node&lt;&gt;(e, null); &#125; size++; &#125; // 在单链表头部插入新的数据 public void linkFirst(E e) &#123; Node&lt;E&gt; newNode = new Node&lt;&gt;(e, first); first = newNode; size++; &#125; // 清空单链表 public void clear() &#123; for (Node&lt;E&gt; node = first; node != null;) &#123; Node&lt;E&gt; next = node.next; node.data = null; node.next = null; node = next; &#125; first = null; size = 0; &#125; public E get(int index) &#123; checkElementIndex(index); return node(index).data; &#125; public E getFirst() &#123; if(first == null) &#123; throw new NoSuchElementException(); &#125; return first.data; &#125; // 把索引号为index的结点的数据改为element，并返回原来的结点数据 public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; node = node(index); E oldElement = node.data; node.data = element; return oldElement; &#125; // 在指定索引处插入元素 public void add(int index, E element) &#123; checkPositionIndex(index); if (index == 0) &#123; linkFirst(element); return; &#125; Node&lt;E&gt; newNode = new Node&lt;&gt;(element, null); Node&lt;E&gt; node = first; for (int i = 0; i &lt; index - 1; i++) &#123; node = node.next; &#125; newNode.next = node.next; node.next = newNode; size++; &#125; // 删除指定索引的结点，并返回该结点的数据值 public E remove(int index) &#123; checkElementIndex(index); Node&lt;E&gt; node = first; for (int i = 0; i &lt; index - 1; i++) &#123; node = node.next; &#125; Node&lt;E&gt; removeNode = node.next; node.next = removeNode.next; E e = removeNode.data; removeNode.data = null; removeNode.next = null; return e; &#125; //反转单链表pre-&gt;p-&gt;next public void reverse() &#123; Node&lt;E&gt; pre = first; Node&lt;E&gt; p = first.next; Node&lt;E&gt; next = null; pre.next = null; while(p != null) &#123; next = p.next; p.next = pre; pre = p; p = next; &#125; first = pre; &#125; // 给定数据在单链表中首次出现的位置 public int indexOf(Object obj) &#123; int index = 0; if (obj == null) &#123; for (Node&lt;E&gt; node = first; node != null; node = node.next) &#123; if (node.data == null) &#123; return index; &#125; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; node = first; node != null; node = node.next) &#123; if (obj.equals(node.data)) &#123; return index; &#125; index++; &#125; &#125; return -1; &#125; // 给定数据在单链表中最后一次出现的位置 public int lastIndexOf(Object obj) &#123; int index = 0; int i = 0; int[] array = new int[size]; if (obj == null) &#123; for (Node&lt;E&gt; node = first; node != null; node = node.next) &#123; if (node.data == null) &#123; array[i++] = index; &#125; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; node = first; node != null; node = node.next) &#123; if (obj.equals(node.data)) &#123; array[i++] = index; &#125; index++; &#125; &#125; if (array.length != 0) &#123; return array[i - 1]; &#125; return -1; &#125; /*public int lastIndexOf(Object obj) &#123; Object[] array = toArray(); if(obj == null) &#123; for(int i = array.length -1;i&gt;=0;i--) &#123; if(array[i] == null) &#123; return i; &#125; &#125; &#125; else &#123; for(int i = array.length -1;i&gt;=0;i--) &#123; if(obj.equals(array[i])) &#123; return i; &#125; &#125; &#125; return -1; &#125;*/ @Override public String toString() &#123; StringBuilder list = new StringBuilder("["); Node&lt;E&gt; node = first; int index = 0; while (node != null) &#123; index++; if (index == size) &#123; list.append(node.data); &#125; else &#123; list.append(node.data).append(","); &#125; node = node.next; &#125; list.append("]"); return list.toString(); &#125; private Node&lt;E&gt; node(int index) &#123; checkElementIndex(index); Node&lt;E&gt; node = first; for(int i = 0 ; i &lt; index ;i++) &#123; node = node.next; &#125; return node; &#125; private static class Node&lt;E&gt; &#123; private E data; private Node&lt;E&gt; next; Node(E data, Node&lt;E&gt; next) &#123; this.data = data; this.next = next; &#125; &#125; // 单链表中的结点索引从0开始到size-1 private void checkElementIndex(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IndexOutOfBoundsException("index:" + index + ",size:" + size); &#125; &#125; // 可以添加结点的位置，索引从0开始到size private void checkPositionIndex(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IndexOutOfBoundsException("index:" + index + ",size:" + size); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法分析:Java语言描述</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析C语言指针]]></title>
    <url>%2F2018%2F05%2F26%2Fc-pointer%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;指针是一个地址，而指针变量是存放地址的变量。 定义指针变量定义指针变量的一般形式： 类型名 * 指针变量名; 如： 1int * p1,* p2; 引用指针变量相关运算符 &amp;&nbsp;&nbsp;&nbsp;取地址运算符，&amp;a是变量a的地址 *&nbsp;&nbsp;&nbsp;&nbsp;指针运算符，*p代表指针变量p指向的对象 给指针变量赋值（指针变量的值只能是地址） 1p = &amp;a;//把a的地址赋给指针变量p，p指向a 引用指针变量指向的变量 123int * p,a = 10;p = &amp;a;printf("%d",*p);//其中*p等价于a 这里*p出现了两次，但是二者的含义完全不同。第一行中的*p表示定义了一个指针变量*p，其前面的*只是表示该变量是一个指针变量。而第三行中的*p则代表指针变量p所指向的变量a。 引用指针变量的值。如： 1printf("%d",p);//以八进制数的形式输出指针变量p的值，如果p指向了a，就是输出a的地址，即&amp;a。 示例： 1234567891011#include &lt;stdio.h&gt;int main()&#123; int a = 100,b = 90; int * p1, * p2; p1 = &amp;a; p2 = &amp;b; printf("a = %d,b = %d\n",a,b); printf("* p1 = %d,* p2 = %d",*p1,*p2); return 0;&#125; 输出： 12a = 100,b = 90* p1 = 100,* p2 = 90 这里指针变量p1指向a，指针变量p2指向b，因此*p1等价于a，*p2等价于b 指针变量的好处C语言中，实参变量和形参变量之间的数据传递是单向的“值传递”方式。函数的调用可以（且只可以）得到一个返回值，而使用指针变量作参数，可以得到多个变化了的值。虽然不能改变实参指针变量的值，但是可以改变实参指针变量所指向的变量的值。]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法分析作业之自己实现Java顺序表]]></title>
    <url>%2F2018%2F05%2F25%2Fdata-structure-and-algorithm-analysis-homework-arraylist%2F</url>
    <content type="text"><![CDATA[自己实现的Java顺序表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195package com.hegongshan.collections;/** * 顺序表 * @author hegongshan https://www.hegongshan.com * @param &lt;E&gt; */public class ArrayList&lt;E&gt; &#123; private static final int DEFAULT_CAPACITY = 10; private Object[] elementData; private int size = 0; public ArrayList() &#123; this(DEFAULT_CAPACITY); &#125; public ArrayList(int capacity) &#123; if (capacity &lt; 0) &#123; throw new IllegalArgumentException("Illegal Capacity: " + capacity); &#125; elementData = new Object[capacity]; &#125; // 返回顺序表中的元素个数 public int size() &#123; return size; &#125; // 是否为空 public boolean isEmpty() &#123; return size == 0; &#125; // 添加元素 public boolean add(E e) &#123; ensureCapacity(); elementData[size] = e; size++; return true; &#125; // 根据索引号添加元素 public void add(int index, E e) &#123; checkPositionIndex(index); ensureCapacity(); for (int i = size - 1; i &gt;= index; i--) &#123; elementData[i + 1] = elementData[i]; &#125; elementData[index] = e; size++; &#125; // 删除指定索引处的元素 @SuppressWarnings("unchecked") public E remove(int index) &#123; checkElementIndex(index); E oldValue = (E) elementData[index]; for (int i = size - 1; i &gt; index; i--) &#123; elementData[i - 1] = elementData[i]; &#125; elementData[--size] = null;// 最后一个元素变为null return oldValue; &#125; // 删除指定元素值首次出现的那个元素 public boolean remove(Object obj) &#123; int index = indexOf(obj); if (index != -1) &#123; remove(index); return true; &#125; return false; &#125; // 根据索引号获取元素 @SuppressWarnings("unchecked") public E get(int index) &#123; checkElementIndex(index); return (E) elementData[index]; &#125; // 改变指定索引号的元素值 public void set(int index, E e) &#123; checkElementIndex(index); elementData[index] = e; &#125; public void clear() &#123; for (int i = 0; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = 0; &#125; // 去掉多余的容量 public void trimToSize() &#123; if (size &lt; elementData.length) &#123; if (size == 0) &#123; return; &#125; Object[] newElementData = new Object[size]; for (int i = 0; i &lt; size; i++) &#123; newElementData[i] = elementData[i]; &#125; elementData = newElementData; &#125; &#125; // 是否包含某一元素 public boolean contains(Object obj) &#123; return indexOf(obj) != -1; &#125; // 某一元素首次出现的位置 public int indexOf(Object obj) &#123; if (obj == null) &#123; for (int i = 0; i &lt; size; i++) &#123; if (elementData[i] == null) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; size; i++) &#123; if (obj.equals(elementData[i])) &#123; return i; &#125; &#125; &#125; return -1; &#125; // 某一元素最后一次出现的位置 public int lastIndexOf(Object obj) &#123; if (obj == null) &#123; for (int i = size - 1; i &gt;= 0; i--) &#123; if (elementData[i] == null) &#123; return i; &#125; &#125; &#125; else &#123; for (int i = size - 1; i &gt;= 0; i--) &#123; if (obj.equals(elementData[i])) &#123; return i; &#125; &#125; &#125; return -1; &#125; // 确保容量，如果实际的元素个数大于等于容量，则扩容 private void ensureCapacity() &#123; if (size &gt;= elementData.length) &#123; grow(); &#125; &#125; // 扩容，每次增加原来一半的容量 private void grow() &#123; // 右移的时候一定要加括号，&gt;&gt;的优先级低于+， // 为了避免size为0，取扩容后的size和默认容量两者的最大值为新的容量 int newCapacity = Math.max(size + (size &gt;&gt; 1), DEFAULT_CAPACITY); Object[] newElementData = new Object[newCapacity]; for (int i = 0; i &lt; size; i++) &#123; newElementData[i] = elementData[i]; &#125; elementData = newElementData; &#125; // 判断索引值是否为正确的元素索引 private void checkElementIndex(int index) &#123; if (index &lt; 0 || index &gt;= size) &#123; throw new IndexOutOfBoundsException("index:" + index + ",size:" + size); &#125; &#125; // 可以添加元素的位置，索引从0开始到size private void checkPositionIndex(int index) &#123; if (index &lt; 0 || index &gt; size) &#123; throw new IndexOutOfBoundsException("index:" + index + ",size:" + size); &#125; &#125; @Override public String toString() &#123; StringBuilder list = new StringBuilder(); list.append("ArrayList ["); for (int i = 0; i &lt; size; i++) &#123; list.append(elementData[i]); if (i &lt; size - 1) &#123; list.append(','); &#125; &#125; list.append("]"); return list.toString(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构与算法分析:Java语言描述</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java网络爬虫之HttpURLConnection实战]]></title>
    <url>%2F2018%2F05%2F21%2Fjava-spider-httpurlconnection-in-action%2F</url>
    <content type="text"><![CDATA[在开始写爬虫之前，我们先来总结一下用HttpURLConnection写爬虫的操作步骤： 1.实例化一个URL，调用URL类的openConnection()方法获得URLConnection对象，并强转为HttpURLConnection对象 12URL url = new URL("http://host/path");HttpURLConnection connection = (HttpURLConnection) url.openConnection(); 2.设置连接的请求属性，诸如，setRequestProperty、setConnectionTimeout、setReadTimeout等 3.调用connect()方法连接远程资源 1connection.connect(); 4.访问资源数据。使用getInputStream方法获取一个输入流用以读取信息。如果服务器端出现错误，调用getErrorStream()方法获取错误信息。 12345try&#123; connection.getInputStream();&#125; catch(Exception e) &#123; connection.getErrorStream();&#125; 5.调用disconnect()关闭连接 1connection.disconnect(); 6.解析需要的数据。 这里以爬取百度首页为例， GET请求爬取百度首页源码1234567891011121314151617181920URL url = new URL("https://www.baidu.com");HttpURLConnection connection = (HttpURLConnection) url.openConnection();connection.setConnectTimeout(10000);connection.setRequestMethod("GET");connection.connect();InputStream is = connection.getInputStream();BufferedReader br = new BufferedReader(new InputStreamReader(is,"utf-8"));String temp;StringBuilder html = new StringBuilder();while((temp = br.readLine()) != null) &#123; if(temp.trim().isEmpty()) &#123; continue; &#125; //格式化html html.append(temp.replaceAll("\\s+&lt;", "&lt;").replace("&gt;", "&gt;\n"));&#125;br.close();is.close();connection.disconnect();System.out.println(html); 控制台输出如下信息： 设置用户代理，再爬百度首页上面的程序，我们稍微改一下，在setRequestProperty方法中设置下User-Agent，看下会出现什么神奇的变化？因为输出的内容有点多，我把它写入到一个html文件中了，而不是直接打印在控制台。 1234567891011121314151617181920212223242526272829303132URL url = new URL("https://www.baidu.com");HttpURLConnection connection = (HttpURLConnection) url.openConnection();connection.setConnectTimeout(10000);connection.setRequestMethod("GET");connection.setDoInput(true);connection.setDoOutput(false);connection.setRequestProperty("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36");connection.connect();InputStream is = connection.getInputStream();BufferedReader br = new BufferedReader(new InputStreamReader(is,"utf-8"));String temp;BufferedWriter bw = new BufferedWriter(new FileWriter(new File("c:/Users/hgs/Desktop/baidu_index.html"),true));while((temp = br.readLine()) != null) &#123; temp = temp.trim(); if(temp.isEmpty()) &#123; continue; &#125; //格式化输出，便于在浏览器中查看 temp = temp.replaceAll("\\s+&lt;", "&lt;") .replace("&lt;", "&amp;lt;") .replace("&gt;", "&amp;gt;&lt;br&gt;") .replace("&amp;lt;/","&lt;br&gt;&amp;lt;/") .replace("&#123;", "&#123;&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;") .replace("&#125;", "&lt;br&gt;&#125;&lt;br&gt;") .replaceAll("[^\\&amp;(nbsp|gt|lt)];[^\"']", ";&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"); bw.write(temp);&#125;bw.flush();bw.close();br.close();is.close();connection.disconnect(); 响应结果： 响应结果似乎与刚才不一样了，多出了很多内容。这是因为，默认情况下，Java程序会发送包含单词Java的通用用户代理字符串，而有些服务器可能存在反爬虫机制，不想为程序自动产生的请求服务。这时候，我们可在请求头中设置User-Agent，以达到伪装浏览器的目的。 带参数的get请求到这里我们已经能爬到完整的百度首页了，但这似乎没有什么用处。 现在我们试试通过程序自动查询百度，并获取第一页的查询结果。。。（未完待续）]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网络爬虫之详解HttpURLConnection]]></title>
    <url>%2F2018%2F05%2F21%2Fjava-spider-httpurlconnection%2F</url>
    <content type="text"><![CDATA[在Java.net包下有一个类HttpURLConnection，其继承结构如下： 1public abstract class HttpURLConnection extends URLConnection 它的父类URLConnection也是一个抽象类。要想取得URLConnection对象，只能通过java.net.URL下的如下方法： 12public URLConnection openConnection() throws java.io.IOException;public URLConnection openConnection(Proxy proxy) throws java.io.IOException; URLConnection主要的成员方法： 12345678910111213141516171819202122232425//设置建立连接后，产生从服务器读取信息的输入流，默认为truepublic void setDoInput(boolean doinput);//默认情况下，建立连接后不会产生执行写操作的输出流，如果想要获得输出流，//则将dooutput设置为true，主要用于post请求public void setDoOutput(boolean dooutput);public void setIfModifiedSince(long ifmodifiedsince);public void setUseCaches(boolean usecaches);public void setAllowUserInteraction(boolean allowuserinteraction);public void setRequestProperty(String key, String value);public void setConnectTimeout(int timeout);public void setReadTimeout(int timeout);public String getHeaderField(String name);public String getHeaderField(int n);public String getHeaderFieldKey(int n);public int getContentLength();public String getContentType();public String getContentEncoding();public long getExpiration()public long getLastModified();public URL getURL();public abstract void connect() throws IOException; 12 在setRequestProperty()方法中可以设置请求头信息。请求头信息将和请求命令一起被发送到服务器，例如： 12345678910Accept:image/webp,image/apng,image/*,*/*;q=0.8Accept-Encoding:gzip, deflate, brAccept-Language:zh-CN,zh;q=0.8Cache-Control:no-cacheConnection:keep-aliveCookie:Host:sp1.baidu.comPragma:no-cacheReferer:https://www.baidu.comUser-Agent:Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36 如何查看有哪些头信息可以设置呢？这里以百度首页为例，我用的chrome浏览器（其他浏览器大同小异），按F12打开开发者工具，选择网络（network），然后刷新一下正在浏览的页面，可以看到很多的图片、css、js等，随便点开一个，右侧的Request Headers下的信息，就是请求头信息。 HttpURLConnection主要的扩展方法： 12345678910//method必须写大写字母public void setRequestMethod(String method) throws ProtocolException;public int getResponseCode() throws IOException;public String getResponseMessage() throws IOException;public InputStream getErrorStream();public static void setFollowRedirects(boolean set);public void setInstanceFollowRedirects(boolean followRedirects);public abstract void disconnect(); 值得注意的是，setRequestMethod方法的参数必须写大写，以GET请求为例，如果写小写，会报如下错误： 123Exception in thread "main" java.net.ProtocolException: Invalid HTTP method: getat java.net.HttpURLConnection.setRequestMethod(Unknown Source)at sun.net.www.protocol.http.HttpURLConnection.setRequestMethod(Unknown Source) 支持的HTTP请求为GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE，默认为GET请求。 若为POST请求，则需要设置setDoOutput(boolean dooutput)为true，否则会报如下错误： 1234Exception in thread "main" java.net.ProtocolException: cannot write to a URLConnection if doOutput=false - call setDoOutput(true) at sun.net.www.protocol.http.HttpURLConnection.getOutputStream0(Unknown Source) at sun.net.www.protocol.http.HttpURLConnection.getOutputStream(Unknown Source) at sun.net.www.protocol.https.HttpsURLConnectionImpl.getOutputStream(Unknown Source) （未完待续）]]></content>
      <categories>
        <category>网络爬虫</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下搭建nginx和tomcat整合开发环境]]></title>
    <url>%2F2018%2F05%2F19%2Fwindows-nginx-tomcat-development-environment%2F</url>
    <content type="text"><![CDATA[遇到的问题越多，人成长的越快。算下日子，接手课题组的项目，已经一月有余。期间碰到了很多问题，也一直在积极面对。 问题引出接手课题组的项目后，遇到过一个很严重的问题：项目在本地tomcat上能完美运行，但是到了服务器上，就出问题了——JSP文件中el表达式${pageContext.request.contextPath}取到的上下文路径始终为空，即***“”。由于之前深受项目必须使用绝对路径这一思想的影响，我在JSP文件中定义了如下变量，用来表示外部js文件中的ajax请求地址的前缀。 123&lt;script src="text/javascript"&gt; var contextPath = "$&#123;pageContext.request.contextPath&#125;";&lt;/script&gt; 对于一个常规的java web项目，我们在部署到服务器tomcat中的时候，一般会先配置server.xml文件 12345678910111213141516171819&lt;!--端口号改为80--&gt;&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt;&lt;!--defaultHost和主机的name均改为项目的域名--&gt;&lt;Engine name="Catalina" defaultHost="localhost"&gt; &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt; &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm" resourceName="UserDatabase"/&gt; &lt;/Realm&gt; &lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;!--如果项目名不为ROOT，还要配置Context--&gt; &lt;!--&lt;Context docBase="" path=""/&gt;--&gt; &lt;/Host&gt;&lt;/Engine&gt; 但是，最开始不知道的是，服务器上使用了nginx作为反向代理服务器，所有的http请求，都由nginx转发给tomcat，tomcat的server.xml根本就没有配置（或者说是使用了默认配置），这就很好的解释了为什么${pageContext.request.contextPath}为空了，因为项目名为ROOT的项目，默认的path就是空。 当时的解决办法是，把上面jsp中定义的js变量contextPath直接改为项目域名。这样一改，域名是写死的，不带www前缀的时候，出现了ajax跨域。 后来想想，干脆直接改为“.”，也就是用相对路径。这样一改，似乎解决了原来的问题。但这只是假象，一旦原来的路径多起来，”.”表示与当前页面同级，ajax请求的地址可能就不对了。 最后干脆弃用${pageContext.request.contextPath}，所有的请求以”/“开头，并且为了防止再出现本机运行效果和服务器上运行效果不一致的情况，我在我的电脑上搭建了nginx和tomcat整合开发环境。 废话不多说了，赶紧进入正题。 安装nginx首先，从nginx官网下载最新的稳定版nginx，下载地址 当前最新的稳定版本是1.14.0，根据自己的操作系统选择对应的版本，我这里选择nginx/Windows-1.14.0 下载下来后，直接解压缩就可以了，下面是解压后的目录结构 启动nginx 启动nginx有两种方式，一是点击nginx.exe直接启动，二是在命令行模式下切换到nginx解压目录（当然，也可以将nginx路径添加到系统环境变量path中，以后就不需要切换到解压目录那么麻烦了），使用命令 start nginx来启动nginx（推荐使用这种方法）。 进入命令行模式，切换到nginx解压目录，我直接解压在桌面上了，输入start nginx，屏幕一闪，然后出现下一个命令行，这就表示nginx已经启动啦。 现在我们来测试下nginx是不是真的成功启动了，在浏览器里输入localhost，不出意外的话应该会出现nginx的欢迎页面。 关闭nginx 使用命令nginx.exe -s stop来关闭nginx 重启nginx 使用命令nginx.exe -s reload来重启nginx 配置nginx 在conf目录下有一个叫做nginx.conf文件，这是nginx的配置文件。 这里我不会详细讲nginx.conf中的各种配置（因为我现在也不会啊^_^），以后会专门开一个系列来讲nginx以及Linux上nginx和tomcat实现反向代理和负载均衡。 主要来看下与开发环境搭建相关的server的配置 1234567891011121314151617181920212223#配置虚拟主机server &#123; listen 80; #指定需要nginx监听的端口 server_name localhost; #需要访问的域名 #charset koi8-r; #access_log logs/host.access.log main; #转发 location / &#123; root html; #指定根目录 index index.html index.htm; #指定首页及优先顺序 &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 主要需要改下location /里面的配置 1234location / &#123; proxy_pass http://localhost:8080; # proxy_pass 指定被代理服务器的URL proxy_set_header Host $host; # 将nginx接收到的请求头信息中的host转发给被代理服务器&#125; 到这里，nginx就基本配置好了。 配置eclipse（可选）在eclipse中运行我们的项目，然后修改eclipse引入的tomcat配置文件server.xml 1234&lt;!--eclipse默认情况下会用项目名作为上下文路径，这里我们改为空或者/，不改的话，访问的时候需要加上项目名--&gt;&lt;Context docBase="demo" path="" reloadable="true" source="org.eclipse.jst.jee.server:course"/&gt; 我们在浏览器中直接访问localhost，看能否访问到我们的项目 出现了Hello World! 这表明nginx确实把我们的请求转发给了tomcat。]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL模糊查询并高亮显示查询结果]]></title>
    <url>%2F2018%2F05%2F14%2Fsql-fuzzy-query-and-highlight-keyword%2F</url>
    <content type="text"><![CDATA[最近在完善课题组的项目时，遇到了一个问题：项目有个论坛模块，需要实现根据用户输入的关键字检索论坛文章，然后高亮显示检索结果。 本来遇到这个需求，第一反应是用lucene来做全文检索。但是，lucene只是一个全文检索工具包，要用它实现全文检索，需要写一大堆的代码，加之虽然之前用过几次lucene，但是对lucene的API还是不太熟。想想还是算了，等以后专门研究一下lucene再说吧。 有朋友可能要问了：为什么不用solr或者elasticsearch？还不是因为不熟，再说了，一个solr一百多兆，我这就是个小项目，没必要啊。思来想去，最后还是决定就用sql的模糊查询like实现。 表结构是这样的 123456789create table article( id bigint unsigned not null auto_increment, title varchar(255) not null, summary varchar(255) not null, is_public tinyint(1) unsigned not null default 1 comment "是否公开，1表示公开，0表示私密", gmt_create datetime not null, ..., primary key(id)) 这里以检索“作业“为例，只查询公开的文章，并且按照发表时间降序排列，SQL是这样写的 12345select id,title,summary,gmt_create,... from articlewhere is_public = 1 and (title like "%作业%" or summary like "%作业%")order by gmt_create desclimit 0,10; 这样做确实能实现模糊查询了，但是又一个问题来了：如何实现检索结果高亮显示呢？ 寻思了很久，也没想到解决办法。后来灵机一动，想到干嘛不在返回字段的时候在关键字的前后插入一些html标签，或者直接替换返回字段中的关键字，这不就实现高亮显示了吗？于是SQL就成了下面这样。 12345678select id,replace(title,"作业",concat("&lt;font color='red'&gt;&lt;b&gt;","作业","&lt;/b&gt;&lt;/font&gt;")) as title,replace(summary,"作业",concat("&lt;font color='red'&gt;&lt;b&gt;","作业","&lt;/b&gt;&lt;/font&gt;")) as summary,gmt_create,...from articlewhere is_public = 1 and (title like "%作业%" or summary like "%作业%")order by gmt_create desclimit 0,10; 当然，使用全模糊查询，然后通过替换关键字的方式实现检索结果高亮显示，从而实现全文检索，这种方法效率肯定不高。《阿里巴巴Java开发手册》中也明确禁止使用全模糊或左模糊查询，因为全模糊或者左模糊查询无法使用索引。]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux中存活下来之tar压缩和解压缩文件]]></title>
    <url>%2F2018%2F05%2F14%2Flinux-command-tar%2F</url>
    <content type="text"><![CDATA[最近需要在Linux服务器上解压tar.gz文件，于是乎学习了下tar命令的使用。 tar命令参数很多，暂时就只用到以下几个参数，其他的以后用到再补上。 参数说明： -c：全称create，用于创建文件 -v：全称verbose，用于显示详细的命令执行信息 -f：全称file，用于指定需要压缩或者解压缩的文件名 -x：用于解压文件 -C：切换到指定目录 -z：通过gzip命令处理文件。简单来说，如果需要压缩为*.gz文件，或者解压缩*.gz文件，就要带上-z 示例1.解压缩tar.gz文件 1tar -zxvf apache-tomcat-8.5.31.tar.gz 2.解压缩tar.gz文件到指定目录，这里以/usr/local目录为例 1tar -zxvf apache-tomcat-8.5.31.tar.gz -C /usr/local 3.将某个（些）目录或文件压缩为tar.gz文件 1tar -zcvf archive.tar.gz file1 file2 ... archive.tar.gz是生成的压缩文件名，file1、file2等是要压缩的文件和目录列表。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>压缩</tag>
        <tag>解压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux中存活下来之vim编辑器的使用]]></title>
    <url>%2F2018%2F05%2F11%2Flinux-vim%2F</url>
    <content type="text"><![CDATA[前话：学习vim编辑器，是一个循序渐进的过程，本篇是博主自己的学习总结，会持续更新。 简介vim编辑器有三种工作模式： 命令行模式：顾名思义，在这个模式下，所有的键盘操作都会被认为是命令。启动vi编辑器，就会进入命令行模式。 输入模式：除了按下“Esc”外，其他的键盘输入都不会被认为是命令。处于这个模式下，和我们在Windows中用Notepad等编辑文件，几乎没有区别。按下“Esc”，会退出输入模式，进入命令行模式。 末行模式（编辑模式）：在命令模式下，输入“:”就会进入末行模式。 这里，博主总结下最近学习到的且经常使用的一些命令。 启动vimvim fileName：进入编辑环境并打开或新建文件 命令行模式dd：删除光标所在行，并将当前行内容复制到剪贴板 p：全称paste，表示将剪贴板中的数据粘贴到光标当前位置 yy：复制光标所在行 进入输入模式 i：在命令模式下，在当前光标处进入输入模式 输入模式输入模式，类似于我们在Windows中编辑文件 方向键进行上下左右方向的光标移动 Backspace键：删除光标左侧的字符 delete键：删除光标右侧的字符 退出输入模式按下Esc键：从输入模式回到命令行模式 进入末行模式在命令行模式下，按下”:“就会进入末行模式。 输入:set number或者:set nu显示行号。 输入:set nonumber或者:set nonu不显示行号。 退出vimq：退出vi q!：不保存文件并退出vi w：保存文件 wq：保存文件并退出vi wq!：强制保存文件并退出vi（忽略只读） 快速定位行1.启动前 定位到文件第num行：vim +num fileName 例如，定位到test.txt的第10行：vim +10 test.txt 2.命令行模式 shift + G：跳转至最后一行 1+shift + G 或者 GG：跳转至第一行 n+shift + G 或者 nGG：跳转至第n行。比如10GG，跳转至第10行 3.末行模式 输入:number，定位到第number行。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux中存活下来之文件与目录管理]]></title>
    <url>%2F2018%2F05%2F10%2Flinux-file-directory-manage%2F</url>
    <content type="text"><![CDATA[前话：最近接手了导师的一个项目，项目部署在Linux服务器上后，出了点小问题，需要修改一些文件。因为不是自己部署的，加之对linux命令不熟，怎么办？在本地修改完后，重新让别人帮忙部署？还是自己在服务器上手动修改？天生不喜欢求人，哈哈 总结一下最近常用的一些Linux基础命令，主要和文件、目录的操作相关 lsls，全称list，用于列出某个目录下的所有文件和目录。 用法：ls -options dirName 参数说明： -a或者--all：列出所有的文件，包括以点号开头的文件 cdcd，全称change directory，用于切换路径。估计大伙对cd这个命令都很熟，因为Windows上的命令行界面也是用cd命令来切换路径。值得一提的是，”~”表示当前用户的主目录，”..”表示回到当前目录的上一级目录 用法：cd [dirName] pwdpwd，全称print working directory，用于输出当前的工作目录名。 rmrm，全称remove，用于删除文件或目录。 用法：rm [options] name… 参数说明： -i 删除前逐一询问确认 -f 全称force，删除文件不需要询问 -r 全称recurse，递归删除目录下的所有文件 如果嫌上面的麻烦，那么我们简单粗暴点，删除文件用 rm [fileName]，删除目录用 rm -rf [dirName]，哈哈 cpcp，全称copy，用于复制文件或目录。 用法：cp [options] source… dest cp的参数比较多，这里只讲-r，其他的用到再现学。cp中的-r和rm中的-r意思差不多，都表示递归。主要用于目录复制。 简单粗暴版：复制单个文件用 cp source … dest，复制目录用 cp -r [dirName]&nbsp;[dirName] mvmv，具有rename和move两种功能，用于重命名文件或目录，或者将文件或目录移入另一个目录。 用法：mv source dest 简单来说，如果source和dest同为目录或者文件，且dest不存在，则将source重命名为dest； 如果source为文件或目录，而dest为目录，则将source移到dest中。 touchtouch，用于创建文件。如果文件已经存在，则更新文件的时间戳。 filefile，用于输出文件类型。 用法：file filename mkdirmkdir，全称make directory，用于创建目录。 用法：mkdir [options] dirName mkdir的参数暂时没用过，等用到了再补上。 rmdirrmdir，全称remove directory，用于删除空目录。 语法：rmdir [options] dirName 参数： -p：全称parents，删除指定的空目录后，若此时该目录的父目录已变成空目录，则将父目录一并删除。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式及Java对其的支持]]></title>
    <url>%2F2018%2F04%2F11%2Fjava-regular-expression%2F</url>
    <content type="text"><![CDATA[简述正则表达式​ 今天我们来讲下正则表达式，先来看下正则表达式中的数量表示 字符 说明 举例 ? 零次或一次匹配？前的字符或子表达式，等价于{0,1} gong(shan)?匹配gong或gongshan * 零次或多次匹配*前的字符或子表达式，等价于{0,} sm*匹配sm或者s + 一次或多次匹配*前的字符或子表达式，等价于{1,} zoo+匹配zoo或者zooo等 {n} n为非负整数，正好匹配n次 zo{2}匹配zoo {n,} n为非负整数，至少匹配n次 zo{1,}可匹配zo，zoo，zooo等 {n,m} n和m均为非负整数，表示至少匹配n次，至多匹配m次 zo{1,2}则只匹配zo或者zoo 常用特殊字符 字符 说明 举例 [xyz] 字符集。匹配包含的任一字符 [abc] 匹配 java 中的a [^xyz] 反字符集。匹配未被包含的任一字符 [^abc] 匹配 java 中的 j和v [x-y] 字符范围。匹配从x到y（指定范围内）的所有字符 [a-z]匹配从a到z的所有小写字母 \d 匹配一个数字，等价于[0-9] he\d{2} 匹配 he33 \D 匹配一个非数字，等价于[^0-9] he\D{4} 匹配 heyang \s 匹配任何空白字符 \S 匹配任何非空白字符 \w 匹配任何字类字符，包括下划线，等价于[a-zA-Z0-9_] \W 匹配任何非字类字符，等价于[^a-zA-Z0-9_] 常用逻辑操作 字符 说明 举例 xy x并y [xy] x&#124;y x或y [x&#124;y] (X) 将X定义为一个组 [xy(bc)]，(x&#124;y) 其他预定义字符以及不是特别常用的字符，详见 java正则表达式 java对正则表达式的支持在java中要想使用正则表达式，有三种方式： String类对正则表达式的支持 1public boolean matches(String regex) 单独使用java.util.regex.Pattern 1public static boolean matches(String regex, CharSequence input) java.util.regex包下的Pattern类配合Matcher类使用（推荐采用此方式） 下面我们依次来使用这三种方式： 第一种：String类对正则表达式的支持 matches(String regex) 123456public void testString() &#123; String str = "Java"; boolean flag = str.matches("(J|x)ava"); System.out.println(flag);&#125;输出结果：true 这种方式虽然也能实现正则匹配，但是功能单一，只能返回是否匹配，而且字符串必须整体匹配才能返回true，以下面的代码来说明这个问题 123456public void testString2() &#123; String str = "Java is a programming language."; boolean flag = str.matches("Java"); System.out.println(flag);&#125;输出结果：false 查看String类的源码可以发现，String类的matches方法实际上就是调用的下面要讲的第二种方式Pattern.matches(String regex,CharSequence input) 123public boolean matches(String regex) &#123; return Pattern.matches(regex, this);&#125; 第二种：单独使用Pattern进行正则匹配 1234567public void testPattern() &#123; String str = "Java is a programming language."; String regex = "Java"; boolean flag = Pattern.matches(regex, str); System.out.println(flag);&#125;输出结果：false 这里为什么也返回了false？原因和第一种方式一样，因为Pattern的静态方法matches(String regex,CharSequence input)也是整体匹配。实际上，如果我们去查看Pattern的源码的话，可以发现：12345public static boolean matches(String regex, CharSequence input) &#123; Pattern p = Pattern.compile(regex); Matcher m = p.matcher(input); return m.matches();&#125; 这种方式实际上使用的是下面的第三种方式 第三种：Pattern和Matcher的结合使用 1234567891011121314public void testPatternAndMatcher() &#123; String str = "I love Java and xava."; String regex = "(J|x)ava"; Pattern p = Pattern.compile(regex); Matcher m = p.matcher(str); System.out.println(m.matches()); while(m.find()) &#123; System.out.println(m.group()); &#125;&#125;输出结果：falseJavaxava 通过以上分析，我们可以发现，第一种方式是对第二种方式的调用，而第二种方式的实现又是采用的第三种方式。 因此，在以后的使用中，推荐直接使用第三种方式，其功能远强于第一种和第二种方式。 详解Pattern和MatcherPattern的常用方法如下： 12public static Pattern compile(String regex)public Matcher matcher(CharSequence input) 由于Pattern只有私有构造方法，我们不能直接实例化它，故每次必须通过其compile方法取得Pattern对象，继而通过matcher方法获取Matcher对象。 Matcher的常用方法 ①索引方法： 1234public int start()//返回之前匹配的起始索引public int start(int group)public int end()//返回最后匹配字符之后的偏移量，例如用\d&#123;4&#125;匹配he2018，则end()返回6public int end(int group) 实例如下： 12345678910111213141516import java.util.regex.Matcher;import java.util.regex.Pattern;public class RegexTest &#123; public static void main(String[] args) &#123; String regex = "\\d&#123;4&#125;"; String str = "he2018shan0423yang11gong456shan"; Pattern pattern = Pattern.compile(regex); Matcher matcher = pattern.matcher(str); while(matcher.find()) &#123; System.out.println("匹配字段："+matcher.group()); System.out.println("开始索引："+matcher.start()); System.out.println("结束索引："+matcher.end()); &#125; &#125;&#125; 输出结果： 123456匹配字段：2018开始索引：2结束索引：6匹配字段：0423开始索引：10结束索引：14 ②研究方法 1234public boolean find()public boolean find(int start)public boolean lookingAt()public boolean matches() ③替换方法 12345public static String quoteReplacement(String s)public Matcher appendReplacement(StringBuffer sb, String replacement)public StringBuffer appendTail(StringBuffer sb)public String replaceAll(String replacement)public String replaceFirst(String replacement) 附录常用的正则表达式 规则 正则表达式语法 电子邮箱 [\w!#$%^&amp;`+=/(&#124;)’?,~*-]+@([a-z0-9]+\.)+[a-z]+ 中文字符 [\u4e00-\u9fa5] QQ号 [1-9][0-9]{4,} 身份证号 \d{6}(19&#124;20)\d{2}((0[1-9])&#124;(1[0-2]))(([0-2]\d)&#124;(3[0-1]))\d{3}(\d&#124;x&#124;X){1}]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架源码阅读之栈Stack]]></title>
    <url>%2F2018%2F04%2F02%2Fjava-collections-api-stack%2F</url>
    <content type="text"><![CDATA[什么是栈？栈是限制插入和删除只能在一个位置上进行的表，它是一个后进先出(last-in-first-out，LIFO)表 本文是《Java集合框架源码阅读》系列的第三篇，我们来说说Java中的栈在Java Collections API中有一个类叫做java.util.Stack，它的继承结构如下：1public class Stack&lt;E&gt; extends Vector&lt;E&gt; 它是在java.util.Vector类的基础上扩展了5个方法而来的12345public E push(E item)//进栈public synchronized E pop()//出栈，返回栈顶元素并将其删除public synchronized E peek()//取得栈顶元素（不删除）public boolean empty()//判断是否为空栈public synchronized int search(Object o)//详见问题四 Stack本身是扩展Vector而来的，而Vector是一个可增长的对象数组（The Vector class implements a growable array of objects），那么这个数组的哪部分成为了Stack的栈顶和栈底呢？ 问题一：Stack的栈顶和栈底在哪里？我们先来观察peek()方法的源码：1234567public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1);&#125; 这里调用了父类Vector的elementAt(int index)方法1234567891011public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; return elementData(index);&#125;@SuppressWarnings("unchecked")E elementData(int index) &#123; return (E) elementData[index];&#125; 通过观察以上源码，我们可以发现：调用peek()方法时，实际返回的是数组elementData的最后一位，也就是说，Stack的栈顶为Vector中数组的末端，相应的，数组起始端即为栈底事实上，在peek()方法的注释中也说明了这一点：return the object at the top of this stack (the last item of the Vector object). 问题二：Stack如何实现进栈操作？源码如下：12345public E push(E item) &#123; addElement(item); return item;&#125; 此处调用了其父类Vector的addElement(E item)，源码如下：123456789101112131415161718192021222324252627282930protected Object[] elementData;//默认初始化容量为10protected int elementCount;protected int capacityIncrement;public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125;private void ensureCapacityHelper(int minCapacity) &#123; if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; //默认的capacityIncrement为0，即默认扩容后新的容量为原来的两倍 int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 问题三：Stack如何实现出栈操作？源码如下：123456789public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj;&#125; 问题四：Stack中的search(Object o)方法返回的值表示什么意思？search(Object o)的源码（下面的注释是我从原方法注释中截取下来的）如下：1234567891011//The equals method is used to compare o to the items in this stack.//return the 1-based position from the top of the stack where the object is located; //the return value -1 indicates that the object is not on the stack.public synchronized int search(Object o) &#123; int i = lastIndexOf(o); if (i &gt;= 0) &#123; return size() - i; &#125; return -1;&#125; 这里调用了父类Vector的lastIndexOf(Object o)方法，从数组的最后往前找（也即从栈顶往下依次查找），查找第一次出现的位置（因为栈中元素是可以重复的），若没找到该对象，返回-1，否则返回该对象和栈顶元素之间的距离，返回值从1（表示所要查找的对象就是栈顶元素）开始下面的示例让我们很容易明白search(Object o)到底要返回的是什么？1234567Stack&lt;String&gt; s = new Stack&lt;&gt;();for(int i = 0 ;i &lt; 10;i++) s.push(String.valueOf(i));System.out.println("栈顶元素："+s.peek());System.out.println("9到栈顶的距离："+s.search("9"));System.out.println("0到栈顶的距离："+s.search("0"));System.out.println("10到栈顶的距离："+s.search("10")); 输出：1234栈顶元素：99到栈顶的距离：10到栈顶的距离：1010到栈顶的距离：-1 值得注意的是，search(Object o)方法的查找是基于对象的equals方法进行，若泛型申明为自定义的类型，需要重写equals方法 栈的应用之配对问题问题：输入一串字符串，判断其中的括号是否配对（可以引申为判断字符串是否为json串，是否为算数表达式等等），例如，[( )]是配对的，而[( ])]就不配对算法思想：先判断输入的字符串是否为空串（null或者” “等均认为是空串），若为空串则直接返回false。否则，实例化一个空栈。如果字符为(，[，{等开放符号，则让其进栈。如果字符为)，]，}等封闭符号，则当栈空时返回false。若栈不空，则判断栈顶字符是否为对应的开放字符，若不是，则返回false，否则继续判断下一个字符代码示例如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Stack;public class Main &#123; public static boolean isMatch(String json) &#123; if(isEmpty(json)) return false; char[] charArray = json.toCharArray(); Stack&lt;Character&gt; s = new Stack&lt;Character&gt;(); for(char c : charArray) &#123; if(c == '&#123;' || c == '[' || c == '(') s.push(c); else if(c == '&#125;') &#123; if(isMatch0(s,'&#123;')) s.pop(); else return false; &#125; else if(c == ']') &#123; if(isMatch0(s,'[')) s.pop(); else return false; &#125; else if(c == ')') &#123; if(isMatch0(s,'(')) s.pop(); else return false; &#125; &#125; return true; &#125; //当栈空时返回false。 //若栈不空，则判断栈顶字符是否为对应的开放字符，若不是，则返回false private static boolean isMatch0(Stack&lt;?&gt; s,char openChar) &#123; if(s.empty() || (char)s.peek() != openChar) return false; return true; &#125; public static boolean isEmpty(String str) &#123; return str == null || str.trim().isEmpty(); &#125; public static void main(String[] args) &#123; System.out.println(isMatch("&#123;[([asdfffffffffff])]&#125;")); System.out.println(isMatch("&#123;][])99(&#125;")); &#125;&#125; 输出结果12truefalse 结语java.util.Stack的注释中写道：A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class. For example: Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;();言下之意是相比Stack类，双端队列Deque和它的实现类具有更好的完整性和一致性，应该被优先使用 下回预告：数据结构与算法分析之Java中的队列Queue]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java collections api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架源码阅读之双链表LinkedList]]></title>
    <url>%2F2018%2F04%2F01%2Fjava-collections-api-linkedlist%2F</url>
    <content type="text"><![CDATA[本文只分析LinkedList的增(add) 删(remove) 改(set) 查(get)的实现，剩余的部分留给读者自己去浏览吧 本文是《Java集合框架源码阅读》系列的第二篇，我们的主角是java.util.LinkedList老规矩，先看LinkedList继承结构123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 构造方法：12public LinkedList()public LinkedList(Collection&lt;? extends E&gt; c) 成员属性：123transient int size = 0;transient Node&lt;E&gt; first;//头结点transient Node&lt;E&gt; last;//尾结点 问题一：LinkedList如何存储结点信息？查看源码可以发现，LinkedList内部有一个静态内部类Node&lt;E&gt;，其保存了当前结点的数据信息，以及指向其前驱和后继结点的链（或称指针）12345678910private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 问题二：LinkedList是如何实现尾部添加add(E e)方法的？源码如下：123456789101112131415public boolean add(E e) &#123; linkLast(e); return true;&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125; 解析：每当调用add(E e)方法时，首先调用linkLast(E e)，linkLast顾名思义，链接到尾结点，新建一个Node，让当前尾结点l成为其前驱结点，后继结点设为null，继而，新建的Node成为了新的尾结点，若原尾结点l尚未初始化，则让头结点指向新建的Node结点，否则，原来的尾节点L已经初始化了，则让新增结点成为原来的尾节点L的后继结点 我们都知道Java中的表List都是可以通过索引号（下标）获取结点值的，即 T get(int index)，ArrayList本身是数组，当然很好实现，而LinkedList却是双链表，它又是如何实现的呢？ 问题三：LinkedList是如何实现随机添加add(int index,E e)方法的？先来看下原理图： 第一步：newNode.prev = succ.prev; newNode.next = succ;第二步：succ.prev = newNode;第三步：if(pred != null) pred.next = newNode; else first = newNode;源码如下：123456789101112131415161718192021222324252627public void add(int index, E element) &#123; checkPositionIndex(index);//判断index是否为可以插入的位置 if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;private void checkPositionIndex(int index) &#123; if (!isPositionIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;private boolean isPositionIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt;= size;&#125;//在给定结点succ的前面插入一个新的结点，结点的值为evoid linkBefore(E e, Node&lt;E&gt; succ) &#123; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 问题四：LinkedList是如何实现get(int index)方法的？源码如下：12345678910111213141516171819202122232425public E get(int index) &#123; //检查是否满足0 &lt;= index &lt; size，不满足则抛出下标越界异常 checkElementIndex(index); return node(index).item;&#125;private void checkElementIndex(int index) &#123; if (!isElementIndex(index)) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125;private boolean isElementIndex(int index) &#123; return index &gt;= 0 &amp;&amp; index &lt; size;&#125;Node&lt;E&gt; node(int index) &#123; if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 可以发现，get(int index)中使用了一个node(int index)来获取指定下标的Node，而node(int index)又采用了二分法——首先判断指定索引位于LinkedList的前半部分，还是后半部分，这么做主要是为了提高效率，减少需要遍历的结点个数，然后依次遍历结点，直至找到指定下标的Node。从源码也可以看出来，LinkedList并不适合随机取数据，因为每次按照索引号随机取数据时，都需要依次遍历表 问题五：LinkedList是如何实现remove(int index)方法的？先看原理图：源码如下：123456789101112131415161718192021222324252627282930313233343536public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125;E unlink(Node&lt;E&gt; x) &#123; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; /* [===] ——&gt; [===] ——&gt; [===] * || || * null × first */ if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; /* [===] ——&gt; [===] ——&gt; [===] * || || * last × null */ if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 问题六：LinkedList是如何实现set(int index,E element)方法的？set方法的实现相对简单，源码如下：12345678//把element设为新的item，返回原来的itempublic E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; 作业：自己实现简单的单链表SingleLinkedList以及循环单/双链表CircularSingleLinkedList/CircularDoubleLinkedList下回预告：数据结构与算法分析之Java中的栈]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java collections api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架源码阅读之顺序表ArrayList]]></title>
    <url>%2F2018%2F03%2F30%2Fjava-collections-api-arraylist%2F</url>
    <content type="text"><![CDATA[今天是《Java集合框架源码阅读》的第一篇，我们来讲讲Java中的顺序表ArrayList首先来看下ArrayList的继承结构12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 构造方法：123public ArrayList(int initialCapacity)public ArrayList()public ArrayList(Collection&lt;? extends E&gt; c) 成员属性：123456private static final int DEFAULT_CAPACITY = 10;//ArrayList的默认容量private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//空数组private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;//默认容量的空数组transient Object[] elementData;private int size;//ArrayList中实际存储的元素个数private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 问题一：ArrayList的底层是采用什么实现的？查看ArrayList的源码可以发现如下代码:1transient Object[] elementData; 不难看出，ArrayList是采用数组实现的，事实上，ArrayList就是一个动态数组。 问题二：ArrayList是带泛型的，为什么不直接申明泛型数组T[]，而要采用Object型数组存储数据？java中不能直接实例化泛型数组，即不能new T[capacity];如果硬要申明泛型数组T[]，需创建一个泛型类型限界的数组，然后使用一个数组进行类型转换。这将产生一个编译器警告，但在泛型集合的实现中这是不可避免的。123T[] elementData;...elementData = (T[]) Object[capacity]; 我们都知道数组的长度是不变的，那么ArrayList是如何实现动态扩容的呢？ 问题三：ArrayList采用什么方式实现动态扩容？下面举个很简单的例子，大家就能明白了1234567891011static final DEFAULT_CAPACITY = 10;...int arr = new int[DEFAULT_CAPACITY];...//下面扩大arr容量int newCapacity = arr.length + arr.length / 2;int[] newArr = new int[newCapacity];for(int i = 0; i&lt; arr.length;i++) &#123; newArr[i] = arr[i];&#125;arr = newArr; 事实上，ArrayList内部也是采用的复制数组的方式实现动态扩容。至于其到底是如何做到的，请看下一个问题。 问题四：ArrayList的扩容机制？要回答这个问题，我们先得弄明白：当我们使用add(E e)时，ArrayList都干了什么123456//在尾部添加public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 可以看到，当我们调用add(E e)方法时，先执行的ensureCapacityInternal(size+1),然后将e加入elementData，size加1。ensureCapacityInternal直译为“确保内部容量”，它又是怎么实现的呢？​123456789//@param minCapacity 需要的最小容量private void ensureCapacityInternal(int minCapacity) &#123; //判断elementData是否为默认长度的空数组， //若是，则minCapacity取默认容量和原minCapacity的最大值 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125; 看到这里，又出现了一个新的方法ensureExplicitCapacity(int minCapacity)，ensureExplicitCapacity直译为“确保明确的容量”，接着往下挖​12345678private void ensureExplicitCapacity(int minCapacity) &#123; //modCount是ArrayList的父类AbstractList中定义的局部变量， //用于表示List的结构修改次数 modCount++; // 如果minCapacity超过了ArrayList的容量，则对其扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 这里出现了一个新的方法grow(int minCapacity)，grow意为“成长”，这就是ArrayList动态扩容的秘密吗？我们接着往下看 ​1234567891011private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; //每次扩容后，新的容量为原来容量的1.5倍，oldCapacity &gt;&gt; 1等价于 oldCapacity / 2 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); //通过复制数组的方式，将数组扩容 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 其中出现了一个新的变量MAX_ARRAY_SIZE，ArrayList中对它的定义如下：1private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 为什么这么定义？ 源代码中的注释如下：The maximum size of array to allocate. Some VMs reserve some header words in an array.Attempts to allocate larger arrays may result in OutOfMemoryError: Requested array size exceeds VM limit翻译：可分配的最大的数组大小。一些虚拟机在数组中保留了一些头部信息。试图给数组分配更大的空间可能导致内存溢出错误：请求的数组大小超过了虚拟机的限制 12345678910//给定需要的最小容量，如果所给最小容量小于0，抛出内存溢出错误，//如果最小容量大于ArrayList定义的最大数组长度，则返回Integer的最大值，//否则，返回ArrayList定义的最大数组长度private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 作业：自己动手实现简单的ArrayList下回预告：数据结构与算法分析之Java中的双链表LinkedList]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java collections api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从阿里云服务器到使用github pages的变迁]]></title>
    <url>%2F2018%2F03%2F24%2Fblog%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;从2016年5月20号晚上注册了域名 http://www.hegongshan.com ，一直到2017年9月，我在阿里云上租用了一年多的云服务器。由于那时候是新手，所以保守的选择了windows server，而且是最低档的配置——1核1G内存20G磁盘，每个月80多，没办法，谁叫咱穷。&nbsp;&nbsp;&nbsp;&nbsp;一年多的时间，我的个人博客也经历了数次重构，从最开始采用最原始的JSP+Servlet+JDBC，到后来痴迷SSM，沉迷freemarker，再到后来觉得SSM项目jar包太多太大，占用内存过多，经常发生OOM，又想到将MyBatis砍掉，就采用Spring JdbcTemplate来处理dao层，直到现在选择了hexo和github pages。个人博客的搭建和维系，真是让人心累。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
